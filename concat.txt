===== ./index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ENVULN — Threat Path Explorer</title>
  <link rel="stylesheet" href="./styles/app.css">
</head>

<body>
<div class="wrap">

  <!-- LEFT PANEL — Add + Manage Entities -->
  <div class="panel" id="panelEntities">
    <h3>Add & Manage</h3>
    <div class="small">Add, rename, or delete entities here.</div>

    <!-- Add forms -->
    <div class="form-block">
      <label>New attacker</label>
      <div class="row">
        <input id="attackerName" placeholder="Attacker name">
        <button id="btnAddAttacker">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New target</label>
      <div class="row">
        <input id="targetName" placeholder="Target name">
        <button id="btnAddTarget">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New vulnerability</label>
      <div class="row">
        <input id="vulnName" placeholder="Vulnerability name">
        <button id="btnAddVuln">Add</button>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnResetAll" class="ghost">Reset all</button>
    </div>

    <hr>

    <!-- Entity Lists -->
    <h3>Attackers</h3>
    <div id="attackerList" class="list"></div>

    <h3>Attacker targets</h3>
    <div id="targetList" class="list"></div>

    <h3>Vulnerabilities</h3>
    <div id="vulnList" class="list"></div>
  </div>

  <!-- CENTER PANEL — Associations / Compute / Results -->
  <div class="panel" id="panelAssociations">
    <h3>Configuration & Exploration</h3>

    <div class="row ceiling-row">
      <!-- (Simulation speed and Path limit moved to the right panel) -->
    </div>

    <hr>

    <!-- Attacker selection -->
    <h3>Attacker selection</h3>
    <div class="small">Choose the current attacker.</div>
    <div class="row">
      <select id="selAttacker"></select>
    </div>

    <hr>

    <!-- Entry points selection -->
    <h3>Attacker entry points</h3>
    <div class="small">Select targets that act as entry points for the attacker.</div>
    <div class="row">
      <select id="selEntriesAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearEntries" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Exit points selection -->
    <h3>Attacker exit points</h3>
    <div class="small">Select targets that act as exit points for the attacker.</div>
    <div class="row">
      <select id="selExitsAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearExits" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Vulnerability association -->
    <h3>Vulnerabilities</h3>
    <div class="small">Pick an element, then select/unselect the vulnerabilities to associate.</div>

    <div class="row">
      <div class="col">
        <label>Element to edit</label>
        <select id="selVulnElement">
          <!-- filled by JS -->
        </select>
      </div>

      <div class="col">
        <label>Vulnerabilities (multi)</label>
        <select id="selVulnsForElement" multiple size="6"></select>
      </div>
    </div>

    <div class="row">
      <button id="btnClearVulnSelection" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Links -->
    <h3>Links between targets</h3>
    <div class="row">
      <select id="linkSource"></select>
      <select id="linkDest" multiple size="4"></select>
      <select id="linkType">
        <option value="direct">direct</option>
        <option value="lateral">lateral</option>
        <option value="contains">contains</option>
      </select>
    </div>

    <div class="row">
      <button id="btnClearLinkSelection" class="ghost">Clear selection</button>
    </div>
    <div class="row">
      <label><input type="checkbox" id="includeLateral" checked> include lateral</label>
      <label><input type="checkbox" id="includeContains" checked> include contains</label>
    </div>

    <div id="linksInspector" class="small"></div>

    <hr>

    <!-- Actions -->
    <div class="row top-actions">
      <button id="btnFindPaths">Compute paths</button>
      <button id="btnExportODS" class="ghost">Export ODS</button>
      <button id="btnImportJSON" class="ghost">Import JSON</button>
      <button id="btnExportJSON" class="ghost">Export JSON</button>
      <button id="btnSimu" class="ghost">Simulation</button>
      <input type="file" id="fileIn" accept="application/json" hidden>
      <span id="status" class="small">—</span>
    </div>

    <hr>

    <!-- Results -->
    <h3 style="display:flex;align-items:center;gap:10px">
      Results
      <label class="small" style="display:inline-flex;align-items:center;gap:6px">
        <input type="checkbox" id="chkOnlyVuln">
        Vulnerable paths only
      </label>
    </h3>

    <div id="results" class="path-list"></div>
  </div>

  <!-- RIGHT PANEL — Tutorial + Configuration + Diagram -->
  <div class="panel" id="panelDetailsRight">
    <h3>Tutorial</h3>
    <ol id="tutorial" class="small">
      <li>Add attackers, targets, and vulnerabilities in the left panel.</li>
      <li>Select the current attacker from “Attacker selection”.</li>
      <li>Choose attacker entry points, then use “Clear selection” if needed.</li>
      <li>Choose attacker exit points, then use “Clear selection” if needed.</li>
      <li>Select an element and pick vulnerabilities to associate; use “Clear selection” to reset.</li>
      <li>Configure links between targets; use “Clear selection” to reset the link pickers.</li>
      <li>Adjust path visibility (include lateral/contains) using the checkboxes.</li>
      <li>Click “Compute paths” to generate results.</li>
      <li>Select a path to view the attack diagram.</li>
      <li>Use the playback controls to play, pause, stop, restart, step back, or step forward the simulation.</li>
      <li>Export data as needed (JSON/ODS).</li>
    </ol>

    <hr>

    <!-- Playback controls (above simulation speed) -->
    <div class="row" id="playbackRow" style="justify-content:center;gap:10px">
      <button id="btnStepBack" class="ghost" title="Step back" aria-label="Step back">⏮</button>
      <button id="btnPlayPause" title="Play/Pause" aria-label="Play or pause">▶</button>
      <button id="btnStepForward" class="ghost" title="Step forward" aria-label="Step forward">⏭</button>
      <button id="btnStop" class="ghost" title="Stop" aria-label="Stop">⏹</button>
      <button id="btnRestart" class="ghost" title="Restart" aria-label="Restart">↺</button>
    </div>
    
    <div class="row">
      <div class="col speed-col">
        <label for="simSpeed">Simulation speed</label>
        <input id="simSpeed" type="range" min="0.2" max="3" step="0.1" value="1">
        <span id="simSpeedValue">×1.0</span>
      </div>
    </div>

    <hr>

    <div class="row ceiling-row">
      <label for="maxPaths">Path limit</label>
      <input type="number" id="maxPaths" min="100" value="2000">
    </div>

    <hr>

    <h3>Attack diagram</h3>
    <div id="diagramBox" class="uml"><div class="small">Select a path → Diagram</div></div>

    <div class="row">
      <button id="btnDownloadSVG" class="ghost">Download SVG</button>
      <span id="svgSize" class="small">—</span>
    </div>
  </div>

</div>

<script type="module" src="./js/main.js"></script>
</body>
</html>

===== ./js/ui/links.js =====
// js/ui/links.js
// UI logic for managing links between targets using the selectors present in the page.

import { State, ensureEdgeMaps } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

/* =========================
   Internal helpers
========================= */

function nameOfTarget(id) {
  const t = State.targets.find(x => x.id === id);
  return t ? t.name : '?';
}

function getLinkMapByType(type) {
  if (type === 'direct')   return State.edges.direct;
  if (type === 'lateral')  return State.edges.lateral;
  if (type === 'contains') return State.edges.contains;
  return null;
}

function addLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map) return;
  ensureEdgeMaps(from);
  map[from].add(to);
}

function removeLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map || !map[from]) return;
  map[from].delete(to);
}

function clearAndFillSelect(selectEl, items) {
  selectEl.innerHTML = '';
  items.forEach(({ id, name }) => {
    const o = document.createElement('option');
    o.value = id;
    o.textContent = name;
    selectEl.appendChild(o);
  });
}

/* =========================
   Populate selectors
========================= */

export function populateLinkSelectors() {
  const src = el('linkSource');
  const dst = el('linkDest');
  const type = el('linkType');

  if (!src || !dst || !type) return;

  const items = State.targets.map(t => ({ id: t.id, name: t.name }));
  clearAndFillSelect(src, items);
  clearAndFillSelect(dst, items);

  if (!['direct', 'lateral', 'contains'].includes(type.value)) {
    type.value = 'direct';
  }
}

/* =========================
   Links inspector
========================= */

export function renderLinksInspector() {
  const box = el('linksInspector');
  const src = el('linkSource')?.value;

  if (!box) return;

  if (!src) {
    box.innerHTML = '<div class="mini">Pick a source to view its links.</div>';
    return;
  }

  const makeGroup = (label, mapObj, typeKey) => {
    const set = mapObj[src] || new Set();
    const items = Array.isArray(set) ? set : [...set];
    if (!items.length) {
      return `<div style="margin-top:6px"><strong>${label}:</strong> —</div>`;
    }
    const chips = items.map(toId => {
      const tName = nameOfTarget(toId);
      const btn = `<button data-type="${typeKey}" data-to="${toId}" class="ghost" style="padding:2px 6px;border-radius:6px">Remove</button>`;
      return `<span class="badge" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${tName}${btn}</span>`;
    }).join(' ');
    return `<div style="margin-top:6px"><strong>${label}:</strong><div style="margin-top:4px">${chips}</div></div>`;
  };

  box.innerHTML = [
    `<div class="mini">Links from <strong>${nameOfTarget(src)}</strong> (use "Remove" to delete)</div>`,
    makeGroup('direct',   State.edges.direct,   'direct'),
    makeGroup('lateral',  State.edges.lateral,  'lateral'),
    makeGroup('contains', State.edges.contains, 'contains'),
  ].join('');

  box.onclick = (e) => {
    const btn = e.target.closest('button[data-to]');
    if (!btn) return;
    const type = btn.getAttribute('data-type');
    const to   = btn.getAttribute('data-to');
    removeLink(type, src, to);
    saveToLocal(State);
    renderLinksInspector();
    // Keep the destination multiselect visually in sync
    syncDestSelectionFromState();
  };
}

/* =========================
   Event wiring
========================= */

let _syncDestSelectionFromState = null;
function syncDestSelectionFromState() {
  // late-bound to avoid accessing elements before ready
  if (typeof _syncDestSelectionFromState === 'function') {
    _syncDestSelectionFromState();
  }
}

export function wireLinksUI() {
  const srcSel   = el('linkSource');
  const dstSel   = el('linkDest');
  const typeSel  = el('linkType');
  const btnClear = el('btnClearLinkSelection');

  if (!srcSel || !dstSel || !typeSel) return;

  _syncDestSelectionFromState = () => {
    const from = srcSel.value;
    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    const set = map[from] || new Set();
    const current = new Set(Array.isArray(set) ? set : Array.from(set));
    [...dstSel.options].forEach(o => { o.selected = current.has(o.value); });
    renderLinksInspector();
  };

  srcSel.addEventListener('change', _syncDestSelectionFromState);
  typeSel.addEventListener('change', _syncDestSelectionFromState);

  // Real-time persistence on every change
  dstSel.addEventListener('change', () => {
    const from = srcSel.value;
    if (!from) return;

    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    ensureEdgeMaps(from);

    const before = new Set(Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []));
    const after  = new Set([...dstSel.selectedOptions].map(o => o.value));

    for (const to of after) {
      if (!before.has(to)) addLink(type, from, to);
    }
    for (const to of before) {
      if (!after.has(to)) removeLink(type, from, to);
    }

    saveToLocal(State);
    renderLinksInspector();
  });

  // Clear selection button: clears UI and state through the change handler
  if (btnClear) {
    btnClear.onclick = () => {
      [...dstSel.options].forEach(o => o.selected = false);
      dstSel.dispatchEvent(new Event('change', { bubbles: true }));
    };
  }

  populateLinkSelectors();
  _syncDestSelectionFromState();
}

===== ./js/ui/results.js =====
// js/ui/results.js
// Module responsible for rendering computed attack paths (results panel).
// Exports: initResultsPanel, renderResults, computeAndRenderAll, renderDiagramForPath, getLastResults, getLastMeta
// Dependencies: ../helpers.js (el, esc), ../paths.js (computeAllPaths), ../diagram.js (buildSVGForPath), ../state.js (State)

import { el, esc } from '../helpers.js';
import { computeAllPaths } from '../paths.js';
import { buildSVGForPath } from '../diagram.js';
import { State } from '../state.js';
import { exportODS } from '../exportODS.js'; // optional: if you implemented exporter

// Internal cache
let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

// UI element references (populated on init)
let resultsBox = null;
let chkOnlyVuln = null;
let statusEl = null;
let svgContainer = null;
let svgSizeEl = null;
let downloadSvgBtn = null;

/* ---------- UTIL ---------- */
// By design, we ignore the *first* node of the path for the vuln-everywhere filter,
// because entry nodes often don't carry a vulnerability in the model.
const hasVulnsEverywhere = (path) => {
  if (!Array.isArray(path.vulnsPerNode)) return false;
  const slice = path.vulnsPerNode.slice(1);
  if (!slice.length) return false;
  return slice.every(vs => Array.isArray(vs) && vs.length > 0);
};

const getDisplayResults = () => {
  if (chkOnlyVuln && chkOnlyVuln.checked) {
    return lastResults.filter(hasVulnsEverywhere);
  }
  return lastResults;
};

function renderSummary(count, meta = {}) {
  if (!statusEl) return;
  const parts = [];
  parts.push(`${count} path${count === 1 ? '' : 's'}`);
  if (meta.cycles) parts.push('cycles detected (simple paths)');
  if (meta.truncated) parts.push('truncated by ceiling');
  statusEl.textContent = parts.join(' • ');
}

/* ---------- RENDER RESULTS ---------- */
function renderResults(resultsArray, meta = {}) {
  if (!resultsBox) return;
  // Cache full (unfiltered) set and metadata
  lastResults = Array.isArray(resultsArray) ? resultsArray.slice() : [];
  lastMeta = Object.assign({}, meta);

  // Decide what to display
  const toDisplay = getDisplayResults();

  resultsBox.innerHTML = '';
  if (!toDisplay.length) {
    const empty = document.createElement('div');
    empty.className = 'small';
    const filtered = !!(chkOnlyVuln && chkOnlyVuln.checked);
    empty.textContent = filtered
      ? 'No paths match the “only vulnerable” filter.'
      : 'No paths (check entry points, finals and link types).';
    resultsBox.appendChild(empty);
    renderSummary(0, meta);
    return;
  }

  // Build entries
  toDisplay.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.alignItems = 'flex-start';
    row.style.gap = '10px';
    row.style.padding = '8px';
    row.style.borderRadius = '8px';
    row.style.background = 'rgba(255,255,255,0.02)';

    // Left column: attacker + chain + vulns summary
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.flexDirection = 'column';
    left.style.gap = '6px';

    const title = document.createElement('div');
    title.innerHTML = `<strong>${esc(p.attacker)}</strong>`;
    left.appendChild(title);

    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.appendChild(chain);

    const vulnSummary = document.createElement('div');
    vulnSummary.className = 'mini';
    vulnSummary.style.fontSize = '12px';
    vulnSummary.style.color = 'var(--muted)';
    vulnSummary.textContent = p.vulnsPerNode.map((vs, i) =>
      vs && vs.length ? `[${p.nodes[i].name}: ${vs.join(', ')}]` : `[${p.nodes[i].name}: —]`
    ).join(' ');
    left.appendChild(vulnSummary);

    // Optionally grey-out impossible paths
    if (!hasVulnsEverywhere(p)) {
      row.style.opacity = '0.72';
      row.title = 'One or more targets have no vulnerabilities (path theoretically impossible)';
    }

    // Right column: actions
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.flexDirection = 'column';
    right.style.gap = '6px';
    right.style.alignItems = 'flex-end';

    const btnDiagram = document.createElement('button');
    btnDiagram.textContent = 'Diagram';
    btnDiagram.className = 'ghost';
    btnDiagram.onclick = () => {
      renderDiagramForPath(p);
      // focus diagram in UI
      if (svgContainer) svgContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
    };

    const btnZoom = document.createElement('button');
    btnZoom.textContent = 'Zoom';
    btnZoom.className = 'ghost';
    btnZoom.onclick = () => {
      // If a diagram is already rendered for this path, try to center it
      if (svgContainer) {
        svgContainer.style.boxShadow = '0 0 0 4px rgba(59,130,246,0.18)';
        setTimeout(() => svgContainer.style.boxShadow = 'none', 800);
      }
    };

    right.appendChild(btnDiagram);
    right.appendChild(btnZoom);

    row.appendChild(left);
    row.appendChild(right);
    resultsBox.appendChild(row);
  });

  renderSummary(toDisplay.length, meta);
}

/* ---------- DIAGRAM rendering + download ---------- */
function renderDiagramForPath(pathObj) {
  if (!svgContainer) return;
  try {
    // Pass live State so the builder can resolve entries, edge types, etc.
    const svgStr = buildSVGForPath(pathObj, State);
    svgContainer.innerHTML = svgStr;

    // store last svg for download
    const svgEl = svgContainer.querySelector('svg');
    if (svgEl) {
      // update size display (if provided)
      if (svgSizeEl) {
        const w = svgEl.getAttribute('width') || svgEl.viewBox?.baseVal?.width || svgEl.getBoundingClientRect().width;
        const h = svgEl.getAttribute('height') || svgEl.viewBox?.baseVal?.height || svgEl.getBoundingClientRect().height;
        svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
      }
      // attach download helper
      if (downloadSvgBtn) {
        downloadSvgBtn.onclick = () => {
          const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
          const ts = new Date().toISOString().replace(/[:.]/g, '-');
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `attack-diagram-${ts}.svg`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(a.href), 0);
        };
      }
    }
  } catch (err) {
    console.error('renderDiagramForPath:', err);
    if (svgContainer) svgContainer.innerHTML = `<div class="small">Failed to render diagram: ${esc(String(err))}</div>`;
  }
}

/* ---------- Compute (bridge to paths.js) ---------- */
async function computeAndRenderAll(state, opts = { includeLateral: true, includeContains: true, maxPaths: 2000 }) {
  // computeAllPaths returns an object { paths, cycles, truncated }
  const out = computeAllPaths(state, opts, opts.maxPaths);
  const arr = Array.isArray(out?.paths) ? out.paths : [];

  // ensure normalized shape: nodes are target objects and vulnsPerNode array exists
  const normalized = arr.map(r => {
    return {
      attacker: r.attackerName || r.attacker || r.attackerId || '',
      attackerId: r.attackerId || '',
      nodes: r.nodes || (r.nodeIds || []).map(id => ({ id, name: id })), // fallback
      vulnsPerNode: Array.isArray(r.vulnsPerNode) ? r.vulnsPerNode : (r.nodes ? r.nodes.map(() => []) : [])
    };
  });

  const meta = { cycles: !!out.cycles, truncated: !!out.truncated };

  // render
  renderResults(normalized, meta);
  return normalized;
}

/* ---------- Initialization ---------- */
function initResultsPanel(opts = {}) {
  resultsBox = el(opts.resultsBoxId || 'results');
  chkOnlyVuln = el(opts.chkOnlyVulnId || 'chkOnlyVuln');
  statusEl = el(opts.statusId || 'status');
  svgContainer = el(opts.svgContainerId || 'diagramBox');
  svgSizeEl = el(opts.svgSizeId || 'svgSize');
  downloadSvgBtn = el(opts.downloadSvgBtnId || 'btnDownloadSVG');

  // bind checkbox to re-render current cache
  if (chkOnlyVuln) {
    chkOnlyVuln.addEventListener('change', () => {
      renderResults(getDisplayResults(), lastMeta);
    });
  }

  // wire export ODS (if exporter present)
  const exportBtn = el(opts.exportOdsBtnId || 'btnExportODS');
  if (exportBtn && typeof exportODS === 'function') {
    exportBtn.addEventListener('click', () => {
      // Use filtered display results if checkbox on, else use full
      const toExport = chkOnlyVuln && chkOnlyVuln.checked ? getDisplayResults() : lastResults;
      if (!toExport || !toExport.length) return alert('No paths to export.');
      exportODS(State, { results: toExport });
    });
  }
}

/* ---------- accessors for other modules / app -------- */
function getLastResults() { return lastResults.slice(); }
function getLastMeta() { return Object.assign({}, lastMeta); }

export {
  initResultsPanel,
  renderResults,
  computeAndRenderAll,
  renderDiagramForPath,
  getLastResults,
  getLastMeta
};

===== ./js/ui/editors.js =====
// js/ui/editors.js
// Editor UI module: target editor, attacker editor, details panel
// Imports expected from the modular structure:
//  - State (singleton) from ../state.js
//  - saveToLocal(state) from ../storage.js
//  - helpers: el, norm
//
// The module emits `document.dispatchEvent(new CustomEvent('state:changed'))`
// after any mutation so other UI modules can re-render.

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el, norm } from '../helpers.js';

function emitChange() {
  try { saveToLocal(State); } catch (e) { console.warn('save failed', e); }
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------- Target editor (vulns / final flag) ---------- */
export function renderTargetEditor(targetId) {
  const details = el('details');
  if (!details) return;

  const target = State.targets.find(t => t.id === targetId);
  if (!target) {
    details.innerHTML = `<div class="small">Select a target to edit its vulnerabilities and properties.</div>`;
    return;
  }

  // Build editor UI
  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  // Header: name + rename button
  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(target.name)}</strong>`;
  const headerRow = document.createElement('div');
  headerRow.className = 'row';
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename target', target.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    // check duplicates
    if (State.targets.some(t => t.name.toLowerCase() === n.toLowerCase() && t.id !== target.id)) return alert('Name already used');
    target.name = n;
    emitChange();
  };
  const finalLabel = document.createElement('label');
  finalLabel.className = 'small';
  finalLabel.style.display = 'inline-flex';
  finalLabel.style.alignItems = 'center';
  finalLabel.style.gap = '8px';
  const finalCb = document.createElement('input');
  finalCb.type = 'checkbox';
  finalCb.checked = !!target.final;
  finalCb.onchange = () => {
    target.final = finalCb.checked;
    emitChange();
  };
  finalLabel.append(finalCb, document.createTextNode(' Final flag'));
  headerRow.append(header, finalLabel, renameBtn);
  wrapper.appendChild(headerRow);

  // Vulnerabilities editor
  const vLabel = document.createElement('div');
  vLabel.className = 'small';
  vLabel.textContent = 'Vulnerabilities (check all that apply)';
  wrapper.appendChild(vLabel);

  const vulnBox = document.createElement('div');
  vulnBox.className = 'col';
  vulnBox.style.marginTop = '6px';

  // For each global vulnerability, show checkbox
  State.vulns.forEach(v => {
    const lab = document.createElement('label');
    lab.className = 'small';
    lab.style.display = 'flex';
    lab.style.alignItems = 'center';
    lab.style.gap = '8px';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    const currentVulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    cb.checked = currentVulns.has(v.id);
    cb.onchange = () => {
      target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
      if (cb.checked) target.vulns.add(v.id);
      else target.vulns.delete(v.id);
      emitChange();
    };
    const span = document.createElement('span');
    span.textContent = v.name;
    lab.append(cb, span);
    vulnBox.appendChild(lab);
  });

  // Add quick "add new vuln" line
  const addVRow = document.createElement('div');
  addVRow.className = 'row';
  addVRow.style.marginTop = '6px';
  const inputNewV = document.createElement('input');
  inputNewV.type = 'text';
  inputNewV.placeholder = 'New vulnerability name';
  inputNewV.style.flex = '1';
  const addVBtn = document.createElement('button');
  addVBtn.textContent = 'Add & attach';
  addVBtn.onclick = () => {
    const name = norm(inputNewV.value);
    if (!name) return alert('Name required');
    // avoid duplicate vulnerability names
    if (State.vulns.some(x => x.name.toLowerCase() === name.toLowerCase())) {
      // attach existing vuln if present
      const existing = State.vulns.find(x => x.name.toLowerCase() === name.toLowerCase());
      if (existing) {
        target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
        target.vulns.add(existing.id);
        inputNewV.value = '';
        emitChange();
        return;
      }
      return;
    }
    // create new vuln id and add globally
    const id = (Date.now().toString(36) + Math.random().toString(36).slice(2,6));
    State.vulns.push({ id, name });
    // attach to target
    target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    target.vulns.add(id);
    inputNewV.value = '';
    emitChange();
  };
  addVRow.append(inputNewV, addVBtn);

  wrapper.appendChild(vulnBox);
  wrapper.appendChild(addVRow);

  // Links quick view (read-only summary)
  const linksLabel = document.createElement('div');
  linksLabel.className = 'small';
  linksLabel.style.marginTop = '10px';
  linksLabel.textContent = 'Outgoing links (summary)';
  wrapper.appendChild(linksLabel);

  const linksSummary = document.createElement('div');
  linksSummary.className = 'small';
  linksSummary.style.marginTop = '6px';
  // summarise by type
  const outDirect = (State.edges.direct[target.id] || new Set());
  const outLat = (State.edges.lateral[target.id] || new Set());
  const outContains = (State.edges.contains[target.id] || new Set());
  linksSummary.innerHTML = `
    <div><strong>Direct:</strong> ${[...outDirect].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Lateral:</strong> ${[...outLat].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Contains:</strong> ${[...outContains].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
  `;
  wrapper.appendChild(linksSummary);

  // put everything in details
  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Attacker editor (entries multi-select) ---------- */
export function renderAttackerEditor(attackerId) {
  const details = el('details');
  if (!details) return;

  const attacker = State.attackers.find(a => a.id === attackerId);
  if (!attacker) {
    details.innerHTML = `<div class="small">Select an attacker to edit its entry points.</div>`;
    return;
  }

  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(attacker.name)}</strong>`;
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename attacker', attacker.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    if (State.attackers.some(x => x.name.toLowerCase() === n.toLowerCase() && x.id !== attacker.id)) return alert('Name already used');
    attacker.name = n;
    emitChange();
  };
  header.appendChild(renameBtn);
  wrapper.appendChild(header);

  // Entries multi-select
  const lbl = document.createElement('div');
  lbl.className = 'small';
  lbl.textContent = 'Entry points (select one or many from targets below)';
  wrapper.appendChild(lbl);

  const sel = document.createElement('select');
  sel.id = 'editorEntriesSelect';
  sel.multiple = true;
  sel.size = Math.min(10, Math.max(6, State.targets.length));
  sel.style.width = '100%';

  // Normalize attacker.entries to a Set before checking membership
  const entriesSet = attacker.entries instanceof Set ? attacker.entries : new Set(attacker.entries || []);

  State.targets.forEach(t => {
    const o = document.createElement('option');
    o.value = t.id;
    o.textContent = t.name;
    o.selected = entriesSet.has(t.id);
    sel.appendChild(o);
  });

  sel.onchange = () => {
    const picked = [...sel.selectedOptions].map(o => o.value);
    attacker.entries = new Set(picked);
    emitChange();
  };

  wrapper.appendChild(sel);

  // Quick helpers: select all / none
  const btnRow = document.createElement('div');
  btnRow.className = 'row';
  const btnAll = document.createElement('button');
  btnAll.textContent = 'Select all';
  btnAll.onclick = () => {
    for (const o of sel.options) { o.selected = true; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  const btnNone = document.createElement('button');
  btnNone.textContent = 'Select none';
  btnNone.className = 'ghost';
  btnNone.onclick = () => {
    for (const o of sel.options) { o.selected = false; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  btnRow.append(btnAll, btnNone);
  wrapper.appendChild(btnRow);

  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Helpers & init ---------- */
function escapeHtml(s) {
  return String(s||'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
}

/**
 * Re-render whichever details panel is relevant to the current selection.
 * If a target is selected, render the target editor; otherwise, if an attacker is
 * selected, render the attacker editor. If nothing is selected, clear the panel.
 */
export function hydrateDetailsPanel() {
  const details = el('details');
  if (!details) return;

  const selTarget = el('selectTarget') || el('linkSource');
  const selAttacker = el('selAttacker');

  if (selTarget && selTarget.value) {
    renderTargetEditor(selTarget.value);
    return;
  }
  if (selAttacker && selAttacker.value) {
    renderAttackerEditor(selAttacker.value);
    return;
  }
  details.innerHTML = `<div class="small">Select an attacker or target to edit.</div>`;
}

/**
 * initEditors
 * - wires main high-level editor controls: when selectAttacker changes, render attacker editor;
 *   when selectTarget changes, render target editor.
 * - listens to global `state:changed` to re-populate selects (targets / vulns) so editors remain live.
 */
export function initEditors() {
  // populate initial selects in the central UI if they exist
  const selAttacker = el('selAttacker');
  const selTarget = el('selectTarget') || el('linkSource'); // support both naming conventions
  // When attacker selection changes, present attacker editor
  if (selAttacker) {
    selAttacker.onchange = () => {
      renderAttackerEditor(selAttacker.value);
    };
  }

  // When target selection changes, present target editor
  if (selTarget) {
    selTarget.onchange = () => {
      renderTargetEditor(selTarget.value);
    };
  }

  // when global state changes, re-populate selects so editors remain in sync
  document.addEventListener('state:changed', () => {
    // re-fill attacker select
    if (selAttacker) {
      const cur = selAttacker.value;
      selAttacker.innerHTML = '';
      State.attackers.forEach(a => {
        const o = document.createElement('option');
        o.value = a.id; o.textContent = a.name;
        selAttacker.appendChild(o);
      });
      if (State.attackers.some(a=>a.id===cur)) selAttacker.value = cur;
    }
    // re-fill central target selects used by UI
    const selTargets = [ 'selectTarget', 'linkSource', 'linkDest', 'selEntriesAll', 'selectStartPool' ];
    selTargets.forEach(id => {
      const s = el(id);
      if (!s) return;
      const prev = s.value;
      const selectedValues = [...(s.selectedOptions || [])].map(o => o.value);
      s.innerHTML = '';
      State.targets.forEach(t => {
        const o = document.createElement('option'); o.value = t.id; o.textContent = t.name;
        // re-select previously selected items if still present
        if (selectedValues.includes(o.value)) o.selected = true;
        s.appendChild(o);
      });
      if (prev && [...s.options].some(o => o.value === prev)) s.value = prev;
    });

    // If there is a currently rendered details editor, re-render it to reflect vulnerabilities and flags
    hydrateDetailsPanel();
  });

  // initial population in case DOM is already ready
  document.dispatchEvent(new CustomEvent('state:changed'));
}

===== ./js/ui/lists.js =====
// js/ui/lists.js
// Utilities and renderers for side lists and central selectors.

import { State, deleteAttacker, deleteTarget, deleteVuln } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

import { hydrateDetailsPanel } from './editors.js';
import { renderLinksInspector as _renderLinksInspector } from './links.js';
import { renderResults } from './results.js';

/* ---------------------------------------------------------- */
/* Small DOM helpers                                           */
/* ---------------------------------------------------------- */
function createButton(label, onClick, ghost = false){
  const b = document.createElement('button');
  b.textContent = label;
  b.className = ghost ? 'ghost' : '';
  b.onclick = onClick;
  return b;
}

function badge(text){
  const d = document.createElement('div');
  d.className = 'badge';
  d.textContent = text;
  return d;
}

function mini(text){
  const d = document.createElement('div');
  d.className = 'mini';
  d.textContent = text;
  return d;
}

function emitStateChanged() {
  try { saveToLocal(State); } catch(e) {}
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------------------------------------------------------- */
/* setOptions : peuple un <select> et conserve la sélection    */
/* - Si `selected` est fourni (Set), il est prioritaire.       */
/* - Sinon on restaure la sélection précédente (multi/single). */
/* ---------------------------------------------------------- */
export function setOptions(
  selectEl,
  items,
  { getValue = x => x.id, getLabel = x => x.name, selected = null } = {}
){
  if(!selectEl) return;

  const wasMultiple = !!selectEl.multiple;

  // capture sélection courante
  const prevSelected = wasMultiple
    ? new Set([...selectEl.selectedOptions].map(o => String(o.value)))
    : new Set(selectEl.value ? [String(selectEl.value)] : []);

  const prevValue = selectEl.value;

  // rebuild
  selectEl.innerHTML = '';
  (items || []).forEach(item => {
    const val = String(getValue(item));
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = String(getLabel(item));

    // priorité: selected (fourni) > sélection précédente
    if (selected instanceof Set) {
      opt.selected = selected.has(val);
    } else if (prevSelected.has(val)) {
      opt.selected = true;
    }

    selectEl.appendChild(opt);
  });

  // pour les selects non-multiples, restaurer la value si possible
  if (!wasMultiple && prevValue && [...selectEl.options].some(o => o.value === prevValue)) {
    selectEl.value = prevValue;
  }
}

/* ---------------------------------------------------------- */
/* Side panel : ATTACKERS                                     */
/* ---------------------------------------------------------- */
export function renderAttackers(){
  const container = el('attackerList');
  if(!container) return;
  container.innerHTML = '';

  (State.attackers || []).forEach(a => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    const entries = a.entries instanceof Set ? a.entries : new Set(a.entries || []);
    left.appendChild(badge(a.name));
    left.appendChild(mini(`Entries: ${[...entries].map(id => {
      const t = (State.targets || []).find(x => x.id === id);
      return t ? t.name : '?';
    }).join(', ') || '—'}`));

    const right = document.createElement('div');

    // rename
    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename attacker', a.name);
      if(!name) return;
      a.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    // delete
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete attacker?')){
        deleteAttacker(a.id);
        emitStateChanged();
        renderAllLists();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : TARGETS                                       */
/* ---------------------------------------------------------- */
export function renderTargets(){
  const container = el('targetList');
  if(!container) return;
  container.innerHTML = '';

  (State.targets || []).forEach(t => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    left.appendChild(badge(t.name));

    const vulnsSet = t.vulns instanceof Set ? t.vulns : new Set(t.vulns || []);
    left.appendChild(mini(`Vulns: ${
      [...vulnsSet].map(id => (State.vulns || []).find(v => v.id === id)?.name || '?').join(', ') || '—'
    }`));

    const right = document.createElement('div');

    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename target', t.name);
      if(!name) return;
      t.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete target?')){
        deleteTarget(t.id);
        emitStateChanged();
        renderAllLists();
        renderLinksInspector();
        renderResults([]);
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : VULNERABILITIES                               */
/* ---------------------------------------------------------- */
export function renderVulns(){
  const container = el('vulnList');
  if(!container) return;
  container.innerHTML = '';

  (State.vulns || []).forEach(v => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';
    left.appendChild(badge(v.name));

    const right = document.createElement('div');
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete vulnerability?')){
        deleteVuln(v.id);
        emitStateChanged();
        renderAllLists();
        hydrateDetailsPanel();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Re-render lists globally                                   */
/* ---------------------------------------------------------- */
export function renderAllLists(){
  renderAttackers();
  renderTargets();
  renderVulns();
  hydrateDetailsPanel();
}

/* ---------------------------------------------------------- */
/* Populate ALL selectors (menus)                             */
/* ---------------------------------------------------------- */
export function populateSelectors(state = State){
  setOptions(el('selAttacker'), state.attackers || []);

  setOptions(el('selEntriesAll'), state.targets || []);
  setOptions(el('selExitsAll'),   state.targets || []);

  setOptions(el('linkSource'), state.targets || []);
  setOptions(el('linkDest'),   state.targets || []);

  hydrateEntriesSelect(state);
  hydrateExitsSelect(state);
  hydrateVulnSelectors(state);

  renderLinksInspector();
}

/* ---------------------------------------------------------- */
/* Hydrate Entries (multi)                                    */
/* ---------------------------------------------------------- */
export function hydrateEntriesSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selEntriesAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.entries ? [...att.entries].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Exits (multi)                                      */
/* ---------------------------------------------------------- */
export function hydrateExitsSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selExitsAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.exits ? [...att.exits].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Vulns (multi, persist visuellement)                */
/* ---------------------------------------------------------- */
export function hydrateVulnSelectors(state = State){
  const selT = el('selVulnElement');
  const selV = el('selVulnsForElement');
  if(!selT || !selV) return;

  // (1) cibles
  setOptions(selT, state.targets || []);

  // (2) vulns de la cible courante
  const t = (state.targets || []).find(x => String(x.id) === String(selT.value));
  const current = t ? (t.vulns instanceof Set ? t.vulns : new Set(t.vulns || [])) : new Set();
  const selected = new Set([...current].map(String));

  setOptions(selV, state.vulns || [], { selected });
}

/* ---------------------------------------------------------- */
/* Re-export                                                  */
/* ---------------------------------------------------------- */
export const renderLinksInspector = _renderLinksInspector;

===== ./js/simulation/scenarios.js =====
/* =========================================================
   simulation/scenarios.js
   Scénarios "humains" : chaque lien est créé via un vrai clic
   sur le bouton Add Link, puis la sélection est nettoyée pour
   éviter les boucles infinies.
   ========================================================= */

import { registerScenario, g } from './index.js';

/* ---------------------------------------------------------
   Helpers: commit *comme un humain*
   --------------------------------------------------------- */

// Compte les arêtes pour détecter "rien n'a changé"
function __edgeCount(state) {
  const E = state?.edges || { direct:{}, lateral:{}, contains:{} };
  const sum = (m) => Object.values(E[m] || {}).reduce((n, s) => n + (s?.size || 0), 0);
  return { d: sum('direct'), l: sum('lateral'), c: sum('contains') };
}

/** Clique le vrai bouton "Add link" si présent, sinon fallback "change". Puis CLEAR la sélection. */
async function clickAddLinkButton() {
  const tryIds = ['btnAddLink','addLink','linkAdd','btnLinkAdd','btn-add-link','action-add-link'];
  let btn = null;
  for (const id of tryIds) { const n = g.el(id); if (n) { btn = n; break; } }

  // snapshot avant
  const S = window.__envuln_boot?.State || window.State;
  const before = __edgeCount(S);

  if (btn) {
    await g.click(btn);
  } else {
    // fallback: déclenchement par change pour UIs sans bouton
    const sel = g.el('linkDest');
    if (sel) sel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // laisser le temps aux handlers d'ajouter les liens
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  await g.wait(40);

  // CLEAR la sélection pour éviter les re-commits infinis
  const destSel = g.el('linkDest');
  if (destSel) {
    [...destSel.options].forEach(o => o.selected = false);
    destSel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // garde-fou : si rien n'a changé, on n'insiste pas
  const after = __edgeCount(S);
  const delta = (after.d - before.d) + (after.l - before.l) + (after.c - before.c);
  if (delta <= 0) {
    await g.wait(80);
  }
}

/** S'assure du type de lien (direct/lateral/contains) si le select existe. */
async function ensureLinkType(type = 'direct') {
  const selType = g.el('linkType');
  if (!selType) return;
  if (String(selType.value).toLowerCase() === String(type).toLowerCase()) return;
  await g.click(selType);
  await g.wait(40);
  await g.selectByText(selType, type);
  await g.wait(60);
}

/** Commit "humain" : source → type → destinations → Add → CLEAR selection. */
async function humanCommitLinks(fromLabel, toLabels = [], type = 'direct') {
  // source
  await g.selectByText(g.el('linkSource'), fromLabel);
  await g.wait(60);

  // type
  await ensureLinkType(type);

  // destinations
  const destSel = g.el('linkDest');
  if (!destSel) return;
  await g.click(destSel);
  await g.wait(40);
  g.multiSelectByTexts(destSel, toLabels);
  await g.wait(40);

  // commit via bouton (avec clear + vérif delta)
  await clickAddLinkButton();
}

/** Commit de la sélection de vulnérabilités (multi-select change). */
function commitVulnSelection() {
  const sel = g.el('selVulnsForElement');
  if (!sel) return;
  sel.dispatchEvent(new Event('change', { bubbles: true }));
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* Ajouts via la vraie UI */
async function ensureVuln(name) {
  const inp = g.el('vulnName');
  if (!inp) return;
  await g.typeInto(inp, name);
  await g.click(g.el('btnAddVuln'));
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

async function addTarget(label) {
  await g.typeInto(g.el('targetName'), label);
  await g.click(g.el('btnAddTarget'));
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Scénarios (créent explicitement les liens nécessaires)
   --------------------------------------------------------- */

/* 1) Minimal web app chain — Internet LB -> Web Server -> App Server -> Database */
async function scenario_small_webapp() {
  await g.typeInto(g.el('attackerName'), 'Threat Actor — WebApp');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(240);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = ['Internet LB', 'Web Server', 'App Server', 'Database'];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Auth RCE');

  await g.selectByText(g.el('selAttacker'), 'Threat Actor — WebApp');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Database']);
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens
  await humanCommitLinks('Internet LB', ['Web Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('Web Server', ['App Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('App Server', ['Database'], 'direct');
  await g.wait(120);

  // Vuln
  await g.selectByText(g.el('selVulnElement'), 'Web Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth RCE']);
  commitVulnSelection();
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(420);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 2) Corporate network — plusieurs chemins + lien latéral depuis Mail */
async function scenario_corporate_network() {
  await g.typeInto(g.el('attackerName'), 'APT — Corporate');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = [
    'Internet Gateway', 'Perimeter FW', 'Proxy', 'Mail Server',
    'VPN Gateway', 'Edge VM', 'Internal App', 'DB Cluster', 'Secrets Store'
  ];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Open Port');
  await ensureVuln('Phishing OTP');
  await ensureVuln('Priv Esc');

  await g.selectByText(g.el('selAttacker'), 'APT — Corporate');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet Gateway', 'Mail Server']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Secrets Store']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Topologie
  await humanCommitLinks('Internet Gateway', ['Perimeter FW', 'Mail Server'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Perimeter FW', ['Proxy', 'VPN Gateway'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Proxy', ['Edge VM', 'Internal App'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Edge VM', ['Internal App'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Internal App', ['DB Cluster'], 'direct');
  await g.wait(80);
  await humanCommitLinks('DB Cluster', ['Secrets Store'], 'direct');
  await g.wait(100);

  // Lateral : Mail -> Edge VM
  await humanCommitLinks('Mail Server', ['Edge VM'], 'lateral');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Mail Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Phishing OTP']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Edge VM');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Open Port']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Internal App');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Priv Esc']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(700);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 3) Cloud containers — direct + contains + chemin vers Backup */
async function scenario_cloud_containers() {
  await g.typeInto(g.el('attackerName'), 'Cloud Operator Bug');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const hosts = ['LB', 'Web Pod', 'App Pod', 'Cache Pod', 'DB Pod', 'Backup Pod'];
  for (const h of hosts) await addTarget(h);

  await ensureVuln('Container Escape');
  await ensureVuln('Unpatched Service');

  await g.selectByText(g.el('selAttacker'), 'Cloud Operator Bug');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Backup Pod']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Flots directs
  await humanCommitLinks('LB', ['Web Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('Web Pod', ['App Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('App Pod', ['DB Pod', 'Cache Pod'], 'direct');
  await g.wait(90);

  // Chemin vers exit
  await humanCommitLinks('DB Pod', ['Backup Pod'], 'direct');
  await g.wait(90);

  // Contains (sémantique)
  await humanCommitLinks('App Pod', ['Cache Pod'], 'contains');
  await g.wait(120);

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Web Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Unpatched Service']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'App Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Container Escape']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(650);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 4) IoT/OT dense — Sensors -> Aggregator -> Edge -> Admin -> PLC */
async function scenario_iot_ot_dense() {
  await g.typeInto(g.el('attackerName'), 'Script Kiddie — IoT Wave');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const devices = [];
  for (let i = 1; i <= 10; i++) {
    const name = `Sensor-${i}`;
    devices.push(name);
    await addTarget(name);
  }
  const core = ['Aggregator', 'Edge Controller', 'Admin Console', 'Historian', 'PLC'];
  for (const c of core) await addTarget(c);

  await ensureVuln('Default Creds');
  await ensureVuln('Telnet Open');
  await ensureVuln('Weak Auth');

  await g.selectByText(g.el('selAttacker'), 'Script Kiddie — IoT Wave');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), devices.slice(0, 6));
  g.multiSelectByTexts(g.el('selExitsAll'), ['PLC']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens Sensors -> Aggregator / Edge / Admin
  await humanCommitLinks('Sensor-1', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-2', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-3', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-4', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-5', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-6', ['Aggregator', 'Admin Console'], 'direct');
  await g.wait(80);

  await humanCommitLinks('Aggregator', ['Edge Controller'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Edge Controller', ['Admin Console'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Admin Console', ['PLC', 'Historian'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Historian', ['PLC'], 'direct');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Sensor-2');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Sensor-4');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Edge Controller');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Telnet Open']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Admin Console');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Weak Auth']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(900);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 5) High-connectivity mesh — DAG dense A..G */
async function scenario_high_connectivity_mesh() {
  await g.typeInto(g.el('attackerName'), 'Black Hat — Mesh Experiment');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  for (const n of nodes) await addTarget(`Node ${n}`);

  await ensureVuln('Service X RCE');
  await ensureVuln('Auth Bypass');

  await g.selectByText(g.el('selAttacker'), 'Black Hat — Mesh Experiment');
  await g.wait(100);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Node A']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Node G']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // DAG dense: A -> B..G, B -> C..G, etc.
  for (let i = 0; i < nodes.length; i++) {
    const from = `Node ${nodes[i]}`;
    const toList = [];
    for (let j = i + 1; j < nodes.length; j++) toList.push(`Node ${nodes[j]}`);
    if (toList.length) {
      await humanCommitLinks(from, toList, 'direct');
      await g.wait(60);
    }
  }
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Node B');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Service X RCE']);
  commitVulnSelection();
  await g.wait(50);

  await g.selectByText(g.el('selVulnElement'), 'Node D');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth Bypass']);
  commitVulnSelection();
  await g.wait(70);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(1000);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Catalogue & enregistrement (un scénario aléatoire)
   --------------------------------------------------------- */

const CATALOG = [
  { name: 'Small webapp chain', fn: scenario_small_webapp },
  { name: 'Corporate network', fn: scenario_corporate_network },
  { name: 'Cloud containers', fn: scenario_cloud_containers },
  { name: 'IoT / OT dense', fn: scenario_iot_ot_dense },
  { name: 'High-connectivity mesh', fn: scenario_high_connectivity_mesh }
];

registerScenario('Random: pick one realistic scenario', async () => {
  const i = Math.floor(Math.random() * CATALOG.length);
  const picked = CATALOG[i];
  try {
    const txt = `Running scenario: ${picked.name}`;
    const statusEl = g.el('status');
    if (statusEl) statusEl.textContent = txt;
    await picked.fn();
  } finally {
    try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  }
});

===== ./js/simulation/index.js =====
/* =========================================================
   simulation/index.js
   UI-driven simulation with a virtual cursor (mouse gestures)
   Controller supports play / pause / stop / restart /step,
   speed control, and cursor timeline stepping.
   ========================================================= */

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';

const SCENARIOS = [];

/* ---------------- Registry ---------------- */
export function registerScenario(name, fn, weight = 1) {
  SCENARIOS.push({ name, fn, weight: Math.max(0, +weight || 1) });
}

/* ---------------- Global controller state ---------------- */
const CTRL = {
  paused: false,
  stopRequested: false,
  running: false,
  stepArmed: false,   // single-step gate for "step forward"
  speed: 1.0          // 0.2..3.0
};

/* ---------------- Abort helper ---------------- */
function shouldAbort() { return CTRL.stopRequested === true; }

/* ---------------- State snapshot / restore (sandbox) ---------------- */
let _snapshot = null;

function takeSnapshot() {
  try {
    // structuredClone preserves Sets/Maps/Date; good for our State shape.
    _snapshot = structuredClone(State);
  } catch {
    // last resort: shallow rebuild (Sets will still be Sets because current State uses Sets)
    _snapshot = JSON.parse(JSON.stringify({
      version: State.version,
      attackers: State.attackers.map(a => ({
        id: a.id, name: a.name,
        entries: [...a.entries],
        exits:   [...a.exits]
      })),
      targets: State.targets.map(t => ({
        id: t.id, name: t.name,
        vulns: [...t.vulns],
        final: !!t.final
      })),
      edges: {
        direct:   Object.fromEntries(Object.entries(State.edges.direct   || {}).map(([k,v]) => [k, [...v]])),
        lateral:  Object.fromEntries(Object.entries(State.edges.lateral  || {}).map(([k,v]) => [k, [...v]])),
        contains: Object.fromEntries(Object.entries(State.edges.contains || {}).map(([k,v]) => [k, [...v]])),
      }
    }));
    // Rehydrate Sets
    _snapshot.targets.forEach(t => t.vulns = new Set(t.vulns || []));
    _snapshot.attackers.forEach(a => {
      a.entries = new Set(a.entries || []);
      a.exits   = new Set(a.exits   || []);
    });
    for (const m of ['direct','lateral','contains']) {
      for (const k in _snapshot.edges[m]) {
        _snapshot.edges[m][k] = new Set(_snapshot.edges[m][k] || []);
      }
    }
  }
}

function restoreSnapshot() {
  if (!_snapshot) return;

  // Replace State fields in-place (keep same object reference)
  State.version   = _snapshot.version;
  State.attackers = _snapshot.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: new Set(a.entries),
    exits:   new Set(a.exits)
  }));
  State.targets   = _snapshot.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: new Set(t.vulns),
    final: !!t.final
  }));
  State.edges = { direct:{}, lateral:{}, contains:{} };
  for (const m of ['direct','lateral','contains']) {
    for (const k in _snapshot.edges[m]) {
      State.edges[m][k] = new Set(_snapshot.edges[m][k]);
    }
  }

  try { saveToLocal(State); } catch {}
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------- Cursor timeline (for step back/forward) ---------------- */
const TIMELINE = { points: [], idx: -1 };

function timelineClear() { TIMELINE.points.length = 0; TIMELINE.idx = -1; safeUpdateButtons(); }

// last known cursor position (px)
let __lastCursorPos = { x: null, y: null };

// clamp helper
function _clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

// record timeline but ignore invalid/meaningless points and duplicates
function timelineRecord(x, y) {
  // sanitize
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
  // clamp to viewport + small margin
  const margin = 8;
  const px = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth) - margin));
  const py = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  // ignore duplicate consecutive points
  const last = TIMELINE.points.length ? TIMELINE.points[TIMELINE.points.length - 1] : null;
  if (last && last.x === px && last.y === py) {
    TIMELINE.idx = TIMELINE.points.length - 1;
    return;
  }

  const t = performance.now();
  TIMELINE.points.push({ x: px, y: py, t });
  TIMELINE.idx = TIMELINE.points.length - 1;

  // update last known cursor pos
  __lastCursorPos.x = px;
  __lastCursorPos.y = py;

  safeUpdateButtons();
}

function timelineGoto(index) {
  const i = Math.max(0, Math.min(TIMELINE.points.length - 1, index));
  const p = TIMELINE.points[i];
  if (!p) return;
  const c = document.getElementById(CURSOR_ID) || ensureCursor();
  c.style.left = `${p.x}px`;
  c.style.top  = `${p.y}px`;
  TIMELINE.idx = i;
  safeUpdateButtons();
}

/* ---------------- Speed helpers ---------------- */
function readSpeedFromUI() {
  const el = document.getElementById('simSpeed');
  const v = el ? parseFloat(el.value) : 1;
  CTRL.speed = Math.max(0.2, Math.min(3, Number.isFinite(v) ? v : 1));
  const lab = document.getElementById('simSpeedValue');
  if (lab) lab.textContent = `×${CTRL.speed.toFixed(1)}`;
}
readSpeedFromUI();

/* ---------------- Public controls ---------------- */
export function simSetSpeed(mult) { CTRL.speed = Math.max(0.2, Math.min(3, +mult || 1)); }
export function simPlay() { CTRL.paused = false; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simPause(){ CTRL.paused = true;  CTRL.stepArmed = false; safeUpdateButtons(); }
export function simToggle(){ CTRL.paused = !CTRL.paused; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simStop() {
  CTRL.stopRequested = true;
  CTRL.paused = false;     // allow sleepers to exit
  CTRL.stepArmed = false;
  simCleanupUI();          // UI artifacts
}

/* one-step while paused */
export function simStep() { CTRL.stepArmed = true; }

/* step back/forward on cursor timeline (no state mutation) */
export function simStepBack(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.max(0, TIMELINE.idx - Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simStepForward(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.min(TIMELINE.points.length - 1, TIMELINE.idx + Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simCanStepBack()    { return TIMELINE.idx > 0; }
export function simCanStepForward() { return TIMELINE.idx >= 0 && TIMELINE.idx < (TIMELINE.points.length - 1); }

/* ---------------- DOM helpers ---------------- */
const $ = (id) => document.getElementById(id);
export function disableTopButtons(disabled = true) {
  ['btnSimu', 'btnFindPaths', 'btnExportODS', 'btnImportJSON', 'btnExportJSON'].forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !!disabled;
  });
}
export function enableTopButtons() { disableTopButtons(false); }
function safeUpdateButtons() { try { window.__updatePlaybackButtons && window.__updatePlaybackButtons(); } catch {} }

/* Sleep that honors pause/step/stop and speed */
function sleep(ms) {
  const base = Math.max(0, +ms || 0);
  const scaled = Math.max(10, Math.floor(base / Math.max(0.2, CTRL.speed)));
  return new Promise((resolve) => {
    const start = performance.now();
    function loop() {
      if (CTRL.stopRequested) return resolve();
      if (CTRL.paused && !CTRL.stepArmed) return setTimeout(loop, 40);
      if (CTRL.stepArmed) CTRL.stepArmed = false;
      const elapsed = performance.now() - start;
      if (elapsed >= scaled) return resolve();
      setTimeout(loop, 16);
    }
    loop();
  });
}

/* ---------------- Cursor rendering ---------------- */
const CURSOR_ID = '__sim_cursor';
function ensureCursor() {
  let c = document.getElementById(CURSOR_ID);
  if (c) return c;
  c = document.createElement('div');
  c.id = CURSOR_ID;
  Object.assign(c.style, {
    position: 'fixed',
    zIndex: 999999,
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    background: 'rgba(59,130,246,.9)',
    boxShadow: '0 0 0 6px rgba(59,130,246,.18)',
    pointerEvents: 'none',
    transform: 'translate(-50%, -50%)',
    transition: 'transform 80ms linear, left 120ms linear, top 120ms linear'
  });
  // put it at center by default
  const cx = Math.round(window.innerWidth / 2);
  const cy = Math.round(window.innerHeight / 2);
  c.style.left = `${cx}px`;
  c.style.top  = `${cy}px`;
  __lastCursorPos.x = cx;
  __lastCursorPos.y = cy;
  document.body.appendChild(c);
  return c;
}

function removeCursor() {
  const c = document.getElementById(CURSOR_ID);
  if (c) c.remove();
}

/* --------- FAST-ABORT GUARDS inside helpers (critical!) --------- */
async function moveToPoint(x, y, msPer100px = 120) {
  if (shouldAbort()) return;
  const cur = ensureCursor();

  // compute starting pos - prefer last known, else DOM rect
  let fromX = __lastCursorPos.x;
  let fromY = __lastCursorPos.y;
  if (!Number.isFinite(fromX) || !Number.isFinite(fromY)) {
    try {
      const r0 = cur.getBoundingClientRect();
      fromX = (Number.isFinite(r0.left) ? r0.left + 6 : window.innerWidth/2);
      fromY = (Number.isFinite(r0.top)  ? r0.top  + 6 : window.innerHeight/2);
    } catch {
      fromX = Math.round(window.innerWidth / 2);
      fromY = Math.round(window.innerHeight / 2);
    }
  }

  // sanitize target coords and clamp to viewport
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
  const margin = 8;
  const targetX = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth) - margin));
  const targetY = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  const dx = targetX - fromX, dy = targetY - fromY;
  const dist = Math.hypot(dx, dy) || 1;

  // If teleport distance is absurdly large (e.g. > viewport diag * 0.9), prefer linear interpolation via an intermediate point
  const viewportDiag = Math.hypot(window.innerWidth, window.innerHeight);
  const MAX_SAFE_JUMP = viewportDiag * 0.9;
  if (dist > MAX_SAFE_JUMP) {
    // first move to center-ish to avoid teleport bounce, then continue
    const midX = Math.round(window.innerWidth / 2);
    const midY = Math.round(window.innerHeight / 2);
    await moveToPoint(midX, midY, msPer100px); // recursive but will use last known pos now
    // continue to final
  }

  const steps = Math.max(10, Math.floor(dist / 10));
  const dur = Math.max(80, Math.floor((dist / 100) * msPer100px) / Math.max(0.2, CTRL.speed));
  const dt = dur / steps;

  for (let i = 1; i <= steps; i++) {
    if (shouldAbort()) return;
    while (CTRL.paused && !CTRL.stepArmed && !CTRL.stopRequested) { await sleep(40); }
    if (CTRL.stepArmed) CTRL.stepArmed = false;

    const t = i / steps;
    const nx = Math.round(fromX + dx * t);
    const ny = Math.round(fromY + dy * t);

    // set style (px)
    cur.style.left = `${nx}px`;
    cur.style.top  = `${ny}px`;

    // record stable, clamped positions
    timelineRecord(nx, ny);
    await sleep(dt);
  }

  // ensure final set exactly target
  cur.style.left = `${targetX}px`;
  cur.style.top  = `${targetY}px`;
  timelineRecord(targetX, targetY);
}

async function moveToEl(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  try {
    // Prefer instant scroll to stabilize getBoundingClientRect
    try { node.scrollIntoView({ block: 'center', behavior: 'auto' }); } catch { try { node.scrollIntoView(); } catch {} }
  } catch {}
  // small delay to allow layout to settle
  await sleep(80);

  if (shouldAbort()) return;
  let r;
  try { r = node.getBoundingClientRect(); } catch { r = null; }
  if (!r || !Number.isFinite(r.left) || !Number.isFinite(r.top)) {
    // fallback to center of viewport
    const px = Math.round(window.innerWidth / 2);
    const py = Math.round(window.innerHeight / 2);
    await moveToPoint(px, py);
    return;
  }
  await moveToPoint(r.left + Math.min(r.width - 2, offX), r.top + Math.min(r.height - 2, offY));
}

function fireMouse(node) {
  if (!node || shouldAbort()) return;
  const r = node.getBoundingClientRect();
  const centerX = r.left + r.width / 2;
  const centerY = r.top + r.height / 2;
  for (const type of ['mousedown', 'mouseup', 'click']) {
    if (shouldAbort()) return;
    node.dispatchEvent(new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: centerX, clientY: centerY, button: 0
    }));
  }
}

async function click(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  await moveToEl(node, offX, offY);
  if (shouldAbort()) return;
  fireMouse(node);
  await sleep(80);
}

async function typeInto(input, text, perCharMs = 28) {
  if (shouldAbort() || !input) return;
  await click(input);
  if (shouldAbort()) return;
  input.focus();
  input.value = '';
  input.dispatchEvent(new Event('input', { bubbles: true }));
  for (const ch of String(text)) {
    if (shouldAbort()) return;
    input.value += ch;
    input.dispatchEvent(new Event('input', { bubbles: true }));
    await sleep(perCharMs);
  }
}

async function selectByText(selectEl, text) {
  if (shouldAbort() || !selectEl) return;
  const target = String(text).toLowerCase();
  const options = [...selectEl.options];
  for (const opt of options) {
    if (shouldAbort()) return;
    if (opt.textContent.toLowerCase() === target) {
      await click(selectEl);
      if (shouldAbort()) return;
      await sleep(120);
      opt.selected = true;
      opt.scrollIntoView({ block: 'center', behavior: 'auto' });
      await click(opt);
      if (shouldAbort()) return;
      selectByBrowser(selectEl); // change event for UI handlers
      await sleep(120);
      return;
    }
  }
}

function selectByBrowser(selectEl) {
  if (shouldAbort() || !selectEl) return;
  selectEl.dispatchEvent(new Event('change', { bubbles: true }));
}

function multiSelectByTexts(selectEl, labels = []) {
  if (shouldAbort() || !selectEl) return;
  const wanted = new Set(labels.map(x => String(x).toLowerCase()));
  for (const opt of selectEl.options) {
    if (shouldAbort()) return;
    opt.selected = wanted.has(opt.textContent.toLowerCase());
  }
  selectByBrowser(selectEl);
}

/* ---------------- Simulation artifacts cleanup (UI only) ---------------- */
const SIM_TRACES = { nodes: new Set(), classAdds: [] };

export function simMarkEl(node) {
  if (!node) return null;
  try { node.setAttribute('data-sim', ''); } catch {}
  SIM_TRACES.nodes.add(node);
  return node;
}
export function simAddTempClass(node, className) {
  if (!node || !className) return;
  try {
    node.classList.add(className);
    SIM_TRACES.classAdds.push([node, className]);
  } catch {}
}

export function simCleanupUI() {
  // 1) remove cursor
  removeCursor();
  // 2) remove elements tagged as simulation artifacts
  try { document.querySelectorAll('[data-sim]').forEach(n => n.remove()); } catch {}
  // 3) remove temp classes
  SIM_TRACES.classAdds.forEach(([n, cls]) => { try { n.classList.remove(cls); } catch {} });
  SIM_TRACES.classAdds.length = 0;
  // 4) timeline reset
  timelineClear();
  safeUpdateButtons();
}

/* ---------------- Public gesture API used by scenarios ---------------- */
export const g = {
  el: (id) => document.getElementById(id),
  wait: sleep,
  moveToEl,
  click,
  typeInto,
  selectByText,
  multiSelectByTexts,
  // tagging helpers for cleanup
  markEl: simMarkEl,
  addClassTemp: simAddTempClass,
  // keep toolbar toggling consistent
  disableTopButtons: (disabled = true) => disableTopButtons(disabled),
  ensureInView: (node, block = 'center') => {
    try { node?.scrollIntoView({ block, behavior: 'auto' }); } catch {}
  }
};

/* =========================================================
   Scenario runner
   ========================================================= */

async function runScenarioObject(sc) {
  try {
    await sc.fn(g);
  } catch (e) {
    if (!CTRL.stopRequested) console.error(e);
  }
}

export async function runSimulation(opts = {}) {
  if (CTRL.running) return;     // avoid concurrent runs
  CTRL.stopRequested = false;
  CTRL.paused = false;
  CTRL.stepArmed = false;
  readSpeedFromUI();

  // Take a state snapshot so STOP can fully roll back.
  takeSnapshot();

  // Fresh cursor/timeline/UI artifacts
  simCleanupUI();

  disableTopButtons(true);
  CTRL.running = true;

  for (const sc of SCENARIOS) {
    if (shouldAbort()) break;
    await runScenarioObject(sc);
    if (shouldAbort()) break;
    await sleep(300);
  }

  CTRL.running = false;
  disableTopButtons(false);

  // If aborted, restore snapshot so *nothing* from the scenario sticks.
  if (shouldAbort()) {
    restoreSnapshot();
  }

  // Always clean UI artifacts
  simCleanupUI();

  // Render after finishing/aborting
  if (typeof opts.renderCallback === 'function') {
    try { opts.renderCallback(); } catch {}
  }
}

/* ---------------- State queries for UI ---------------- */
export function simIsRunning() { return CTRL.running; }
export function simIsPaused()  { return CTRL.paused; }
export function simHasStopRequest() { return CTRL.stopRequested; }

/* ---------------- Default export ---------------- */
export default {
  registerScenario,
  runSimulation,
  simPlay, simPause, simToggle, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simCanStepBack, simCanStepForward,
  simIsRunning, simIsPaused, simHasStopRequest,
  simCleanupUI, simMarkEl, simAddTempClass,
  g,
  SCENARIOS
};

===== ./js/paths.js =====
// js/paths.js
// Graph path enumeration for ENVULN

/**
 * Return a map id -> target
 */
function targetMap(state){
  const m = Object.create(null);
  (state.targets || []).forEach(t => { m[t.id] = t; });
  return m;
}

export function nameOfTarget(state, id){
  return (state.targets || []).find(t => t.id === id)?.name || String(id || '');
}

function outsFrom(map, id){
  if(!map) return [];
  const s = map[id];
  if(!s) return [];
  return Array.isArray(s) ? s.slice() : Array.from(s);
}

export function adjacency(state, id, opts = { includeLateral: true, includeContains: true }){
  const out = new Set();
  const e = state.edges || {};
  outsFrom(e.direct, id).forEach(x => out.add(x));
  if(opts.includeLateral) outsFrom(e.lateral, id).forEach(x => out.add(x));
  if(opts.includeContains) outsFrom(e.contains, id).forEach(x => out.add(x));
  return Array.from(out);
}

export function isDAG(state, opts = { includeLateral: true, includeContains: true }){
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = Object.create(null);
  for(const t of (state.targets || [])) color[t.id] = WHITE;
  let hasCycle = false;

  function dfs(u){
    color[u] = GRAY;
    const nexts = adjacency(state, u, opts);
    for(const v of nexts){
      if(color[v] === GRAY){ hasCycle = true; return; }
      if(color[v] === WHITE) dfs(v);
      if(hasCycle) return;
    }
    color[u] = BLACK;
  }

  for(const t of (state.targets || [])){
    if(color[t.id] === WHITE) dfs(t.id);
    if(hasCycle) break;
  }
  return !hasCycle;
}

/* -------- DAG enumeration with exit-stop support -------- */
function enumeratePaths_DAG_from(state, startId, memo, opts, stopSet){
  if(memo.has(startId)) return memo.get(startId);

  const results = [];
  const nexts = adjacency(state, startId, opts);
  const t = (state.targets || []).find(x => x.id === startId);
  const isFinal = !!(t && t.final);
  const isExit  = !!(stopSet && stopSet.has(String(startId)));

  // stop on: no outgoing edges, target.final, or attacker exit
  if(nexts.length === 0 || isFinal || isExit){
    results.push([startId]);
  } else {
    for(const v of nexts){
      const subs = enumeratePaths_DAG_from(state, v, memo, opts, stopSet);
      for(const sub of subs){
        results.push([startId, ...sub]);
      }
    }
  }

  memo.set(startId, results);
  return results;
}

export function enumeratePaths_DAG(state, starts, opts, stopSet){
  const memo = new Map();
  let all = [];
  for(const s of starts){
    const sub = enumeratePaths_DAG_from(state, s, memo, opts, stopSet);
    all = all.concat(sub);
  }
  return all;
}

/* -------- General graph (cycles allowed) with exit-stop support -------- */
export function enumeratePaths_General(state, starts, opts, stopSet, maxPaths = 5000){
  const paths = [];
  let cycles = false;

  const adj = (id) => adjacency(state, id, opts);

  function dfs(u, visited, stack){
    if(paths.length >= maxPaths) return;
    const t = (state.targets || []).find(x => x.id === u);
    const isFinal = !!(t && t.final);
    const isExit  = !!(stopSet && stopSet.has(String(u)));
    const nexts = adj(u);

    if(nexts.length === 0 || isFinal || isExit){
      paths.push([...stack, u]);
      return;
    }

    visited.add(u);
    for(const v of nexts){
      if(visited.has(v)){ cycles = true; continue; }
      dfs(v, visited, [...stack, u]);
      if(paths.length >= maxPaths) break;
    }
    visited.delete(u);
  }

  for(const s of starts){
    dfs(s, new Set(), []);
    if(paths.length >= maxPaths) break;
  }

  return { paths, cycles };
}

export function computePathsForAttacker(
  state,
  attackerId,
  opts = { includeLateral: true, includeContains: true },
  maxPaths = 5000
){
  const attacker = (state.attackers || []).find(a => a.id === attackerId);
  if(!attacker) return { paths: [], cycles: false, truncated: false };

  const starts = Array.from(attacker.entries || []).map(String);
  if(starts.length === 0) return { paths: [], cycles: false, truncated: false };

  // exits selected in UI are treated as stopping nodes
  const exits = new Set(Array.from(attacker.exits || []).map(String));

  const dag = isDAG(state, opts);

  let nodePaths = [];
  let cycles = false;

  if(dag){
    nodePaths = enumeratePaths_DAG(state, starts, opts, exits);
  } else {
    const out = enumeratePaths_General(state, starts, opts, exits, maxPaths);
    nodePaths = out.paths;
    cycles = out.cycles;
  }

  // Keep only those that end on an exit (should already be true, but harmless)
  if(exits.size > 0){
    nodePaths = nodePaths.filter(path => exits.has(String(path[path.length - 1])));
  }

  const targetsById = targetMap(state);
  const normalized = nodePaths.map(nodes => {
    return {
      attackerId: attacker.id,
      attackerName: attacker.name,
      nodes: nodes.map(id => targetsById[id]).filter(Boolean),
      vulnsPerNode: nodes.map(id => {
        const t = targetsById[id];
        if(!t) return [];
        const list = Array.isArray(t.vulns) ? t.vulns : Array.from(t.vulns || []);
        return list.map(vId => {
          const v = (state.vulns || []).find(x => x.id === vId);
          return v ? v.name : vId;
        }).filter(Boolean);
      })
    };
  });

  const truncated = (!dag && nodePaths.length >= maxPaths);
  return { paths: normalized, cycles, truncated };
}

export function computeAllPaths(
  state,
  opts = { includeLateral: true, includeContains: true },
  maxPathsPerAttacker = 5000
){
  const all = [];
  let anyCycles = false;
  let anyTruncated = false;

  for(const a of (state.attackers || [])){
    const out = computePathsForAttacker(state, a.id, opts, maxPathsPerAttacker);
    all.push(...out.paths);
    if(out.cycles) anyCycles = true;
    if(out.truncated) anyTruncated = true;
  }

  return { paths: all, cycles: anyCycles, truncated: anyTruncated };
}

===== ./js/diagram.js =====
// /js/diagram.js
// ES module that builds and renders the attack path SVG diagrams.

export function buildSVGForPath(pathObj, state, options = {}) {
  // ---- options with sane defaults ----
  const {
    padX = 20,
    padY = 22,
    boxW = 220,
    boxH = 70,
    gap = 60,
    corner = 10,
    fontFamily = 'Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial',
    showVulns = true,
    vulnLineHeight = 14,
    maxTitleChars = 28,
    maxSubtitleChars = 34,
    maxVulnChars = 60,
    colors = {
      bg: '#0b1224',
      title: '#e6eef8',
      subtitle: '#9fb0c6',
      note: '#cbd5e1',
      strokeBase: '#a7b8cf',
      strokeDirect: '#a7b8cf',
      strokeLateral: '#fbbf24',
      strokeContains: '#60a5fa',
      boxBase: '#0b1730',
      boxAtt: '#a855f7',
      boxEntry: '#f59e0b',
      boxTarget: '#22c55e',
      boxFinal: '#16a34a'
    }
  } = options;

  // ---- guards ----
  if (!pathObj || !Array.isArray(pathObj.nodes) || !pathObj.nodes.length) {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="640" height="120" viewBox="0 0 640 120" role="img" aria-label="Empty path">
      <rect x="0" y="0" width="640" height="120" fill="${colors.bg}"/>
      <text x="16" y="64" fill="${colors.title}" font-family="${fontFamily}" font-size="14">Empty path</text>
    </svg>`;
  }

  // ---- helpers ----
  const esc = s => String(s || '').replace(/[&<>"]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
  const wrap = (text, max = 28) => {
    const t = String(text || '');
    if (t.length <= max) return [t];
    const words = t.split(/\s+/);
    const lines = [];
    let cur = '';
    for (const w of words) {
      if ((cur ? cur + ' ' : '') .length + w.length > max) {
        if (cur) lines.push(cur);
        cur = w;
      } else {
        cur = cur ? cur + ' ' + w : w;
      }
    }
    if (cur) lines.push(cur);
    return lines.slice(0, 3);
  };

  const nameOf = (id) => (state.targets.find(t => t.id === id) || { name: '?' }).name;

  // Decide edge type between consecutive nodes in the path
  const isInSet = (map, from, to) => {
    const set = map[from];
    if (!set) return false;
    // map can be Set or Array depending on how state was loaded
    if (set instanceof Set) return set.has(to);
    return Array.isArray(set) ? set.includes(to) : false;
  };
  const edgeTypeBetween = (fromId, toId) => {
    if (isInSet(state.edges?.lateral || {}, fromId, toId)) return 'lateral';
    if (isInSet(state.edges?.contains || {}, fromId, toId)) return 'contains';
    return 'direct';
  };

  // ---- build "steps" sequence ----
  const entriesNames = [...(state.attackers.find(a => a.id === pathObj.attackerId)?.entries || new Set())].map(nameOf);
  const steps = [
    { kind: 'attacker', title: 'Attacker', subtitle: pathObj.attacker || '—' },
    { kind: 'entries',  title: 'Entries',  subtitle: entriesNames.length ? entriesNames.join(', ') : '—' },
    ...pathObj.nodes.map((n, i) => ({
      kind: 'target',
      title: `Target ${i + 1}${i === pathObj.nodes.length - 1 ? ' (final)' : ''}`,
      subtitle: n.name,
      isFinal: i === pathObj.nodes.length - 1,
      vulns: (pathObj.vulnsPerNode?.[i] || [])
    }))
  ];

  // Determine canvas base dimensions
  const anyTarget = steps.some(s => s.kind === 'target');
  const baseH = padY * 2 + boxH + (anyTarget && showVulns ? (vulnLineHeight + 18) : 0);
  const baseW = padX * 2 + steps.length * boxW + (steps.length - 1) * gap;

  // ---- SVG construction ----
  let x = padX, y = padY;
  let svg = `
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 ${baseW} ${baseH}" width="${Math.min(baseW, 1600)}" height="${baseH}"
     role="img" aria-label="Attack path diagram">
  <defs>
    <marker id="arrowHead" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
      <polygon points="0,0 12,4 0,8" fill="${colors.strokeBase}"/>
    </marker>
    <style>
      .title { font: 600 14px ${fontFamily}; fill: ${colors.title}; }
      .subtitle { font: 12px ${fontFamily}; fill: ${colors.subtitle}; }
      .note { font: 12px ${fontFamily}; fill: ${colors.note}; }
      .box { fill: ${colors.boxBase}; stroke-width: 1.4; rx: ${corner}; ry: ${corner}; }
      .box-att { stroke: ${colors.boxAtt}; }
      .box-entry { stroke: ${colors.boxEntry}; }
      .box-target { stroke: ${colors.boxTarget}; }
      .box-final { stroke: ${colors.boxFinal}; stroke-width: 2; }
      .arrow { stroke: ${colors.strokeDirect}; stroke-width: 1.6; fill: none; marker-end: url(#arrowHead); }
      .arrow-lat { stroke: ${colors.strokeLateral}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 6 4; }
      .arrow-contains { stroke: ${colors.strokeContains}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 2 4; }
      .bg { fill: ${colors.bg}; }
    </style>
  </defs>
  <rect class="bg" x="0" y="0" width="${baseW}" height="${baseH}" rx="${corner}" ry="${corner}"/>
`;

  // precompute edge types between consecutive target nodes
  const pathTargetIds = pathObj.nodes.map(n => n.id);
  const hopTypes = [];
  for (let i = 0; i < pathTargetIds.length - 1; i++) {
    hopTypes[i] = edgeTypeBetween(pathTargetIds[i], pathTargetIds[i + 1]);
  }

  function drawBox(className, title, subtitle, isFinal) {
    svg += `<rect class="box ${className} ${isFinal ? 'box-final' : ''}" x="${x}" y="${y}" width="${boxW}" height="${boxH}" />`;
    let ty = y + 24;
    wrap(title, maxTitleChars).forEach(ln => { svg += `<text class="title" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 16; });
    wrap(subtitle, maxSubtitleChars).forEach(ln => { svg += `<text class="subtitle" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 14; });
  }

  steps.forEach((s, i) => {
    const cls =
      s.kind === 'attacker' ? 'box-att' :
      s.kind === 'entries'  ? 'box-entry' : 'box-target';

    drawBox(cls, s.title, s.subtitle, s.isFinal);

    if (s.kind === 'target' && showVulns) {
      const text = s.vulns && s.vulns.length
        ? `Vulns: ${truncateList(s.vulns, maxVulnChars)}`
        : 'No vulnerabilities';
      svg += `<text class="note" x="${x + 10}" y="${y + boxH + 22}">${esc(text)}</text>`;
    }

    if (i < steps.length - 1) {
      // Draw edge to next step, deciding style by hop type (only between target→target)
      const nx = x + boxW + gap;
      const midY = y + boxH / 2;
      let clsArrow = 'arrow'; // default direct
      if (s.kind === 'target') {
        const idx = i - 2; // because steps[0]=attacker, steps[1]=entries
        if (idx >= 0 && idx < hopTypes.length) {
          const t = hopTypes[idx];
          if (t === 'lateral') clsArrow = 'arrow-lat';
          else if (t === 'contains') clsArrow = 'arrow-contains';
        }
      }
      svg += `<path class="${clsArrow}" d="M ${x + boxW} ${midY} C ${x + boxW + gap / 2} ${midY} ${nx - gap / 2} ${midY} ${nx} ${midY}" />`;
      x = nx;
    }
  });

  svg += `</svg>`;
  return svg;

  // truncate comma-joined lists to a max char count (soft)
  function truncateList(arr, max) {
    const s = arr.join(', ');
    if (s.length <= max) return s;
    // Try to keep full items, not mid-word cut
    let out = '';
    for (let i = 0; i < arr.length; i++) {
      const next = out ? out + ', ' + arr[i] : arr[i];
      if (next.length > max) break;
      out = next;
    }
    return out ? out + '…' : s.slice(0, max - 1) + '…';
  }
}

/**
 * Render the diagram into a container element.
 * @param {HTMLElement} containerEl - target container (e.g., document.getElementById('diagramBox'))
 * @param {Object} pathObj - result item { attacker, attackerId, nodes: [{id,name}], vulnsPerNode: [...] }
 * @param {Object} state - full app state (targets, edges, attackers...)
 * @param {Object} options - same as buildSVGForPath options (optional)
 * @returns {SVGElement|null}
 */
export function renderDiagram(containerEl, pathObj, state, options = {}) {
  if (!containerEl) return null;
  const svgStr = buildSVGForPath(pathObj, state, options);
  containerEl.innerHTML = svgStr;
  const svg = containerEl.querySelector('svg');
  // small QoL: enable horizontal scroll with Shift+wheel
  containerEl.style.overflowX = 'auto';
  containerEl.style.overflowY = 'hidden';
  containerEl.onwheel = (ev) => {
    if (ev.shiftKey) {
      containerEl.scrollLeft += ev.deltaY;
      ev.preventDefault();
    }
  };
  return svg || null;
}

/**
 * Download an existing <svg> as an .svg file.
 * @param {SVGElement} svgEl
 * @param {string} filename
 */
export function downloadSVG(svgEl, filename = 'attack-diagram.svg') {
  if (!svgEl) return;
  const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/* ===== Usage example (in UI code) =====
import { renderDiagram, downloadSVG } from './diagram.js';
import { State } from './state.js';

const svg = renderDiagram(document.getElementById('diagramBox'), pathItem, State, {
  showVulns: true,
  gap: 68
});
document.getElementById('btnDownloadSVG').onclick = () => downloadSVG(svg, 'attack-diagram.svg');
*/

===== ./js/main.js =====
// js/main.js
// Main UI logic with immediate persistence and dual playback:
// - dataset playback for computed paths (left/right navigation)
// - simulation playback bridge (play/pause/stop/restart/step; speed control)

import './simulation/scenarios.js';

import { el, norm } from './helpers.js';
import * as StateMod from './state.js';
import { saveToLocal, loadFromLocal, exportJSON, importJSON, clearLocal } from './storage.js';
import {
  renderAttackers,
  renderTargets,
  renderVulns,
  populateSelectors,
  renderLinksInspector,
  setOptions,
  hydrateEntriesSelect,
  hydrateExitsSelect,
  hydrateVulnSelectors
} from './ui/lists.js';
import { wireLinksUI } from './ui/links.js';
import { computeAllPaths } from './paths.js';
import { buildSVGForPath } from './diagram.js';
import { exportODS } from './exportODS.js';
import {
  runSimulation,
  disableTopButtons,
  enableTopButtons,
  simPlay, simPause, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simIsRunning, simIsPaused,
  simCanStepBack, simCanStepForward
} from './simulation/index.js';

let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

/* -------------------------------------------------------------------------- */
/* UI selection store (remember current attacker + vuln target)               */
/* -------------------------------------------------------------------------- */
const UI_STORE_KEY = 'envuln-lite-ui';
function saveUISelection(){
  try {
    localStorage.setItem(UI_STORE_KEY, JSON.stringify({
      attackerId: el('selAttacker')?.value || null,
      vulnTargetId: el('selVulnElement')?.value || null
    }));
  } catch {}
}
function loadUISelection(){
  try { return JSON.parse(localStorage.getItem(UI_STORE_KEY) || '{}'); }
  catch { return {}; }
}

/* -------------------------------------------------------------------------- */
/* Status                                                                     */
/* -------------------------------------------------------------------------- */
function renderStatus(s) {
  const sEl = el('status');
  if (sEl) sEl.textContent = s;
}

/* -------------------------------------------------------------------------- */
/* Global rerender                                                            */
/* -------------------------------------------------------------------------- */
function emitStateChanged() {
  try { saveToLocal(StateMod.State); } catch {}
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Playback UI helpers                                                        */
/* -------------------------------------------------------------------------- */
let playbackControlsEnabled = false; // source of truth for enabling the row

function setPlayPauseVisual(isPlaying) {
  const btn = el('btnPlayPause');
  if (!btn) return;
  btn.textContent = isPlaying ? '⏸' : '▶';
}

function setPlaybackEnabled(enabled) {
  playbackControlsEnabled = !!enabled;
  const ids = ['btnPlayPause','btnStop','btnRestart','btnStepBack','btnStepForward'];
  ids.forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !playbackControlsEnabled || !playback.dataset.length;
  });
  const row = document.getElementById('playbackRow');
  if (row) row.classList.toggle('is-disabled', !playbackControlsEnabled);
  if (!playbackControlsEnabled) setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Full wipe (used by Reset All) — clears state + results + diagram + playback */
/* -------------------------------------------------------------------------- */
function resetAllApp() {
  // 1) stop any running simulation and remove cursor
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor'); if (cur) cur.remove();

  // 2) wipe domain state
  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  // 3) storage and last-results cache
  try { clearLocal(); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}
  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  // 4) clear UI
  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram   = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div');
    ph.className = 'small';
    ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }
  const svgSizeEl = el('svgSize'); if (svgSizeEl) svgSizeEl.textContent = '—';
  const statusEl  = el('status');  if (statusEl)  statusEl.textContent  = '—';

  const inAtt = el('attackerName'); if (inAtt) inAtt.value = '';
  const inTar = el('targetName');   if (inTar) inTar.value = '';
  const inVul = el('vulnName');     if (inVul) inVul.value = '';

  // 5) clear playback dataset and reset playback
  playback_setDataset([]);
  playback_resetToStart();

  // 6) disable playback controls and rerender
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Bridge playback controls to simulation engine                              */
/* -------------------------------------------------------------------------- */
function bridgeSimulationPlayback() {
  // intentionally empty: unified handlers in wirePlaybackControls()
}

/* -------------------------------------------------------------------------- */
/* Hidden buttons for scenarios that call add/remove link by clicking         */
/* -------------------------------------------------------------------------- */
function ensureSimScenarioLinkButtons() {
  const byId = (id) => document.getElementById(id);

  ['btnAddLink','btnRemoveLink'].forEach(id => {
    if (!byId(id)) {
      const b = document.createElement('button');
      b.id = id;
      b.type = 'button';
      b.hidden = true;
      document.body.appendChild(b);
    }
  });

  const btnAdd = byId('btnAddLink');
  const btnDel = byId('btnRemoveLink');

  const srcSel  = byId('linkSource');
  const dstSel  = byId('linkDest');
  const typeSel = byId('linkType');

  const apply = (mode) => {
    const from = srcSel?.value;
    const type = typeSel?.value || 'direct';
    if (!from || !dstSel) return;

    const selectedTos = [...dstSel.selectedOptions].map(o => o.value);
    if (!selectedTos.length) return;

    selectedTos.forEach(to => {
      try {
        if (mode === 'add') {
          StateMod.addEdge(type, from, to);
        } else {
          StateMod.removeEdge(type, from, to);
        }
      } catch {}
    });

    try { saveToLocal(StateMod.State); } catch {}
    renderLinksInspector();
  };

  if (btnAdd) btnAdd.addEventListener('click', () => apply('add'));
  if (btnDel) btnDel.addEventListener('click', () => apply('del'));
}

/* -------------------------------------------------------------------------- */
/* Initialization                                                             */
/* -------------------------------------------------------------------------- */
async function init() {
  const loaded = loadFromLocal();
  if (loaded) StateMod.hydrate(loaded);

  StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));

  renderAllUI();

  // Restore UI selection (attacker + vuln target)
  const ui = loadUISelection();
  if (ui.attackerId) {
    const selAtt = el('selAttacker');
    if (selAtt && [...selAtt.options].some(o => o.value === ui.attackerId)) {
      selAtt.value = ui.attackerId;
      hydrateEntriesSelect(StateMod.State);
      hydrateExitsSelect(StateMod.State);
    }
  }
  if (ui.vulnTargetId) {
    const selT = el('selVulnElement');
    if (selT && [...selT.options].some(o => o.value === ui.vulnTargetId)) {
      selT.value = ui.vulnTargetId;
      hydrateVulnSelectors(StateMod.State);
    }
  }

  wireAddControls();
  wireAttackerSelection();
  wireEntries();
  wireExits();
  wireVulns();
  wireLinksUI();
  wireTopActions();
  wireSimulationButton();
  wirePlaybackControls();
  bridgeSimulationPlayback();
  ensureSimScenarioLinkButtons();

  // playback disabled by default until a simulation is started
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  playback_setDataset([]);
  playback_renderCurrent();
  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Rendering                                                                  */
/* -------------------------------------------------------------------------- */
function renderAllUI() {
  renderAttackers(StateMod.State);
  renderTargets(StateMod.State);
  renderVulns(StateMod.State);
  populateSelectors(StateMod.State);

  hydrateEntriesSelect(StateMod.State);
  hydrateExitsSelect(StateMod.State);
  hydrateVulnSelectors(StateMod.State);

  renderLinksInspector();

  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Add controls + Reset All                                                   */
/* -------------------------------------------------------------------------- */
function wireAddControls() {
  el('btnAddAttacker').onclick = () => {
    const name = norm(el('attackerName').value);
    if (!name) return;
    StateMod.createAttacker(name);
    el('attackerName').value = '';
    emitStateChanged();
  };

  el('btnAddTarget').onclick = () => {
    const name = norm(el('targetName').value);
    if (!name) return;
    const id = StateMod.createTarget(name);
    StateMod.ensureEdgeMaps(id);
    el('targetName').value = '';
    emitStateChanged();
  };

  el('btnAddVuln').onclick = () => {
    const name = norm(el('vulnName').value);
    if (!name) return;
    StateMod.createVuln(name);
    el('vulnName').value = '';
    emitStateChanged();
  };

  const btnResetAll = el('btnResetAll');
  if (btnResetAll) {
    btnResetAll.onclick = () => {
      if (confirm('This will erase all attackers, targets, vulnerabilities, links, results and local storage. Continue?')) {
        resetAllApp();
      }
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Attacker selection                                                         */
/* -------------------------------------------------------------------------- */
function wireAttackerSelection() {
  el('selAttacker').addEventListener('change', () => {
    hydrateEntriesSelect(StateMod.State);
    hydrateExitsSelect(StateMod.State);
    saveUISelection(); // remember current attacker in UI store
  });
}

/* -------------------------------------------------------------------------- */
/* Entries (real-time + clear)                                                */
/* -------------------------------------------------------------------------- */
function wireEntries() {
  const sel = el('selEntriesAll');
  const btnClear = el('btnClearEntries');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerEntries(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerEntries(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Exits (real-time + clear)                                                  */
/* -------------------------------------------------------------------------- */
function wireExits() {
  const sel = el('selExitsAll');
  const btnClear = el('btnClearExits');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerExits(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerExits(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Vulnerabilities (real-time + clear)                                        */
/* -------------------------------------------------------------------------- */
function wireVulns() {
  const selTarget = el('selVulnElement');
  const selVulns = el('selVulnsForElement');
  const btnClear = el('btnClearVulnSelection');

  if (!selTarget || !selVulns) return;

  const applySelectionToState = () => {
    const targetId = selTarget.value;
    if (!targetId) return;
    const vids = [...selVulns.selectedOptions].map(o => o.value);
    const t = StateMod.State.targets.find(x => x.id === targetId);
    if (!t) return;
    t.vulns = new Set(vids);
    emitStateChanged();
  };

  selTarget.addEventListener('change', () => {
    hydrateVulnSelectors(StateMod.State); // repopulate + reselect
    saveUISelection();                    // remember current vuln target in UI store
  });

  selVulns.addEventListener('change', applySelectionToState);

  if (btnClear) {
    btnClear.onclick = () => {
      [...selVulns.options].forEach(o => o.selected = false);
      applySelectionToState();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Results rendering                                                          */
/* -------------------------------------------------------------------------- */
function renderResultsList(results) {
  const cont = el('results');
  const svgSizeEl = el('svgSize');
  cont.innerHTML = '';
  if (!results.length) {
    // Provide a useful reason when the list is empty
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const msg = (filterOn && (lastResults?.length || 0) > 0)
      ? 'No paths match the "Only vulnerable paths" filter.'
      : 'No paths.';
    cont.innerHTML = `<div class="small">${msg}</div>`;
    if (svgSizeEl) svgSizeEl.textContent = '—';
    playback_setDataset([]);
    return;
  }

  results.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';

    const left = document.createElement('div');
    left.className = 'left';
    const title = document.createElement('div');
    title.innerHTML = `<strong>${p.attackerName}</strong>`;
    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.append(title, chain);

    const btn = document.createElement('button');
    btn.className = 'ghost';
    btn.textContent = 'Diagram';
    btn.onclick = () => playback_showIndex(idx, true);

    row.append(left, btn);
    cont.appendChild(row);
  });

  playback_setDataset(results);
}

/* -------------------------------------------------------------------------- */
/* Top actions (compute/export/import/download)                               */
/* -------------------------------------------------------------------------- */
function wireTopActions() {
  const chkOnlyVuln = el('chkOnlyVuln');

  const summarize = (count, meta) => {
    const parts = [];
    parts.push(`${count} path${count === 1 ? '' : 's'}`);
    if (meta.cycles) parts.push('cycles detected (simple paths)');
    if (meta.truncated) parts.push('truncated by ceiling');
    renderStatus(parts.join(' • '));
  };

  // Consider a path "vulnerable everywhere" only from the second node onward
  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);

  const renderFiltered = () => {
    const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
    const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
    renderResultsList(display);
    summarize(display.length, lastMeta);
  };

  el('btnFindPaths').onclick = () => {
    const opts = {
      includeLateral: el('includeLateral').checked,
      includeContains: el('includeContains').checked
    };
    const max = parseInt(el('maxPaths').value, 10);
    const out = computeAllPaths(StateMod.State, opts, max);
    lastResults = out.paths || [];
    lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };
    renderFiltered();
    playback_resetToStart();
  };

  if (chkOnlyVuln) chkOnlyVuln.addEventListener('change', () => {
    renderFiltered();
    playback_resetToStart();
  });

  el('btnDownloadSVG').onclick = () => {
    const svg = el('diagramBox')?.querySelector('svg');
    if (!svg) return;
    const blob = new Blob([svg.outerHTML], { type: 'image/svg+xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `attack-diagram-${new Date().toISOString().replace(/[:.]/g, '-')}.svg`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 0);
  };

  const btnODS = el('btnExportODS');
  if (btnODS) {
    btnODS.onclick = () => {
      const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
      const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
      if (!display.length) return alert('No paths to export.');
      exportODS(StateMod.State, { results: display });
    };
  }

  const btnExportJSON = el('btnExportJSON');
  const btnImportJSON = el('btnImportJSON');
  const fileIn = el('fileIn');

  if (btnExportJSON) {
    btnExportJSON.onclick = () => {
      saveToLocal(StateMod.State);
      exportJSON(StateMod.State);
    };
  }

  if (btnImportJSON && fileIn) {
    btnImportJSON.onclick = () => fileIn.click();
    fileIn.onchange = async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const txt = await file.text();
      const state = importJSON(txt);
      if (!state) return alert('Invalid JSON.');
      StateMod.hydrate(state);
      StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));
      renderAllUI();
      fileIn.value = '';
      playback_resetToStart();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Simulation launcher button (auto-scenarios)                                */
/* -------------------------------------------------------------------------- */
function wireSimulationButton() {
  const btn = el('btnSimu');
  if (!btn) return;
  btn.onclick = async () => {
    try {
      disableTopButtons(true);
      setPlaybackEnabled(true);
      setPlayPauseVisual(true);
      playback_updateButtons();
      btn.textContent = 'Simulating…';
      btn.disabled = true;
      await runSimulation({ renderCallback: () => renderAllUI() });
    } finally {
      btn.textContent = 'Simulation';
      btn.disabled = false;
      enableTopButtons();
      setPlayPauseVisual(false);
      setPlaybackEnabled(false);
      renderAllUI();
      playback_resetToStart?.();
      playback_updateButtons();
    }
  };
}

/* -------------------------------------------------------------------------- */
/* Fresh simulation reset helper                                              */
/* -------------------------------------------------------------------------- */
function resetForFreshSimulation() {
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor');
  if (cur) cur.remove();

  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div'); ph.className = 'small'; ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }

  const svgSizeEl1 = el('svgSize'); if (svgSizeEl1) svgSizeEl1.textContent = '—';
  const statusEl  = el('status');   if (statusEl)  statusEl.textContent = '—';

  try { localStorage.removeItem('envuln-lite-store'); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}

  renderAllUI();
  if (typeof playback_resetToStart === 'function') playback_resetToStart();
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Results playback (diagram paging)                                          */
/* -------------------------------------------------------------------------- */
const playback = {
  dataset: [],
  index: 0,
  playing: false,
  timer: null,
  speed: 1.0,
  baseDelayMs: 1200
};

window.__updatePlaybackButtons = () => playback_updateButtons();

function playback_setDataset(results) {
  playback.dataset = Array.isArray(results) ? results.slice() : [];
  playback.index = 0;
  playback_updateButtons();
}
function playback_current() {
  return playback.dataset[playback.index] || null;
}
function playback_renderCurrent() {
  const p = playback_current();
  const box = el('diagramBox');
  const svgSizeEl = el('svgSize');
  if (!p || !box) {
    if (box) box.innerHTML = '<div class="small">Select a path → Diagram</div>';
    if (svgSizeEl) svgSizeEl.textContent = '—';
    return;
  }
  const svgStr = buildSVGForPath(p, StateMod.State);
  box.innerHTML = svgStr;
  const svg = box.querySelector('svg');
  if (svg && svgSizeEl) {
    const w = +svg.getAttribute('width') || svg.viewBox?.baseVal?.width || svg.getBoundingClientRect().width;
    const h = +svg.getAttribute('height') || svg.viewBox?.baseVal?.height || svg.getBoundingClientRect().height;
    svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
  }
}
function playback_updateButtons() {
  const btnPP          = el('btnPlayPause');
  const btnStop        = el('btnStop');
  const btnRestart     = el('btnRestart');
  const btnStepBack    = el('btnStepBack');
  const btnStepForward = el('btnStepForward');

  const simRunning = (typeof simIsRunning === 'function') && simIsRunning();
  const simPaused  = (typeof simIsPaused  === 'function') && simIsPaused();
  const hasData    = playback.dataset.length > 0;

  // enable the row when (a) sim is running OR (b) dataset is present, and the row is globally enabled
  const enableRow  = playbackControlsEnabled && (simRunning || hasData);

  [btnPP, btnStop, btnRestart, btnStepBack, btnStepForward].forEach(b => {
    if (b) b.disabled = !enableRow;
  });

  // step buttons: use sim stepping when sim is running, otherwise dataset edges
  if (enableRow) {
    if (simRunning) {
      if (btnStepBack)    btnStepBack.disabled    = !(typeof simCanStepBack === 'function' && simCanStepBack());
      if (btnStepForward) btnStepForward.disabled = !(typeof simCanStepForward === 'function' && simCanStepForward());
    } else {
      if (btnStepBack)    btnStepBack.disabled    = playback.index <= 0;
      if (btnStepForward) btnStepForward.disabled = playback.index >= (playback.dataset.length - 1);
    }
  }

  // icon logic: simulation state wins; dataset playback is used when no sim is running
  if (btnPP) {
    if (simRunning) {
      btnPP.textContent = simPaused ? '▶' : '⏸';
    } else {
      btnPP.textContent = playback.playing ? '⏸' : '▶';
    }
  }
}
function playback_tick() {
  if (!playback.playing) return;
  const delay = Math.max(200, Math.floor(playback.baseDelayMs / Math.max(0.2, playback.speed)));
  clearTimeout(playback.timer);
  playback.timer = setTimeout(() => {
    playback_stepForward();
    if (playback.playing) playback_tick();
  }, delay);
}
function playback_play() {
  if (!playback.dataset.length) return;
  playback.playing = true;
  playback_updateButtons();
  setPlayPauseVisual(true);
  playback_tick();
}
function playback_pause() {
  playback.playing = false;
  clearTimeout(playback.timer);
  playback_updateButtons();
  setPlayPauseVisual(false);
}
function playback_stop() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_restart() {
  playback.index = 0;
  playback_renderCurrent();
  if (playback.playing) playback_tick();
}
function playback_stepForward() {
  if (!playback.dataset.length) return;
  if (playback.index < playback.dataset.length - 1) {
    playback.index += 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_stepBack() {
  if (!playback.dataset.length) return;
  if (playback.index > 0) {
    playback.index -= 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_setSpeed(mult) {
  playback.speed = Math.max(0.2, Math.min(3, +mult || 1));
  const lab = el('simSpeedValue');
  if (lab) lab.textContent = `×${playback.speed.toFixed(1)}`;
  if (playback.playing) playback_tick();
}
function playback_resetToStart() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_showIndex(idx, pauseAfter = false) {
  if (!playback.dataset.length) return;
  playback.index = Math.max(0, Math.min(playback.dataset.length - 1, idx));
  playback_renderCurrent();
  if (pauseAfter) playback_pause();
}
function playback_computeIfNeededAndStart() {
  if (playback.dataset.length > 0) {
    playback_play();
    return;
  }
  const opts = {
    includeLateral: !!el('includeLateral')?.checked,
    includeContains: !!el('includeContains')?.checked
  };
  const max = parseInt(el('maxPaths')?.value || '2000', 10);
  const out = computeAllPaths(StateMod.State, opts, max);
  lastResults = out.paths || [];
  lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };

  const chkOnlyVuln = el('chkOnlyVuln');
  // Same "everywhere" definition as in wireTopActions
  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);
  const display = chkOnlyVuln && chkOnlyVuln.checked
    ? lastResults.filter(hasVulnsEverywhere)
    : lastResults;

  renderResultsList(display);

  if (display.length) {
    playback_renderCurrent();
    playback_play();
  } else {
    // Provide a status hint about probable cause
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const anyExits = (StateMod.State.attackers || []).some(a => (a.exits instanceof Set ? a.exits.size : (a.exits || []).length) > 0);
    if (filterOn && (lastResults?.length || 0) > 0) {
      renderStatus('0 paths • all were excluded by "Only vulnerable paths".');
    } else if (anyExits) {
      renderStatus('0 paths • check exit nodes are actually reachable.');
    } else {
      renderStatus('0 paths • check entries, links and options.');
    }
  }
}

/* -------------------------------------------------------------------------- */
/* Wire dataset + simulation playback controls                                */
/* -------------------------------------------------------------------------- */
function wirePlaybackControls() {
  const btnPP         = el('btnPlayPause');
  const btnStop       = el('btnStop');
  const btnRestart    = el('btnRestart');
  const btnStepBack   = el('btnStepBack');
  const btnStepForward= el('btnStepForward');
  const speed         = el('simSpeed');

  // Play / Pause
  if (btnPP) {
    btnPP.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        if (simIsPaused && simIsPaused()) {
          try { simPlay(); } catch {}
          setPlayPauseVisual(true);
        } else {
          try { simPause(); } catch {}
          setPlayPauseVisual(false);
        }
        playback_updateButtons();
        return;
      }
      // Dataset playback
      if (playback.playing) {
        playback_pause();
      } else {
        if (!playback.dataset.length) {
          playback_computeIfNeededAndStart();
        } else {
          if (!el('diagramBox')?.querySelector('svg')) playback_renderCurrent();
          playback_play();
        }
      }
      playback_updateButtons();
    };
  }

  // Stop
  if (btnStop) {
    btnStop.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}
        setPlayPauseVisual(false);
        setPlaybackEnabled(false);
        playback_updateButtons();
        return;
      }
      // Dataset playback stop
      playback_stop();
      playback_updateButtons();
    };
  }

  if (btnRestart) {
    btnRestart.onclick = async () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}

        try {
          disableTopButtons(true);
          setPlaybackEnabled(true);
          setPlayPauseVisual(true);
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulating…'; b.disabled = true; }
          await runSimulation({ renderCallback: () => renderAllUI() });
        } finally {
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulation'; b.disabled = false; }
          enableTopButtons();
          setPlayPauseVisual(false);
          setPlaybackEnabled(false);
          renderAllUI();
          playback_resetToStart?.();
          playback_updateButtons();
        }
        return;
      }
      playback_restart();
      playback_updateButtons();
    };
  }

  // Step back
  if (btnStepBack) {
    btnStepBack.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepBack(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepBack();
      playback_updateButtons();
    };
  }

  // Step forward
  if (btnStepForward) {
    btnStepForward.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepForward(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepForward();
      playback_updateButtons();
    };
  }

  // Speed
  if (speed) {
    playback_setSpeed(speed.value || 1);
    try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    const lab = el('simSpeedValue');
    if (lab) lab.textContent = `×${(+speed.value || 1).toFixed(1)}`;
    speed.addEventListener('input', () => {
      playback_setSpeed(speed.value);
      try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    });
  }

  // initial clean state
  playback_updateButtons();
  playback_renderCurrent();
}

/* -------------------------------------------------------------------------- */
/* Convenience export if needed elsewhere                                     */
/* -------------------------------------------------------------------------- */
function playback_setExternalResults(results) {
  playback_setDataset(results);
  playback_resetToStart();
}

/* -------------------------------------------------------------------------- */
/* Boot                                                                       */
/* -------------------------------------------------------------------------- */
window.__envuln_boot = {
  State: StateMod.State,
  computeAllPaths,
  playback_setExternalResults
};
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

===== ./js/state.js =====
// js/state.js
// Global application state

import { uid } from './helpers.js';

export const State = {
  version: 4,
  attackers: [],   // { id, name, entries:Set<targetId>, exits:Set<targetId> }
  targets: [],     // { id, name, vulns:Set<vulnId>, final:boolean }
  vulns: [],       // { id, name }
  edges: {
    direct: {},
    lateral: {},
    contains: {}
  }
};

export function ensureEdgeMaps(id){
  State.edges.direct[id]   = State.edges.direct[id]   || new Set();
  State.edges.lateral[id]  = State.edges.lateral[id]  || new Set();
  State.edges.contains[id] = State.edges.contains[id] || new Set();
}

function uniqueNameExists(list, name){
  return list.some(x => x.name.trim().toLowerCase() === name.trim().toLowerCase());
}

export function createAttacker(name){
  name = name.trim();
  if(!name) throw new Error('Attacker name required');
  if(uniqueNameExists(State.attackers, name)) throw new Error('Attacker already exists');
  const id = uid();
  State.attackers.push({ id, name, entries:new Set(), exits:new Set() });
  return id;
}

export function renameAttacker(id, newName){
  const a = State.attackers.find(x=>x.id===id);
  if(!a) throw new Error('Unknown attacker');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.attackers,newName) && a.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  a.name = newName;
}

export function deleteAttacker(id){
  State.attackers = State.attackers.filter(a=>a.id!==id);
}

export function createTarget(name, isFinal=false){
  name = name.trim();
  if(!name) throw new Error('Target name required');
  if(uniqueNameExists(State.targets,name)) throw new Error('Target already exists');
  const id = uid();
  State.targets.push({ id, name, vulns:new Set(), final:!!isFinal });
  ensureEdgeMaps(id);
  return id;
}

export function renameTarget(id, newName){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.targets,newName) && t.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  t.name = newName;
}

export function setTargetFinal(id, val){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  t.final = !!val;
}

export function deleteTarget(id){
  State.targets = State.targets.filter(t=>t.id!==id);
  for(const m of Object.values(State.edges)){
    delete m[id];
    for(const k in m) m[k].delete(id);
  }
  State.attackers.forEach(a => {
    a.entries?.delete(id);
    a.exits?.delete(id);
  });
}

export function createVuln(name){
  name = name.trim();
  if(!name) throw new Error('Vulnerability name required');
  if(uniqueNameExists(State.vulns,name)) throw new Error('Vulnerability already exists');
  const id = uid();
  State.vulns.push({ id, name });
  return id;
}

export function deleteVuln(id){
  State.vulns = State.vulns.filter(v=>v.id!==id);
  State.targets.forEach(t => t.vulns.delete(id));
}

export function toggleVulnOnTarget(targetId, vulnId, enable){
  const t = State.targets.find(x=>x.id===targetId);
  if(!t) throw new Error('Unknown target');
  if(!(t.vulns instanceof Set)) t.vulns = new Set(t.vulns || []);
  if(enable) t.vulns.add(vulnId); else t.vulns.delete(vulnId);
}

export function setAttackerEntries(attackerId, entryIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.entries = new Set(entryIds);
}

export function setAttackerExits(attackerId, exitIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.exits = new Set(exitIds);
}

export function addEdge(type, fromId, toId){
  if(!State.edges[type]) throw new Error('Invalid edge type');
  ensureEdgeMaps(fromId);
  State.edges[type][fromId].add(toId);
}

export function removeEdge(type, fromId, toId){
  if(!State.edges[type]) return;
  if(State.edges[type][fromId]) State.edges[type][fromId].delete(toId);
}

export const getAttackers = ()=> State.attackers;
export const getTargets   = ()=> State.targets;
export const getVulns     = ()=> State.vulns;

export function getTargetName(id){
  return (State.targets.find(t=>t.id===id)?.name) || '?';
}

// --- Add below: helpers for reviving JSON into live state -------------------
function asSet(x) {
  if (x instanceof Set) return x;
  if (Array.isArray(x)) return new Set(x);
  if (x && typeof x === 'object') return new Set(Object.keys(x)); // tolerate old shapes
  return new Set();
}
function reviveEdgeMap(rawMap = {}) {
  const out = {};
  for (const [fromId, tos] of Object.entries(rawMap)) {
    out[fromId] = asSet(tos);
  }
  return out;
}

// --- Exported: hydrate() to load a plain object into the live State ---------
export function hydrate(raw = {}) {
  // attackers
  State.attackers = Array.isArray(raw.attackers) ? raw.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: asSet(a.entries),
    exits:   asSet(a.exits)
  })) : [];

  // targets
  State.targets = Array.isArray(raw.targets) ? raw.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: asSet(t.vulns),
    final: !!t.final
  })) : [];

  // vulns
  State.vulns = Array.isArray(raw.vulns) ? raw.vulns.map(v => ({ id: v.id, name: v.name })) : [];

  // edges
  const edges = raw.edges || {};
  State.edges = {
    direct:   reviveEdgeMap(edges.direct),
    lateral:  reviveEdgeMap(edges.lateral),
    contains: reviveEdgeMap(edges.contains)
  };

  // ensure edge maps exist for every target id
  State.targets.forEach(t => ensureEdgeMaps(t.id));

  // bump/keep version
  State.version = Number.isFinite(raw.version) ? raw.version : State.version;
}

// (optional but handy) convert live state back to JSON-safe structure
export function dehydrate() {
  const edgeToObj = (m) => {
    const obj = {};
    for (const [k, v] of Object.entries(m)) obj[k] = Array.from(v || []);
    return obj;
  };
  return {
    version: State.version,
    attackers: State.attackers.map(a => ({
      id: a.id, name: a.name,
      entries: Array.from(a.entries || []),
      exits:   Array.from(a.exits   || [])
    })),
    targets: State.targets.map(t => ({
      id: t.id, name: t.name, final: !!t.final,
      vulns: Array.from(t.vulns || [])
    })),
    vulns: State.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   edgeToObj(State.edges.direct),
      lateral:  edgeToObj(State.edges.lateral),
      contains: edgeToObj(State.edges.contains)
    }
  };
}

if(typeof window !== 'undefined'){
  window.State = State;
}

===== ./js/helpers.js =====
/*************************************************************
 * helpers.js — tiny shared utilities for Envuln
 * ⚙️ 100% client-side / no UI logic / no state mutations
 *************************************************************/

/**
 * Query DOM by ID (shorter to type)
 */
export const el = id => document.getElementById(id);

/**
 * Normalized string: trim + collapse spaces
 */
export const norm = s => (s || '').trim().replace(/\s+/g, ' ');

/**
 * Cheap unique ID — enough for UI graph nodes
 */
export const uid = () =>
  Math.random().toString(36).slice(2, 9) + '-' + Date.now().toString(36);

/**
 * Escape text for safe HTML/SVG insertion (no DOMParser needed)
 */
export const esc = s =>
  String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

/**
 * Safe integer parsing with fallback
 */
export const toInt = (v, fallback = 0) => {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
};

/**
 * Clamp number between min and max
 */
export const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

/**
 * Remove duplicates while preserving order
 */
export const unique = arr => [...new Set(arr)];

/**
 * DOM: small utility to create elements faster
 * ex: div('.badge') or div({ class:'item', text:'Click!' })
 */
export function div(arg){
  const el = document.createElement('div');
  if(typeof arg === 'string'){
    el.className = arg.replace(/^\./,'');
  } else if(arg && typeof arg === 'object'){
    if(arg.class) el.className = arg.class;
    if(arg.text) el.textContent = arg.text;
    if(arg.html) el.innerHTML = arg.html;
  }
  return el;
}

/**
 * Scroll node into center view if needed (no crash if missing)
 */
export function ensureInView(node, block='center'){
  try { node?.scrollIntoView({ behavior:'smooth', block }); } catch {}
}

/**
 * Async wait helper (ms)
 */
export const wait = ms => new Promise(res => setTimeout(res, ms));

/**
 * Toggle class for a short pulse highlight
 */
export function pulse(node, duration = 600){
  if(!node) return;
  node.classList.add('sim-pulse');
  setTimeout(()=> node.classList.remove('sim-pulse'), duration);
}

===== ./js/exportODS.js =====
// exportODS.js
// Generate a Flat ODS (.fods) spreadsheet fully client-side

import { computeAllPaths, nameOfTarget } from './paths.js';

/**
 * Export results into a Flat ODS file (.fods)
 * @param {Object} state Current state (from state.js)
 * @param {Object} options Optional: { results?:Array, filter?:Function }
 *   - results: precomputed paths array (same shape as computeAllPaths(...).paths)
 *   - filter : (path) => boolean  (to include/exclude rows)
 */
export function exportODS(state, options = {}) {
  const pre = (options.results && Array.isArray(options.results)) ? options.results : null;
  const results = pre ?? computeAllPaths(state).paths;

  const filterFn = typeof options.filter === 'function' ? options.filter : () => true;

  const filtered = results.filter(filterFn);
  if (!filtered.length) {
    alert("No paths to export.");
    return;
  }

  // Helpers
  const esc = s => String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

  // ===== HEADERS =====
  const headPaths  = ['#','Attacker','Chain','Length','Final','Vulnerabilities (summary)'];
  const headDetail = ['Attacker','Step','Target','Final?','Vulnerabilities'];
  const headGraph  = ['Type','Source','Destination'];

  // ===== ROW BUILDERS =====
  const rowsPaths = filtered.map((p, idx) => {
    const chain = p.nodes.map(n => n.name).join(' → ');
    const len = p.nodes.length;
    const finale = len ? p.nodes[len - 1].name : '';
    const vulnSummary = p.vulnsPerNode.map((vs, i) => {
      const n = p.nodes[i]?.name || '?';
      return `[${n}: ${vs?.length ? vs.join(', ') : '—'}]`;
    }).join(' ');
    return [ String(idx+1), p.attackerName || p.attacker || '', chain, String(len), finale, vulnSummary ];
  });

  const rowsDetail = [];
  filtered.forEach(p => {
    p.nodes.forEach((n, i) => {
      const vs = p.vulnsPerNode?.[i] || [];
      rowsDetail.push([
        p.attackerName || p.attacker || '',
        String(i + 1),
        n?.name || '',
        (i === p.nodes.length - 1) ? 'Yes' : 'No',
        vs.length ? vs.join(', ') : '—'
      ]);
    });
  });

  const rowsGraph = [];
  const pushEdges = (type, map) => {
    for (const from in map) {
      const tos = Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []);
      tos.forEach(to => {
        rowsGraph.push([
          type,
          nameOfTarget(state, from),
          nameOfTarget(state, to)
        ]);
      });
    }
  };
  pushEdges('direct',   state.edges?.direct || {});
  pushEdges('lateral',  state.edges?.lateral || {});
  pushEdges('contains', state.edges?.contains || {});

  // ===== STYLE (readability) =====
  const styles = `
  <office:styles>
    <!-- Bold header -->
    <style:style style:name="hdr" style:family="table-cell">
      <style:text-properties fo:font-weight="bold"/>
      <style:table-cell-properties fo:background-color="#0b1730"
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"/>
      <style:paragraph-properties fo:margin="0cm"/>
    </style:style>

    <!-- Zebra row styles -->
    <style:style style:name="z1" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <style:style style:name="z2" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        fo:background-color="#0f223f" style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Wrapped text -->
    <style:style style:name="wrap" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Column widths -->
    <style:style style:name="colNarrow" style:family="table-column">
      <style:table-column-properties style:column-width="1.2cm"/>
    </style:style>
    <style:style style:name="colMed" style:family="table-column">
      <style:table-column-properties style:column-width="4.2cm"/>
    </style:style>
    <style:style style:name="colWide" style:family="table-column">
      <style:table-column-properties style:column-width="9.5cm"/>
    </style:style>
    <style:style style:name="colXL" style:family="table-column">
      <style:table-column-properties style:column-width="14cm"/>
    </style:style>
  </office:styles>`;

  // ===== XML TABLE UTILS =====
  const mkHeader = heads => `
    <table:table-header-rows>
      <table:table-row>
        ${heads.map(h =>
          `<table:table-cell office:value-type="string" table:style-name="hdr">
             <text:p>${esc(h)}</text:p>
           </table:table-cell>`
        ).join('')}
      </table:table-row>
    </table:table-header-rows>`;

  const mkRow = (cells, zebra=false, wrapIdx=new Set()) => `
    <table:table-row>
      ${cells.map((c,i)=>{
        const style = wrapIdx.has(i) ? 'wrap' : (zebra ? 'z2' : 'z1');
        return `<table:table-cell office:value-type="string" table:style-name="${style}">
                  <text:p>${esc(c)}</text:p>
                </table:table-cell>`;
      }).join('')}
    </table:table-row>`;

  // Columns that should wrap
  const wrapPaths  = new Set([2, 5]); // Chain, Vulnerabilities (summary)
  const wrapDetail = new Set([4]);    // Vulnerabilities
  const wrapGraph  = new Set([]);     // None

  // Build table bodies
  const headerPaths  = mkHeader(headPaths);
  const bodyPaths    = rowsPaths.map((r,i)=> mkRow(r, i%2===1, wrapPaths)).join('');
  const headerDetail = mkHeader(headDetail);
  const bodyDetail   = rowsDetail.map((r,i)=> mkRow(r, i%2===1, wrapDetail)).join('');
  const headerGraph  = mkHeader(headGraph);
  const bodyGraph    = rowsGraph.map((r,i)=> mkRow(r, i%2===1, wrapGraph)).join('');

  // Column layouts
  const colsPaths = `
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsDetail = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsGraph = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>`;

  // ===== ASSEMBLY =====
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document
 xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0"
 xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0"
 xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0"
 xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0"
 xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"
 office:version="1.2"
 office:mimetype="application/vnd.oasis.opendocument.spreadsheet">
 ${styles}
 <office:body>
   <office:spreadsheet>

     <!-- Paths sheet -->
     <table:table table:name="Paths">
       ${colsPaths}
       ${headerPaths}
       ${bodyPaths}
     </table:table>

     <!-- Detail sheet -->
     <table:table table:name="Detail">
       ${colsDetail}
       ${headerDetail}
       ${bodyDetail}
     </table:table>

     <!-- Graph sheet -->
     <table:table table:name="Graph">
       ${colsGraph}
       ${headerGraph}
       ${bodyGraph}
     </table:table>

   </office:spreadsheet>
 </office:body>
</office:document>`;

  // ===== DOWNLOAD =====
  const blob = new Blob(
    [xml],
    { type: 'application/vnd.oasis.opendocument.spreadsheet' }
  );
  const filename = `envuln-export-${new Date().toISOString().replace(/[:.]/g,'-')}.fods`;

  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

===== ./js/storage.js =====
/**
 * storage.js
 * Save and load application state to/from localStorage.
 * Converts runtime structures (Sets) to plain arrays for persistence.
 */

const KEY = 'envuln-lite-store';
const CURRENT_VERSION = 4;

/* ------------ Public API ------------ */

/**
 * Serialize runtime state to localStorage.
 * @param {object} state
 */
export function saveToLocal(state) {
  try {
    localStorage.setItem(KEY, JSON.stringify(toSerializable(state)));
  } catch (e) {
    console.warn('[storage] save error:', e);
  }
}

/**
 * Load from localStorage and convert back to runtime state.
 * @returns {object|null}
 */
export function loadFromLocal() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return null;

    const obj = JSON.parse(raw);
    if (!obj.version || obj.version !== CURRENT_VERSION) {
      console.warn('[storage] version mismatch: resetting storage');
      return null;
    }
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] load error -> reset storage:', e);
    return null;
  }
}

/** Clear storage */
export function clearLocal() {
  localStorage.removeItem(KEY);
}

/** Export JSON to a downloadable file */
export function exportJSON(state) {
  const serial = toSerializable(state);
  const blob = new Blob([JSON.stringify(serial, null, 2)], { type: 'application/json' });
  const ts = new Date().toISOString().replace(/[:.]/g, '-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `envuln-export-${ts}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/**
 * Convert a JSON string previously exported back into runtime state.
 * The caller is responsible for assigning it to the live singleton.
 */
export function importJSON(jsonStr) {
  try {
    const obj = JSON.parse(jsonStr);
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] invalid import JSON', e);
    return null;
  }
}

/* ------------ Runtime → serial ------------ */

function toSerializable(state) {
  return {
    version: CURRENT_VERSION,
    attackers: state.attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: [...a.entries],
      exits:   [...a.exits]
    })),
    targets: state.targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: [...t.vulns],
      final: !!t.final
    })),
    vulns: state.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   setsToArrays(state.edges.direct),
      lateral:  setsToArrays(state.edges.lateral),
      contains: setsToArrays(state.edges.contains),
    }
  };
}

/* ------------ Serial → runtime ------------ */

function fromSerializable(obj) {
  if (!obj || typeof obj !== 'object') {
    console.warn('[storage] fromSerializable failed');
    return null;
  }

  const {
    attackers = [],
    targets = [],
    vulns = [],
    edges = {}
  } = obj;

  return {
    version: obj.version ?? CURRENT_VERSION,
    vulns: vulns.map(v => ({ id: v.id, name: v.name })),
    targets: targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: new Set(t.vulns || []),
      final: !!t.final
    })),
    attackers: attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: new Set(a.entries || []),
      exits:   new Set(a.exits   || [])
    })),
    edges: {
      direct:   arraysToSets(edges.direct   || {}),
      lateral:  arraysToSets(edges.lateral  || {}),
      contains: arraysToSets(edges.contains || {})
    }
  };
}

/* ------------ Helpers ------------ */

function setsToArrays(map) {
  const out = {};
  for (const k in map) {
    out[k] = [...(map[k] || [])];
  }
  return out;
}

function arraysToSets(map) {
  const out = {};
  for (const k in map) {
    out[k] = new Set(map[k] || []);
  }
  return out;
}

===== ./styles/app.css =====
/* =====================
   Global theme
===================== */
:root {
  --bg: #071022;
  --panel: #0d1726;
  --muted: #9fb0c6;
  --accent: #2b8af6;
  --glass: rgba(255,255,255,0.03);

  --border-light: rgba(255,255,255,0.06);
  --border-soft: rgba(255,255,255,0.04);
  --border-strong: rgba(255,255,255,0.08);

  --text-main: #e6eef8;
  --text-muted: #9fb0c6;

  --shadow: 0 6px 18px rgba(0,0,0,0.6);
  --radius: 10px;
}

html, body {
  margin: 0;
  height: 100%;
  font-family: Inter, system-ui, Arial, sans-serif;
  background: linear-gradient(180deg, #041022, #021018);
  color: var(--text-main);
  user-select: none;
}

/* =====================
   Layout
===================== */
.wrap {
  display: grid;
  height: 100vh;
  box-sizing: border-box;
  padding: 18px;
  grid-template-columns: 300px 1fr 380px;
  gap: 16px;
}

.panel {
  min-height: 0;
  padding: 12px;
  overflow: auto;
  border-radius: var(--radius);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  box-shadow: var(--shadow);
}

/* Responsive */
@media (max-width: 1100px) {
  .wrap {
    grid-template-columns: 1fr;
    grid-auto-rows: minmax(0, auto);
  }
}

/* =====================
   Typography
===================== */
h3 {
  margin: 6px 0 10px;
  font-size: 14px;
  font-weight: 600;
}

.small {
  font-size: 13px;
  color: var(--text-muted);
}

.mini {
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Controls
===================== */
input[type=text],
input[type=number],
input[type=range],
select,
textarea {
  width: 100%;
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-light);
  background: rgba(255,255,255,0.02);
  color: inherit;
  box-sizing: border-box;
}

button {
  background: var(--accent);
  border: none;
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: opacity .2s ease;
}
button:hover {
  opacity: 0.9;
}

button.ghost {
  background: transparent;
  border: 1px dashed var(--border-light);
  color: var(--text-muted);
}
button.ghost:hover {
  color: #fff;
  border-color: var(--accent);
}

/* =====================
   Lists & Items
===================== */
.list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: var(--glass);
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-soft);
}

.item .left {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.badge {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Result cards
===================== */
.path-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.path {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  align-items: flex-start;
  padding: 8px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
}

.path .left {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* =====================
   Diagram panel
===================== */
.uml {
  overflow-x: auto;
  overflow-y: hidden;
  min-height: 260px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius);
  padding: 8px;
}

/* =====================
   Simulation visual markers
===================== */
.sim-pulse {
  box-shadow: 0 0 0 3px rgba(59,130,246,0.35) !important;
}

/* nice scrolling everywhere */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.12);
  border-radius: 8px;
}
::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.22);
}

/* small fade hover on list items */
.item:hover,
.path:hover {
  background: rgba(255,255,255,0.04);
}

/* =====================
   Playback
===================== */
/* Playback disabled look */
#playbackRow.is-disabled {
  opacity: 0.45;
  filter: grayscale(0.6);
  pointer-events: none; /* clicks blocked while disabled */
}

/* Align items inside attacker/target/vulnerability lists */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#panelEntities .list > div {
  display: flex;
  flex-direction: column;
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  padding: 10px 12px;
  position: relative;
}

/* Force actions to right side — horizontally aligned */
#panelEntities .list > div button {
  align-self: flex-end; /* right-align actions */
  margin-top: 6px;      /* spacing from text */
}

/* Ensure Rename and Delete align together nicely */
#panelEntities .list > div button + button {
  margin-left: 8px;
}

/* ===============================
   Compact lists in the left panel
==================================== */

#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;                 /* space between cards */
}

#panelEntities .list > div {
  position: relative;        /* required to position the buttons on the right */
  padding: 12px 180px 12px 14px; /* space reserved on the right for the buttons */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* Title + meta on a single line when possible */
#panelEntities .list > div > div {
  display: inline;           /* “Attacker A  Entries: …” stays on the same line */
}

/* Right-aligned buttons, same line, no wrapper needed */
#panelEntities .list > div > button:nth-last-of-type(2) {
  position: absolute;
  top: 12px;
  right: 96px;               /* positions the “Rename” button to the left of Delete */
}
#panelEntities .list > div > button:last-of-type {
  position: absolute;
  top: 12px;
  right: 14px;               /* “Delete” button on the far right */
}

/* Small visual adjustments */
#panelEntities .list > div > button {
  margin: 0;                 /* removes vertical margin that added unnecessary spacing */
}

/* === Left panel list cards: full width, no squeeze === */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Carte = grid: [contenu flexible] [Rename] [Delete]  */
#panelEntities .list > div {
  display: grid;
  grid-template-columns: 1fr auto auto; /* contenu prend toute la largeur */
  align-items: start;
  gap: 10px;
  padding: 12px;                /* ← plus de padding droit réservé */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
  position: static;             /* ← plus d'absolu */
}

/* Colonne contenu = prend tout l'espace  */
#panelEntities .list > div .left {
  grid-column: 1 / 2;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  min-width: 0;                 /* ← autorise l'expansion */
}

/* Les deux boutons sur la droite, alignés en haut */
#panelEntities .list > div > button {
  position: static;             /* ← supprime l'absolu */
  align-self: start;
  margin: 0;
}
#panelEntities .list > div > button:nth-last-of-type(2) { grid-column: 2 / 3; }
#panelEntities .list > div > button:last-of-type       { grid-column: 3 / 4; }

/* Ajustements de texte/badges pour éviter les colonnes étroites */
#panelEntities .list .badge { display: inline-block; }
#panelEntities .list .mini  { white-space: normal; word-break: break-word; }

/* Optionnel: cartes génériques .item → s'étirent aussi */
.item {
  display: grid;
  grid-template-columns: 1fr auto; /* contenu + actions */
  align-items: start;
  gap: 10px;
}
.item .left { min-width: 0; }

@media (max-width: 520px) {
  #panelEntities .list > div {
    grid-template-columns: 1fr;    /* contenu pleine largeur */
  }
  #panelEntities .list > div > button {
    grid-column: 1 / -1;           /* boutons passent dessous */
    justify-self: end;
  }
}

/* === Left panel: cartes pleine largeur, contenu fluide === */

/* 1) Annule les anciens hacks (inline/absolute/padding réservé) */
#panelEntities .list > div > div { display: block !important; }
#panelEntities .list > div > button { position: static !important; }
#panelEntities .list > div { padding-right: 12px !important; }

/* 2) La carte .item devient une grid: [contenu][Rename][Delete] */
#panelEntities .list .item {
  display: grid !important;
  grid-template-columns: 1fr auto auto;   /* contenu prend tout, boutons autos */
  align-items: start;
  gap: 12px;
  padding: 12px;
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* 3) Colonne contenu: laisse respirer le texte */
#panelEntities .list .item .left {
  min-width: 0;            /* autorise l’expansion */
  display: flex;
  flex-direction: column;  /* badge au-dessus, mini dessous */
  gap: 6px;
}

/* 4) Texte des "mini" non étriqué */
#panelEntities .list .mini {
  white-space: normal;     /* pas de contrainte inline */
  word-break: break-word;
  line-height: 1.25;
}

/* 5) Groupe de boutons alignés à droite sans chevauchement */
#panelEntities .list .item > div:last-child {
  display: flex;
  gap: 8px;
  align-items: start;
}

/* Option mobile: empile les boutons sous le contenu */
@media (max-width: 560px) {
  #panelEntities .list .item {
    grid-template-columns: 1fr;
  }
  #panelEntities .list .item > div:last-child {
    justify-self: end;
  }
}


===== ./index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ENVULN — Threat Path Explorer</title>
  <link rel="stylesheet" href="./styles/app.css">
</head>

<body>
<div class="wrap">

  <!-- LEFT PANEL — Add + Manage Entities -->
  <div class="panel" id="panelEntities">
    <h3>Add & Manage</h3>
    <div class="small">Add, rename, or delete entities here.</div>

    <!-- Add forms -->
    <div class="form-block">
      <label>New attacker</label>
      <div class="row">
        <input id="attackerName" placeholder="Attacker name">
        <button id="btnAddAttacker">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New target</label>
      <div class="row">
        <input id="targetName" placeholder="Target name">
        <button id="btnAddTarget">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New vulnerability</label>
      <div class="row">
        <input id="vulnName" placeholder="Vulnerability name">
        <button id="btnAddVuln">Add</button>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnResetAll" class="ghost">Reset all</button>
    </div>

    <hr>

    <!-- Entity Lists -->
    <h3>Attackers</h3>
    <div id="attackerList" class="list"></div>

    <h3>Attacker targets</h3>
    <div id="targetList" class="list"></div>

    <h3>Vulnerabilities</h3>
    <div id="vulnList" class="list"></div>
  </div>

  <!-- CENTER PANEL — Associations / Compute / Results -->
  <div class="panel" id="panelAssociations">
    <h3>Configuration & Exploration</h3>

    <div class="row ceiling-row">
      <!-- (Simulation speed and Path limit moved to the right panel) -->
    </div>

    <hr>

    <!-- Attacker selection -->
    <h3>Attacker selection</h3>
    <div class="small">Choose the current attacker.</div>
    <div class="row">
      <select id="selAttacker"></select>
    </div>

    <hr>

    <!-- Entry points selection -->
    <h3>Attacker entry points</h3>
    <div class="small">Select targets that act as entry points for the attacker.</div>
    <div class="row">
      <select id="selEntriesAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearEntries" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Exit points selection -->
    <h3>Attacker exit points</h3>
    <div class="small">Select targets that act as exit points for the attacker.</div>
    <div class="row">
      <select id="selExitsAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearExits" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Vulnerability association -->
    <h3>Vulnerabilities</h3>
    <div class="small">Pick an element, then select/unselect the vulnerabilities to associate.</div>

    <div class="row">
      <div class="col">
        <label>Element to edit</label>
        <select id="selVulnElement">
          <!-- filled by JS -->
        </select>
      </div>

      <div class="col">
        <label>Vulnerabilities (multi)</label>
        <select id="selVulnsForElement" multiple size="6"></select>
      </div>
    </div>

    <div class="row">
      <button id="btnClearVulnSelection" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Links -->
    <h3>Links between targets</h3>
    <div class="row">
      <select id="linkSource"></select>
      <select id="linkDest" multiple size="4"></select>
      <select id="linkType">
        <option value="direct">direct</option>
        <option value="lateral">lateral</option>
        <option value="contains">contains</option>
      </select>
    </div>

    <div class="row">
      <button id="btnClearLinkSelection" class="ghost">Clear selection</button>
    </div>
    <div class="row">
      <label><input type="checkbox" id="includeLateral" checked> include lateral</label>
      <label><input type="checkbox" id="includeContains" checked> include contains</label>
    </div>

    <div id="linksInspector" class="small"></div>

    <hr>

    <!-- Actions -->
    <div class="row top-actions">
      <button id="btnFindPaths">Compute paths</button>
      <button id="btnExportODS" class="ghost">Export ODS</button>
      <button id="btnImportJSON" class="ghost">Import JSON</button>
      <button id="btnExportJSON" class="ghost">Export JSON</button>
      <button id="btnSimu" class="ghost">Simulation</button>
      <input type="file" id="fileIn" accept="application/json" hidden>
      <span id="status" class="small">—</span>
    </div>

    <hr>

    <!-- Results -->
    <h3 style="display:flex;align-items:center;gap:10px">
      Results
      <label class="small" style="display:inline-flex;align-items:center;gap:6px">
        <input type="checkbox" id="chkOnlyVuln">
        Vulnerable paths only
      </label>
    </h3>

    <div id="results" class="path-list"></div>
  </div>

  <!-- RIGHT PANEL — Tutorial + Configuration + Diagram -->
  <div class="panel" id="panelDetailsRight">
    <h3>Tutorial</h3>
    <ol id="tutorial" class="small">
      <li>Add attackers, targets, and vulnerabilities in the left panel.</li>
      <li>Select the current attacker from “Attacker selection”.</li>
      <li>Choose attacker entry points, then use “Clear selection” if needed.</li>
      <li>Choose attacker exit points, then use “Clear selection” if needed.</li>
      <li>Select an element and pick vulnerabilities to associate; use “Clear selection” to reset.</li>
      <li>Configure links between targets; use “Clear selection” to reset the link pickers.</li>
      <li>Adjust path visibility (include lateral/contains) using the checkboxes.</li>
      <li>Click “Compute paths” to generate results.</li>
      <li>Select a path to view the attack diagram.</li>
      <li>Use the playback controls to play, pause, stop, restart, step back, or step forward the simulation.</li>
      <li>Export data as needed (JSON/ODS).</li>
    </ol>

    <hr>

    <!-- Playback controls (above simulation speed) -->
    <div class="row" id="playbackRow" style="justify-content:center;gap:10px">
      <button id="btnStepBack" class="ghost" title="Step back" aria-label="Step back">⏮</button>
      <button id="btnPlayPause" title="Play/Pause" aria-label="Play or pause">▶</button>
      <button id="btnStepForward" class="ghost" title="Step forward" aria-label="Step forward">⏭</button>
      <button id="btnStop" class="ghost" title="Stop" aria-label="Stop">⏹</button>
      <button id="btnRestart" class="ghost" title="Restart" aria-label="Restart">↺</button>
    </div>
    
    <div class="row">
      <div class="col speed-col">
        <label for="simSpeed">Simulation speed</label>
        <input id="simSpeed" type="range" min="0.2" max="3" step="0.1" value="1">
        <span id="simSpeedValue">×1.0</span>
      </div>
    </div>

    <hr>

    <div class="row ceiling-row">
      <label for="maxPaths">Path limit</label>
      <input type="number" id="maxPaths" min="100" value="2000">
    </div>

    <hr>

    <h3>Attack diagram</h3>
    <div id="diagramBox" class="uml"><div class="small">Select a path → Diagram</div></div>

    <div class="row">
      <button id="btnDownloadSVG" class="ghost">Download SVG</button>
      <span id="svgSize" class="small">—</span>
    </div>
  </div>

</div>

<script type="module" src="./js/main.js"></script>
</body>
</html>

===== ./js/ui/links.js =====
// js/ui/links.js
// UI logic for managing links between targets using the selectors present in the page.

import { State, ensureEdgeMaps } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

/* =========================
   Internal helpers
========================= */

function nameOfTarget(id) {
  const t = State.targets.find(x => x.id === id);
  return t ? t.name : '?';
}

function getLinkMapByType(type) {
  if (type === 'direct')   return State.edges.direct;
  if (type === 'lateral')  return State.edges.lateral;
  if (type === 'contains') return State.edges.contains;
  return null;
}

function addLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map) return;
  ensureEdgeMaps(from);
  map[from].add(to);
}

function removeLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map || !map[from]) return;
  map[from].delete(to);
}

function clearAndFillSelect(selectEl, items) {
  selectEl.innerHTML = '';
  items.forEach(({ id, name }) => {
    const o = document.createElement('option');
    o.value = id;
    o.textContent = name;
    selectEl.appendChild(o);
  });
}

/* =========================
   Populate selectors
========================= */

export function populateLinkSelectors() {
  const src = el('linkSource');
  const dst = el('linkDest');
  const type = el('linkType');

  if (!src || !dst || !type) return;

  const items = State.targets.map(t => ({ id: t.id, name: t.name }));
  clearAndFillSelect(src, items);
  clearAndFillSelect(dst, items);

  if (!['direct', 'lateral', 'contains'].includes(type.value)) {
    type.value = 'direct';
  }
}

/* =========================
   Links inspector
========================= */

export function renderLinksInspector() {
  const box = el('linksInspector');
  const src = el('linkSource')?.value;

  if (!box) return;

  if (!src) {
    box.innerHTML = '<div class="mini">Pick a source to view its links.</div>';
    return;
  }

  const makeGroup = (label, mapObj, typeKey) => {
    const set = mapObj[src] || new Set();
    const items = Array.isArray(set) ? set : [...set];
    if (!items.length) {
      return `<div style="margin-top:6px"><strong>${label}:</strong> —</div>`;
    }
    const chips = items.map(toId => {
      const tName = nameOfTarget(toId);
      const btn = `<button data-type="${typeKey}" data-to="${toId}" class="ghost" style="padding:2px 6px;border-radius:6px">Remove</button>`;
      return `<span class="badge" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${tName}${btn}</span>`;
    }).join(' ');
    return `<div style="margin-top:6px"><strong>${label}:</strong><div style="margin-top:4px">${chips}</div></div>`;
  };

  box.innerHTML = [
    `<div class="mini">Links from <strong>${nameOfTarget(src)}</strong> (use "Remove" to delete)</div>`,
    makeGroup('direct',   State.edges.direct,   'direct'),
    makeGroup('lateral',  State.edges.lateral,  'lateral'),
    makeGroup('contains', State.edges.contains, 'contains'),
  ].join('');

  box.onclick = (e) => {
    const btn = e.target.closest('button[data-to]');
    if (!btn) return;
    const type = btn.getAttribute('data-type');
    const to   = btn.getAttribute('data-to');
    removeLink(type, src, to);
    saveToLocal(State);
    renderLinksInspector();
    // Keep the destination multiselect visually in sync
    syncDestSelectionFromState();
  };
}

/* =========================
   Event wiring
========================= */

let _syncDestSelectionFromState = null;
function syncDestSelectionFromState() {
  // late-bound to avoid accessing elements before ready
  if (typeof _syncDestSelectionFromState === 'function') {
    _syncDestSelectionFromState();
  }
}

export function wireLinksUI() {
  const srcSel   = el('linkSource');
  const dstSel   = el('linkDest');
  const typeSel  = el('linkType');
  const btnClear = el('btnClearLinkSelection');

  if (!srcSel || !dstSel || !typeSel) return;

  _syncDestSelectionFromState = () => {
    const from = srcSel.value;
    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    const set = map[from] || new Set();
    const current = new Set(Array.isArray(set) ? set : Array.from(set));
    [...dstSel.options].forEach(o => { o.selected = current.has(o.value); });
    renderLinksInspector();
  };

  srcSel.addEventListener('change', _syncDestSelectionFromState);
  typeSel.addEventListener('change', _syncDestSelectionFromState);

  // Real-time persistence on every change
  dstSel.addEventListener('change', () => {
    const from = srcSel.value;
    if (!from) return;

    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    ensureEdgeMaps(from);

    const before = new Set(Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []));
    const after  = new Set([...dstSel.selectedOptions].map(o => o.value));

    for (const to of after) {
      if (!before.has(to)) addLink(type, from, to);
    }
    for (const to of before) {
      if (!after.has(to)) removeLink(type, from, to);
    }

    saveToLocal(State);
    renderLinksInspector();
  });

  // Clear selection button: clears UI and state through the change handler
  if (btnClear) {
    btnClear.onclick = () => {
      [...dstSel.options].forEach(o => o.selected = false);
      dstSel.dispatchEvent(new Event('change', { bubbles: true }));
    };
  }

  populateLinkSelectors();
  _syncDestSelectionFromState();
}

===== ./js/ui/results.js =====
// js/ui/results.js
// Module responsible for rendering computed attack paths (results panel).
// Exports: initResultsPanel, renderResults, computeAndRenderAll, renderDiagramForPath, getLastResults, getLastMeta
// Dependencies: ../helpers.js (el, esc), ../paths.js (computeAllPaths), ../diagram.js (buildSVGForPath), ../state.js (State)

import { el, esc } from '../helpers.js';
import { computeAllPaths } from '../paths.js';
import { buildSVGForPath } from '../diagram.js';
import { State } from '../state.js';
import { exportODS } from '../exportODS.js'; // optional: if you implemented exporter

// Internal cache
let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

// UI element references (populated on init)
let resultsBox = null;
let chkOnlyVuln = null;
let statusEl = null;
let svgContainer = null;
let svgSizeEl = null;
let downloadSvgBtn = null;

/* ---------- UTIL ---------- */
// By design, we ignore the *first* node of the path for the vuln-everywhere filter,
// because entry nodes often don't carry a vulnerability in the model.
const hasVulnsEverywhere = (path) => {
  if (!Array.isArray(path.vulnsPerNode)) return false;
  const slice = path.vulnsPerNode.slice(1);
  if (!slice.length) return false;
  return slice.every(vs => Array.isArray(vs) && vs.length > 0);
};

const getDisplayResults = () => {
  if (chkOnlyVuln && chkOnlyVuln.checked) {
    return lastResults.filter(hasVulnsEverywhere);
  }
  return lastResults;
};

function renderSummary(count, meta = {}) {
  if (!statusEl) return;
  const parts = [];
  parts.push(`${count} path${count === 1 ? '' : 's'}`);
  if (meta.cycles) parts.push('cycles detected (simple paths)');
  if (meta.truncated) parts.push('truncated by ceiling');
  statusEl.textContent = parts.join(' • ');
}

/* ---------- RENDER RESULTS ---------- */
function renderResults(resultsArray, meta = {}) {
  if (!resultsBox) return;
  // Cache full (unfiltered) set and metadata
  lastResults = Array.isArray(resultsArray) ? resultsArray.slice() : [];
  lastMeta = Object.assign({}, meta);

  // Decide what to display
  const toDisplay = getDisplayResults();

  resultsBox.innerHTML = '';
  if (!toDisplay.length) {
    const empty = document.createElement('div');
    empty.className = 'small';
    const filtered = !!(chkOnlyVuln && chkOnlyVuln.checked);
    empty.textContent = filtered
      ? 'No paths match the “only vulnerable” filter.'
      : 'No paths (check entry points, finals and link types).';
    resultsBox.appendChild(empty);
    renderSummary(0, meta);
    return;
  }

  // Build entries
  toDisplay.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.alignItems = 'flex-start';
    row.style.gap = '10px';
    row.style.padding = '8px';
    row.style.borderRadius = '8px';
    row.style.background = 'rgba(255,255,255,0.02)';

    // Left column: attacker + chain + vulns summary
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.flexDirection = 'column';
    left.style.gap = '6px';

    const title = document.createElement('div');
    title.innerHTML = `<strong>${esc(p.attacker)}</strong>`;
    left.appendChild(title);

    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.appendChild(chain);

    const vulnSummary = document.createElement('div');
    vulnSummary.className = 'mini';
    vulnSummary.style.fontSize = '12px';
    vulnSummary.style.color = 'var(--muted)';
    vulnSummary.textContent = p.vulnsPerNode.map((vs, i) =>
      vs && vs.length ? `[${p.nodes[i].name}: ${vs.join(', ')}]` : `[${p.nodes[i].name}: —]`
    ).join(' ');
    left.appendChild(vulnSummary);

    // Optionally grey-out impossible paths
    if (!hasVulnsEverywhere(p)) {
      row.style.opacity = '0.72';
      row.title = 'One or more targets have no vulnerabilities (path theoretically impossible)';
    }

    // Right column: actions
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.flexDirection = 'column';
    right.style.gap = '6px';
    right.style.alignItems = 'flex-end';

    const btnDiagram = document.createElement('button');
    btnDiagram.textContent = 'Diagram';
    btnDiagram.className = 'ghost';
    btnDiagram.onclick = () => {
      renderDiagramForPath(p);
      // focus diagram in UI
      if (svgContainer) svgContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
    };

    const btnZoom = document.createElement('button');
    btnZoom.textContent = 'Zoom';
    btnZoom.className = 'ghost';
    btnZoom.onclick = () => {
      // If a diagram is already rendered for this path, try to center it
      if (svgContainer) {
        svgContainer.style.boxShadow = '0 0 0 4px rgba(59,130,246,0.18)';
        setTimeout(() => svgContainer.style.boxShadow = 'none', 800);
      }
    };

    right.appendChild(btnDiagram);
    right.appendChild(btnZoom);

    row.appendChild(left);
    row.appendChild(right);
    resultsBox.appendChild(row);
  });

  renderSummary(toDisplay.length, meta);
}

/* ---------- DIAGRAM rendering + download ---------- */
function renderDiagramForPath(pathObj) {
  if (!svgContainer) return;
  try {
    // Pass live State so the builder can resolve entries, edge types, etc.
    const svgStr = buildSVGForPath(pathObj, State);
    svgContainer.innerHTML = svgStr;

    // store last svg for download
    const svgEl = svgContainer.querySelector('svg');
    if (svgEl) {
      // update size display (if provided)
      if (svgSizeEl) {
        const w = svgEl.getAttribute('width') || svgEl.viewBox?.baseVal?.width || svgEl.getBoundingClientRect().width;
        const h = svgEl.getAttribute('height') || svgEl.viewBox?.baseVal?.height || svgEl.getBoundingClientRect().height;
        svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
      }
      // attach download helper
      if (downloadSvgBtn) {
        downloadSvgBtn.onclick = () => {
          const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
          const ts = new Date().toISOString().replace(/[:.]/g, '-');
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `attack-diagram-${ts}.svg`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(a.href), 0);
        };
      }
    }
  } catch (err) {
    console.error('renderDiagramForPath:', err);
    if (svgContainer) svgContainer.innerHTML = `<div class="small">Failed to render diagram: ${esc(String(err))}</div>`;
  }
}

/* ---------- Compute (bridge to paths.js) ---------- */
async function computeAndRenderAll(state, opts = { includeLateral: true, includeContains: true, maxPaths: 2000 }) {
  // computeAllPaths returns an object { paths, cycles, truncated }
  const out = computeAllPaths(state, opts, opts.maxPaths);
  const arr = Array.isArray(out?.paths) ? out.paths : [];

  // ensure normalized shape: nodes are target objects and vulnsPerNode array exists
  const normalized = arr.map(r => {
    return {
      attacker: r.attackerName || r.attacker || r.attackerId || '',
      attackerId: r.attackerId || '',
      nodes: r.nodes || (r.nodeIds || []).map(id => ({ id, name: id })), // fallback
      vulnsPerNode: Array.isArray(r.vulnsPerNode) ? r.vulnsPerNode : (r.nodes ? r.nodes.map(() => []) : [])
    };
  });

  const meta = { cycles: !!out.cycles, truncated: !!out.truncated };

  // render
  renderResults(normalized, meta);
  return normalized;
}

/* ---------- Initialization ---------- */
function initResultsPanel(opts = {}) {
  resultsBox = el(opts.resultsBoxId || 'results');
  chkOnlyVuln = el(opts.chkOnlyVulnId || 'chkOnlyVuln');
  statusEl = el(opts.statusId || 'status');
  svgContainer = el(opts.svgContainerId || 'diagramBox');
  svgSizeEl = el(opts.svgSizeId || 'svgSize');
  downloadSvgBtn = el(opts.downloadSvgBtnId || 'btnDownloadSVG');

  // bind checkbox to re-render current cache
  if (chkOnlyVuln) {
    chkOnlyVuln.addEventListener('change', () => {
      renderResults(getDisplayResults(), lastMeta);
    });
  }

  // wire export ODS (if exporter present)
  const exportBtn = el(opts.exportOdsBtnId || 'btnExportODS');
  if (exportBtn && typeof exportODS === 'function') {
    exportBtn.addEventListener('click', () => {
      // Use filtered display results if checkbox on, else use full
      const toExport = chkOnlyVuln && chkOnlyVuln.checked ? getDisplayResults() : lastResults;
      if (!toExport || !toExport.length) return alert('No paths to export.');
      exportODS(State, { results: toExport });
    });
  }
}

/* ---------- accessors for other modules / app -------- */
function getLastResults() { return lastResults.slice(); }
function getLastMeta() { return Object.assign({}, lastMeta); }

export {
  initResultsPanel,
  renderResults,
  computeAndRenderAll,
  renderDiagramForPath,
  getLastResults,
  getLastMeta
};

===== ./js/ui/editors.js =====
// js/ui/editors.js
// Editor UI module: target editor, attacker editor, details panel
// Imports expected from the modular structure:
//  - State (singleton) from ../state.js
//  - saveToLocal(state) from ../storage.js
//  - helpers: el, norm
//
// The module emits `document.dispatchEvent(new CustomEvent('state:changed'))`
// after any mutation so other UI modules can re-render.

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el, norm } from '../helpers.js';

function emitChange() {
  try { saveToLocal(State); } catch (e) { console.warn('save failed', e); }
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------- Target editor (vulns / final flag) ---------- */
export function renderTargetEditor(targetId) {
  const details = el('details');
  if (!details) return;

  const target = State.targets.find(t => t.id === targetId);
  if (!target) {
    details.innerHTML = `<div class="small">Select a target to edit its vulnerabilities and properties.</div>`;
    return;
  }

  // Build editor UI
  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  // Header: name + rename button
  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(target.name)}</strong>`;
  const headerRow = document.createElement('div');
  headerRow.className = 'row';
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename target', target.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    // check duplicates
    if (State.targets.some(t => t.name.toLowerCase() === n.toLowerCase() && t.id !== target.id)) return alert('Name already used');
    target.name = n;
    emitChange();
  };
  const finalLabel = document.createElement('label');
  finalLabel.className = 'small';
  finalLabel.style.display = 'inline-flex';
  finalLabel.style.alignItems = 'center';
  finalLabel.style.gap = '8px';
  const finalCb = document.createElement('input');
  finalCb.type = 'checkbox';
  finalCb.checked = !!target.final;
  finalCb.onchange = () => {
    target.final = finalCb.checked;
    emitChange();
  };
  finalLabel.append(finalCb, document.createTextNode(' Final flag'));
  headerRow.append(header, finalLabel, renameBtn);
  wrapper.appendChild(headerRow);

  // Vulnerabilities editor
  const vLabel = document.createElement('div');
  vLabel.className = 'small';
  vLabel.textContent = 'Vulnerabilities (check all that apply)';
  wrapper.appendChild(vLabel);

  const vulnBox = document.createElement('div');
  vulnBox.className = 'col';
  vulnBox.style.marginTop = '6px';

  // For each global vulnerability, show checkbox
  State.vulns.forEach(v => {
    const lab = document.createElement('label');
    lab.className = 'small';
    lab.style.display = 'flex';
    lab.style.alignItems = 'center';
    lab.style.gap = '8px';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    const currentVulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    cb.checked = currentVulns.has(v.id);
    cb.onchange = () => {
      target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
      if (cb.checked) target.vulns.add(v.id);
      else target.vulns.delete(v.id);
      emitChange();
    };
    const span = document.createElement('span');
    span.textContent = v.name;
    lab.append(cb, span);
    vulnBox.appendChild(lab);
  });

  // Add quick "add new vuln" line
  const addVRow = document.createElement('div');
  addVRow.className = 'row';
  addVRow.style.marginTop = '6px';
  const inputNewV = document.createElement('input');
  inputNewV.type = 'text';
  inputNewV.placeholder = 'New vulnerability name';
  inputNewV.style.flex = '1';
  const addVBtn = document.createElement('button');
  addVBtn.textContent = 'Add & attach';
  addVBtn.onclick = () => {
    const name = norm(inputNewV.value);
    if (!name) return alert('Name required');
    // avoid duplicate vulnerability names
    if (State.vulns.some(x => x.name.toLowerCase() === name.toLowerCase())) {
      // attach existing vuln if present
      const existing = State.vulns.find(x => x.name.toLowerCase() === name.toLowerCase());
      if (existing) {
        target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
        target.vulns.add(existing.id);
        inputNewV.value = '';
        emitChange();
        return;
      }
      return;
    }
    // create new vuln id and add globally
    const id = (Date.now().toString(36) + Math.random().toString(36).slice(2,6));
    State.vulns.push({ id, name });
    // attach to target
    target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    target.vulns.add(id);
    inputNewV.value = '';
    emitChange();
  };
  addVRow.append(inputNewV, addVBtn);

  wrapper.appendChild(vulnBox);
  wrapper.appendChild(addVRow);

  // Links quick view (read-only summary)
  const linksLabel = document.createElement('div');
  linksLabel.className = 'small';
  linksLabel.style.marginTop = '10px';
  linksLabel.textContent = 'Outgoing links (summary)';
  wrapper.appendChild(linksLabel);

  const linksSummary = document.createElement('div');
  linksSummary.className = 'small';
  linksSummary.style.marginTop = '6px';
  // summarise by type
  const outDirect = (State.edges.direct[target.id] || new Set());
  const outLat = (State.edges.lateral[target.id] || new Set());
  const outContains = (State.edges.contains[target.id] || new Set());
  linksSummary.innerHTML = `
    <div><strong>Direct:</strong> ${[...outDirect].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Lateral:</strong> ${[...outLat].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Contains:</strong> ${[...outContains].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
  `;
  wrapper.appendChild(linksSummary);

  // put everything in details
  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Attacker editor (entries multi-select) ---------- */
export function renderAttackerEditor(attackerId) {
  const details = el('details');
  if (!details) return;

  const attacker = State.attackers.find(a => a.id === attackerId);
  if (!attacker) {
    details.innerHTML = `<div class="small">Select an attacker to edit its entry points.</div>`;
    return;
  }

  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(attacker.name)}</strong>`;
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename attacker', attacker.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    if (State.attackers.some(x => x.name.toLowerCase() === n.toLowerCase() && x.id !== attacker.id)) return alert('Name already used');
    attacker.name = n;
    emitChange();
  };
  header.appendChild(renameBtn);
  wrapper.appendChild(header);

  // Entries multi-select
  const lbl = document.createElement('div');
  lbl.className = 'small';
  lbl.textContent = 'Entry points (select one or many from targets below)';
  wrapper.appendChild(lbl);

  const sel = document.createElement('select');
  sel.id = 'editorEntriesSelect';
  sel.multiple = true;
  sel.size = Math.min(10, Math.max(6, State.targets.length));
  sel.style.width = '100%';

  // Normalize attacker.entries to a Set before checking membership
  const entriesSet = attacker.entries instanceof Set ? attacker.entries : new Set(attacker.entries || []);

  State.targets.forEach(t => {
    const o = document.createElement('option');
    o.value = t.id;
    o.textContent = t.name;
    o.selected = entriesSet.has(t.id);
    sel.appendChild(o);
  });

  sel.onchange = () => {
    const picked = [...sel.selectedOptions].map(o => o.value);
    attacker.entries = new Set(picked);
    emitChange();
  };

  wrapper.appendChild(sel);

  // Quick helpers: select all / none
  const btnRow = document.createElement('div');
  btnRow.className = 'row';
  const btnAll = document.createElement('button');
  btnAll.textContent = 'Select all';
  btnAll.onclick = () => {
    for (const o of sel.options) { o.selected = true; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  const btnNone = document.createElement('button');
  btnNone.textContent = 'Select none';
  btnNone.className = 'ghost';
  btnNone.onclick = () => {
    for (const o of sel.options) { o.selected = false; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  btnRow.append(btnAll, btnNone);
  wrapper.appendChild(btnRow);

  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Helpers & init ---------- */
function escapeHtml(s) {
  return String(s||'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
}

/**
 * Re-render whichever details panel is relevant to the current selection.
 * If a target is selected, render the target editor; otherwise, if an attacker is
 * selected, render the attacker editor. If nothing is selected, clear the panel.
 */
export function hydrateDetailsPanel() {
  const details = el('details');
  if (!details) return;

  const selTarget = el('selectTarget') || el('linkSource');
  const selAttacker = el('selAttacker');

  if (selTarget && selTarget.value) {
    renderTargetEditor(selTarget.value);
    return;
  }
  if (selAttacker && selAttacker.value) {
    renderAttackerEditor(selAttacker.value);
    return;
  }
  details.innerHTML = `<div class="small">Select an attacker or target to edit.</div>`;
}

/**
 * initEditors
 * - wires main high-level editor controls: when selectAttacker changes, render attacker editor;
 *   when selectTarget changes, render target editor.
 * - listens to global `state:changed` to re-populate selects (targets / vulns) so editors remain live.
 */
export function initEditors() {
  // populate initial selects in the central UI if they exist
  const selAttacker = el('selAttacker');
  const selTarget = el('selectTarget') || el('linkSource'); // support both naming conventions
  // When attacker selection changes, present attacker editor
  if (selAttacker) {
    selAttacker.onchange = () => {
      renderAttackerEditor(selAttacker.value);
    };
  }

  // When target selection changes, present target editor
  if (selTarget) {
    selTarget.onchange = () => {
      renderTargetEditor(selTarget.value);
    };
  }

  // when global state changes, re-populate selects so editors remain in sync
  document.addEventListener('state:changed', () => {
    // re-fill attacker select
    if (selAttacker) {
      const cur = selAttacker.value;
      selAttacker.innerHTML = '';
      State.attackers.forEach(a => {
        const o = document.createElement('option');
        o.value = a.id; o.textContent = a.name;
        selAttacker.appendChild(o);
      });
      if (State.attackers.some(a=>a.id===cur)) selAttacker.value = cur;
    }
    // re-fill central target selects used by UI
    const selTargets = [ 'selectTarget', 'linkSource', 'linkDest', 'selEntriesAll', 'selectStartPool' ];
    selTargets.forEach(id => {
      const s = el(id);
      if (!s) return;
      const prev = s.value;
      const selectedValues = [...(s.selectedOptions || [])].map(o => o.value);
      s.innerHTML = '';
      State.targets.forEach(t => {
        const o = document.createElement('option'); o.value = t.id; o.textContent = t.name;
        // re-select previously selected items if still present
        if (selectedValues.includes(o.value)) o.selected = true;
        s.appendChild(o);
      });
      if (prev && [...s.options].some(o => o.value === prev)) s.value = prev;
    });

    // If there is a currently rendered details editor, re-render it to reflect vulnerabilities and flags
    hydrateDetailsPanel();
  });

  // initial population in case DOM is already ready
  document.dispatchEvent(new CustomEvent('state:changed'));
}

===== ./js/ui/lists.js =====
// js/ui/lists.js
// Utilities and renderers for side lists and central selectors.

import { State, deleteAttacker, deleteTarget, deleteVuln } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

import { hydrateDetailsPanel } from './editors.js';
import { renderLinksInspector as _renderLinksInspector } from './links.js';
import { renderResults } from './results.js';

/* ---------------------------------------------------------- */
/* Small DOM helpers                                           */
/* ---------------------------------------------------------- */
function createButton(label, onClick, ghost = false){
  const b = document.createElement('button');
  b.textContent = label;
  b.className = ghost ? 'ghost' : '';
  b.onclick = onClick;
  return b;
}

function badge(text){
  const d = document.createElement('div');
  d.className = 'badge';
  d.textContent = text;
  return d;
}

function mini(text){
  const d = document.createElement('div');
  d.className = 'mini';
  d.textContent = text;
  return d;
}

function emitStateChanged() {
  try { saveToLocal(State); } catch(e) {}
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------------------------------------------------------- */
/* setOptions : peuple un <select> et conserve la sélection    */
/* - Si `selected` est fourni (Set), il est prioritaire.       */
/* - Sinon on restaure la sélection précédente (multi/single). */
/* ---------------------------------------------------------- */
export function setOptions(
  selectEl,
  items,
  { getValue = x => x.id, getLabel = x => x.name, selected = null } = {}
){
  if(!selectEl) return;

  const wasMultiple = !!selectEl.multiple;

  // capture sélection courante
  const prevSelected = wasMultiple
    ? new Set([...selectEl.selectedOptions].map(o => String(o.value)))
    : new Set(selectEl.value ? [String(selectEl.value)] : []);

  const prevValue = selectEl.value;

  // rebuild
  selectEl.innerHTML = '';
  (items || []).forEach(item => {
    const val = String(getValue(item));
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = String(getLabel(item));

    // priorité: selected (fourni) > sélection précédente
    if (selected instanceof Set) {
      opt.selected = selected.has(val);
    } else if (prevSelected.has(val)) {
      opt.selected = true;
    }

    selectEl.appendChild(opt);
  });

  // pour les selects non-multiples, restaurer la value si possible
  if (!wasMultiple && prevValue && [...selectEl.options].some(o => o.value === prevValue)) {
    selectEl.value = prevValue;
  }
}

/* ---------------------------------------------------------- */
/* Side panel : ATTACKERS                                     */
/* ---------------------------------------------------------- */
export function renderAttackers(){
  const container = el('attackerList');
  if(!container) return;
  container.innerHTML = '';

  (State.attackers || []).forEach(a => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    const entries = a.entries instanceof Set ? a.entries : new Set(a.entries || []);
    left.appendChild(badge(a.name));
    left.appendChild(mini(`Entries: ${[...entries].map(id => {
      const t = (State.targets || []).find(x => x.id === id);
      return t ? t.name : '?';
    }).join(', ') || '—'}`));

    const right = document.createElement('div');

    // rename
    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename attacker', a.name);
      if(!name) return;
      a.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    // delete
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete attacker?')){
        deleteAttacker(a.id);
        emitStateChanged();
        renderAllLists();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : TARGETS                                       */
/* ---------------------------------------------------------- */
export function renderTargets(){
  const container = el('targetList');
  if(!container) return;
  container.innerHTML = '';

  (State.targets || []).forEach(t => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    left.appendChild(badge(t.name));

    const vulnsSet = t.vulns instanceof Set ? t.vulns : new Set(t.vulns || []);
    left.appendChild(mini(`Vulns: ${
      [...vulnsSet].map(id => (State.vulns || []).find(v => v.id === id)?.name || '?').join(', ') || '—'
    }`));

    const right = document.createElement('div');

    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename target', t.name);
      if(!name) return;
      t.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete target?')){
        deleteTarget(t.id);
        emitStateChanged();
        renderAllLists();
        renderLinksInspector();
        renderResults([]);
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : VULNERABILITIES                               */
/* ---------------------------------------------------------- */
export function renderVulns(){
  const container = el('vulnList');
  if(!container) return;
  container.innerHTML = '';

  (State.vulns || []).forEach(v => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';
    left.appendChild(badge(v.name));

    const right = document.createElement('div');
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete vulnerability?')){
        deleteVuln(v.id);
        emitStateChanged();
        renderAllLists();
        hydrateDetailsPanel();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Re-render lists globally                                   */
/* ---------------------------------------------------------- */
export function renderAllLists(){
  renderAttackers();
  renderTargets();
  renderVulns();
  hydrateDetailsPanel();
}

/* ---------------------------------------------------------- */
/* Populate ALL selectors (menus)                             */
/* ---------------------------------------------------------- */
export function populateSelectors(state = State){
  setOptions(el('selAttacker'), state.attackers || []);

  setOptions(el('selEntriesAll'), state.targets || []);
  setOptions(el('selExitsAll'),   state.targets || []);

  setOptions(el('linkSource'), state.targets || []);
  setOptions(el('linkDest'),   state.targets || []);

  hydrateEntriesSelect(state);
  hydrateExitsSelect(state);
  hydrateVulnSelectors(state);

  renderLinksInspector();
}

/* ---------------------------------------------------------- */
/* Hydrate Entries (multi)                                    */
/* ---------------------------------------------------------- */
export function hydrateEntriesSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selEntriesAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.entries ? [...att.entries].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Exits (multi)                                      */
/* ---------------------------------------------------------- */
export function hydrateExitsSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selExitsAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.exits ? [...att.exits].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Vulns (multi, persist visuellement)                */
/* ---------------------------------------------------------- */
export function hydrateVulnSelectors(state = State){
  const selT = el('selVulnElement');
  const selV = el('selVulnsForElement');
  if(!selT || !selV) return;

  // (1) cibles
  setOptions(selT, state.targets || []);

  // (2) vulns de la cible courante
  const t = (state.targets || []).find(x => String(x.id) === String(selT.value));
  const current = t ? (t.vulns instanceof Set ? t.vulns : new Set(t.vulns || [])) : new Set();
  const selected = new Set([...current].map(String));

  setOptions(selV, state.vulns || [], { selected });
}

/* ---------------------------------------------------------- */
/* Re-export                                                  */
/* ---------------------------------------------------------- */
export const renderLinksInspector = _renderLinksInspector;

===== ./js/simulation/scenarios.js =====
/* =========================================================
   simulation/scenarios.js
   Scénarios "humains" : chaque lien est créé via un vrai clic
   sur le bouton Add Link, puis la sélection est nettoyée pour
   éviter les boucles infinies.
   ========================================================= */

import { registerScenario, g } from './index.js';

/* ---------------------------------------------------------
   Helpers: commit *comme un humain*
   --------------------------------------------------------- */

// Compte les arêtes pour détecter "rien n'a changé"
function __edgeCount(state) {
  const E = state?.edges || { direct:{}, lateral:{}, contains:{} };
  const sum = (m) => Object.values(E[m] || {}).reduce((n, s) => n + (s?.size || 0), 0);
  return { d: sum('direct'), l: sum('lateral'), c: sum('contains') };
}

/** Clique le vrai bouton "Add link" si présent, sinon fallback "change". Puis CLEAR la sélection. */
async function clickAddLinkButton() {
  const tryIds = ['btnAddLink','addLink','linkAdd','btnLinkAdd','btn-add-link','action-add-link'];
  let btn = null;
  for (const id of tryIds) { const n = g.el(id); if (n) { btn = n; break; } }

  // snapshot avant
  const S = window.__envuln_boot?.State || window.State;
  const before = __edgeCount(S);

  if (btn) {
    await g.click(btn);
  } else {
    // fallback: déclenchement par change pour UIs sans bouton
    const sel = g.el('linkDest');
    if (sel) sel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // laisser le temps aux handlers d'ajouter les liens
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  await g.wait(40);

  // CLEAR la sélection pour éviter les re-commits infinis
  const destSel = g.el('linkDest');
  if (destSel) {
    [...destSel.options].forEach(o => o.selected = false);
    destSel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // garde-fou : si rien n'a changé, on n'insiste pas
  const after = __edgeCount(S);
  const delta = (after.d - before.d) + (after.l - before.l) + (after.c - before.c);
  if (delta <= 0) {
    await g.wait(80);
  }
}

/** S'assure du type de lien (direct/lateral/contains) si le select existe. */
async function ensureLinkType(type = 'direct') {
  const selType = g.el('linkType');
  if (!selType) return;
  if (String(selType.value).toLowerCase() === String(type).toLowerCase()) return;
  await g.click(selType);
  await g.wait(40);
  await g.selectByText(selType, type);
  await g.wait(60);
}

/** Commit "humain" : source → type → destinations → Add → CLEAR selection. */
async function humanCommitLinks(fromLabel, toLabels = [], type = 'direct') {
  // source
  await g.selectByText(g.el('linkSource'), fromLabel);
  await g.wait(60);

  // type
  await ensureLinkType(type);

  // destinations
  const destSel = g.el('linkDest');
  if (!destSel) return;
  await g.click(destSel);
  await g.wait(40);
  g.multiSelectByTexts(destSel, toLabels);
  await g.wait(40);

  // commit via bouton (avec clear + vérif delta)
  await clickAddLinkButton();
}

/** Commit de la sélection de vulnérabilités (multi-select change). */
function commitVulnSelection() {
  const sel = g.el('selVulnsForElement');
  if (!sel) return;
  sel.dispatchEvent(new Event('change', { bubbles: true }));
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* Ajouts via la vraie UI */
async function ensureVuln(name) {
  const inp = g.el('vulnName');
  if (!inp) return;
  await g.typeInto(inp, name);
  await g.click(g.el('btnAddVuln'));
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

async function addTarget(label) {
  await g.typeInto(g.el('targetName'), label);
  await g.click(g.el('btnAddTarget'));
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Scénarios (créent explicitement les liens nécessaires)
   --------------------------------------------------------- */

/* 1) Minimal web app chain — Internet LB -> Web Server -> App Server -> Database */
async function scenario_small_webapp() {
  await g.typeInto(g.el('attackerName'), 'Threat Actor — WebApp');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(240);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = ['Internet LB', 'Web Server', 'App Server', 'Database'];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Auth RCE');

  await g.selectByText(g.el('selAttacker'), 'Threat Actor — WebApp');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Database']);
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens
  await humanCommitLinks('Internet LB', ['Web Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('Web Server', ['App Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('App Server', ['Database'], 'direct');
  await g.wait(120);

  // Vuln
  await g.selectByText(g.el('selVulnElement'), 'Web Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth RCE']);
  commitVulnSelection();
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(420);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 2) Corporate network — plusieurs chemins + lien latéral depuis Mail */
async function scenario_corporate_network() {
  await g.typeInto(g.el('attackerName'), 'APT — Corporate');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = [
    'Internet Gateway', 'Perimeter FW', 'Proxy', 'Mail Server',
    'VPN Gateway', 'Edge VM', 'Internal App', 'DB Cluster', 'Secrets Store'
  ];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Open Port');
  await ensureVuln('Phishing OTP');
  await ensureVuln('Priv Esc');

  await g.selectByText(g.el('selAttacker'), 'APT — Corporate');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet Gateway', 'Mail Server']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Secrets Store']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Topologie
  await humanCommitLinks('Internet Gateway', ['Perimeter FW', 'Mail Server'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Perimeter FW', ['Proxy', 'VPN Gateway'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Proxy', ['Edge VM', 'Internal App'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Edge VM', ['Internal App'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Internal App', ['DB Cluster'], 'direct');
  await g.wait(80);
  await humanCommitLinks('DB Cluster', ['Secrets Store'], 'direct');
  await g.wait(100);

  // Lateral : Mail -> Edge VM
  await humanCommitLinks('Mail Server', ['Edge VM'], 'lateral');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Mail Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Phishing OTP']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Edge VM');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Open Port']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Internal App');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Priv Esc']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(700);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 3) Cloud containers — direct + contains + chemin vers Backup */
async function scenario_cloud_containers() {
  await g.typeInto(g.el('attackerName'), 'Cloud Operator Bug');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const hosts = ['LB', 'Web Pod', 'App Pod', 'Cache Pod', 'DB Pod', 'Backup Pod'];
  for (const h of hosts) await addTarget(h);

  await ensureVuln('Container Escape');
  await ensureVuln('Unpatched Service');

  await g.selectByText(g.el('selAttacker'), 'Cloud Operator Bug');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Backup Pod']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Flots directs
  await humanCommitLinks('LB', ['Web Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('Web Pod', ['App Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('App Pod', ['DB Pod', 'Cache Pod'], 'direct');
  await g.wait(90);

  // Chemin vers exit
  await humanCommitLinks('DB Pod', ['Backup Pod'], 'direct');
  await g.wait(90);

  // Contains (sémantique)
  await humanCommitLinks('App Pod', ['Cache Pod'], 'contains');
  await g.wait(120);

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Web Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Unpatched Service']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'App Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Container Escape']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(650);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 4) IoT/OT dense — Sensors -> Aggregator -> Edge -> Admin -> PLC */
async function scenario_iot_ot_dense() {
  await g.typeInto(g.el('attackerName'), 'Script Kiddie — IoT Wave');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const devices = [];
  for (let i = 1; i <= 10; i++) {
    const name = `Sensor-${i}`;
    devices.push(name);
    await addTarget(name);
  }
  const core = ['Aggregator', 'Edge Controller', 'Admin Console', 'Historian', 'PLC'];
  for (const c of core) await addTarget(c);

  await ensureVuln('Default Creds');
  await ensureVuln('Telnet Open');
  await ensureVuln('Weak Auth');

  await g.selectByText(g.el('selAttacker'), 'Script Kiddie — IoT Wave');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), devices.slice(0, 6));
  g.multiSelectByTexts(g.el('selExitsAll'), ['PLC']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens Sensors -> Aggregator / Edge / Admin
  await humanCommitLinks('Sensor-1', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-2', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-3', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-4', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-5', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-6', ['Aggregator', 'Admin Console'], 'direct');
  await g.wait(80);

  await humanCommitLinks('Aggregator', ['Edge Controller'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Edge Controller', ['Admin Console'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Admin Console', ['PLC', 'Historian'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Historian', ['PLC'], 'direct');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Sensor-2');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Sensor-4');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Edge Controller');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Telnet Open']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Admin Console');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Weak Auth']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(900);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 5) High-connectivity mesh — DAG dense A..G */
async function scenario_high_connectivity_mesh() {
  await g.typeInto(g.el('attackerName'), 'Black Hat — Mesh Experiment');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  for (const n of nodes) await addTarget(`Node ${n}`);

  await ensureVuln('Service X RCE');
  await ensureVuln('Auth Bypass');

  await g.selectByText(g.el('selAttacker'), 'Black Hat — Mesh Experiment');
  await g.wait(100);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Node A']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Node G']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // DAG dense: A -> B..G, B -> C..G, etc.
  for (let i = 0; i < nodes.length; i++) {
    const from = `Node ${nodes[i]}`;
    const toList = [];
    for (let j = i + 1; j < nodes.length; j++) toList.push(`Node ${nodes[j]}`);
    if (toList.length) {
      await humanCommitLinks(from, toList, 'direct');
      await g.wait(60);
    }
  }
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Node B');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Service X RCE']);
  commitVulnSelection();
  await g.wait(50);

  await g.selectByText(g.el('selVulnElement'), 'Node D');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth Bypass']);
  commitVulnSelection();
  await g.wait(70);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(1000);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Catalogue & enregistrement (un scénario aléatoire)
   --------------------------------------------------------- */

const CATALOG = [
  { name: 'Small webapp chain', fn: scenario_small_webapp },
  { name: 'Corporate network', fn: scenario_corporate_network },
  { name: 'Cloud containers', fn: scenario_cloud_containers },
  { name: 'IoT / OT dense', fn: scenario_iot_ot_dense },
  { name: 'High-connectivity mesh', fn: scenario_high_connectivity_mesh }
];

registerScenario('Random: pick one realistic scenario', async () => {
  const i = Math.floor(Math.random() * CATALOG.length);
  const picked = CATALOG[i];
  try {
    const txt = `Running scenario: ${picked.name}`;
    const statusEl = g.el('status');
    if (statusEl) statusEl.textContent = txt;
    await picked.fn();
  } finally {
    try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  }
});

===== ./js/simulation/index.js =====
/* =========================================================
   simulation/index.js
   UI-driven simulation with a virtual cursor (mouse gestures)
   Controller supports play / pause / stop / restart /step,
   speed control, and cursor timeline stepping.
   ========================================================= */

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';

const SCENARIOS = [];

/* ---------------- Registry ---------------- */
export function registerScenario(name, fn, weight = 1) {
  SCENARIOS.push({ name, fn, weight: Math.max(0, +weight || 1) });
}

/* ---------------- Global controller state ---------------- */
const CTRL = {
  paused: false,
  stopRequested: false,
  running: false,
  stepArmed: false,   // single-step gate for "step forward"
  speed: 1.0          // 0.2..3.0
};

/* ---------------- Abort helper ---------------- */
function shouldAbort() { return CTRL.stopRequested === true; }

/* ---------------- State snapshot / restore (sandbox) ---------------- */
let _snapshot = null;

function takeSnapshot() {
  try {
    // structuredClone preserves Sets/Maps/Date; good for our State shape.
    _snapshot = structuredClone(State);
  } catch {
    // last resort: shallow rebuild (Sets will still be Sets because current State uses Sets)
    _snapshot = JSON.parse(JSON.stringify({
      version: State.version,
      attackers: State.attackers.map(a => ({
        id: a.id, name: a.name,
        entries: [...a.entries],
        exits:   [...a.exits]
      })),
      targets: State.targets.map(t => ({
        id: t.id, name: t.name,
        vulns: [...t.vulns],
        final: !!t.final
      })),
      edges: {
        direct:   Object.fromEntries(Object.entries(State.edges.direct   || {}).map(([k,v]) => [k, [...v]])),
        lateral:  Object.fromEntries(Object.entries(State.edges.lateral  || {}).map(([k,v]) => [k, [...v]])),
        contains: Object.fromEntries(Object.entries(State.edges.contains || {}).map(([k,v]) => [k, [...v]])),
      }
    }));
    // Rehydrate Sets
    _snapshot.targets.forEach(t => t.vulns = new Set(t.vulns || []));
    _snapshot.attackers.forEach(a => {
      a.entries = new Set(a.entries || []);
      a.exits   = new Set(a.exits   || []);
    });
    for (const m of ['direct','lateral','contains']) {
      for (const k in _snapshot.edges[m]) {
        _snapshot.edges[m][k] = new Set(_snapshot.edges[m][k] || []);
      }
    }
  }
}

function restoreSnapshot() {
  if (!_snapshot) return;

  // Replace State fields in-place (keep same object reference)
  State.version   = _snapshot.version;
  State.attackers = _snapshot.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: new Set(a.entries),
    exits:   new Set(a.exits)
  }));
  State.targets   = _snapshot.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: new Set(t.vulns),
    final: !!t.final
  }));
  State.edges = { direct:{}, lateral:{}, contains:{} };
  for (const m of ['direct','lateral','contains']) {
    for (const k in _snapshot.edges[m]) {
      State.edges[m][k] = new Set(_snapshot.edges[m][k]);
    }
  }

  try { saveToLocal(State); } catch {}
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------- Cursor timeline (for step back/forward) ---------------- */
const TIMELINE = { points: [], idx: -1 };

function timelineClear() { TIMELINE.points.length = 0; TIMELINE.idx = -1; safeUpdateButtons(); }

// last known cursor position (px)
let __lastCursorPos = { x: null, y: null };

// clamp helper
function _clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

// record timeline but ignore invalid/meaningless points and duplicates
function timelineRecord(x, y) {
  // sanitize
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
  // clamp to viewport + small margin
  const margin = 8;
  const px = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth) - margin));
  const py = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  // ignore duplicate consecutive points
  const last = TIMELINE.points.length ? TIMELINE.points[TIMELINE.points.length - 1] : null;
  if (last && last.x === px && last.y === py) {
    TIMELINE.idx = TIMELINE.points.length - 1;
    return;
  }

  const t = performance.now();
  TIMELINE.points.push({ x: px, y: py, t });
  TIMELINE.idx = TIMELINE.points.length - 1;

  // update last known cursor pos
  __lastCursorPos.x = px;
  __lastCursorPos.y = py;

  safeUpdateButtons();
}

function timelineGoto(index) {
  const i = Math.max(0, Math.min(TIMELINE.points.length - 1, index));
  const p = TIMELINE.points[i];
  if (!p) return;
  const c = document.getElementById(CURSOR_ID) || ensureCursor();
  c.style.left = `${p.x}px`;
  c.style.top  = `${p.y}px`;
  TIMELINE.idx = i;
  safeUpdateButtons();
}

/* ---------------- Speed helpers ---------------- */
function readSpeedFromUI() {
  const el = document.getElementById('simSpeed');
  const v = el ? parseFloat(el.value) : 1;
  CTRL.speed = Math.max(0.2, Math.min(3, Number.isFinite(v) ? v : 1));
  const lab = document.getElementById('simSpeedValue');
  if (lab) lab.textContent = `×${CTRL.speed.toFixed(1)}`;
}
readSpeedFromUI();

/* ---------------- Public controls ---------------- */
export function simSetSpeed(mult) { CTRL.speed = Math.max(0.2, Math.min(3, +mult || 1)); }
export function simPlay() { CTRL.paused = false; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simPause(){ CTRL.paused = true;  CTRL.stepArmed = false; safeUpdateButtons(); }
export function simToggle(){ CTRL.paused = !CTRL.paused; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simStop() {
  CTRL.stopRequested = true;
  CTRL.paused = false;     // allow sleepers to exit
  CTRL.stepArmed = false;
  simCleanupUI();          // UI artifacts
}

/* one-step while paused */
export function simStep() { CTRL.stepArmed = true; }

/* step back/forward on cursor timeline (no state mutation) */
export function simStepBack(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.max(0, TIMELINE.idx - Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simStepForward(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.min(TIMELINE.points.length - 1, TIMELINE.idx + Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simCanStepBack()    { return TIMELINE.idx > 0; }
export function simCanStepForward() { return TIMELINE.idx >= 0 && TIMELINE.idx < (TIMELINE.points.length - 1); }

/* ---------------- DOM helpers ---------------- */
const $ = (id) => document.getElementById(id);
export function disableTopButtons(disabled = true) {
  ['btnSimu', 'btnFindPaths', 'btnExportODS', 'btnImportJSON', 'btnExportJSON'].forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !!disabled;
  });
}
export function enableTopButtons() { disableTopButtons(false); }
function safeUpdateButtons() { try { window.__updatePlaybackButtons && window.__updatePlaybackButtons(); } catch {} }

/* Sleep that honors pause/step/stop and speed */
function sleep(ms) {
  const base = Math.max(0, +ms || 0);
  const scaled = Math.max(10, Math.floor(base / Math.max(0.2, CTRL.speed)));
  return new Promise((resolve) => {
    const start = performance.now();
    function loop() {
      if (CTRL.stopRequested) return resolve();
      if (CTRL.paused && !CTRL.stepArmed) return setTimeout(loop, 40);
      if (CTRL.stepArmed) CTRL.stepArmed = false;
      const elapsed = performance.now() - start;
      if (elapsed >= scaled) return resolve();
      setTimeout(loop, 16);
    }
    loop();
  });
}

/* ---------------- Cursor rendering ---------------- */
const CURSOR_ID = '__sim_cursor';
function ensureCursor() {
  let c = document.getElementById(CURSOR_ID);
  if (c) return c;
  c = document.createElement('div');
  c.id = CURSOR_ID;
  Object.assign(c.style, {
    position: 'fixed',
    zIndex: 999999,
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    background: 'rgba(59,130,246,.9)',
    boxShadow: '0 0 0 6px rgba(59,130,246,.18)',
    pointerEvents: 'none',
    transform: 'translate(-50%, -50%)',
    transition: 'transform 80ms linear, left 120ms linear, top 120ms linear'
  });
  // put it at center by default
  const cx = Math.round(window.innerWidth / 2);
  const cy = Math.round(window.innerHeight / 2);
  c.style.left = `${cx}px`;
  c.style.top  = `${cy}px`;
  __lastCursorPos.x = cx;
  __lastCursorPos.y = cy;
  document.body.appendChild(c);
  return c;
}

function removeCursor() {
  const c = document.getElementById(CURSOR_ID);
  if (c) c.remove();
}

/* --------- FAST-ABORT GUARDS inside helpers (critical!) --------- */
async function moveToPoint(x, y, msPer100px = 120) {
  if (shouldAbort()) return;
  const cur = ensureCursor();

  // compute starting pos - prefer last known, else DOM rect
  let fromX = __lastCursorPos.x;
  let fromY = __lastCursorPos.y;
  if (!Number.isFinite(fromX) || !Number.isFinite(fromY)) {
    try {
      const r0 = cur.getBoundingClientRect();
      fromX = (Number.isFinite(r0.left) ? r0.left + 6 : window.innerWidth/2);
      fromY = (Number.isFinite(r0.top)  ? r0.top  + 6 : window.innerHeight/2);
    } catch {
      fromX = Math.round(window.innerWidth / 2);
      fromY = Math.round(window.innerHeight / 2);
    }
  }

  // sanitize target coords and clamp to viewport
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
  const margin = 8;
  const targetX = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth) - margin));
  const targetY = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  const dx = targetX - fromX, dy = targetY - fromY;
  const dist = Math.hypot(dx, dy) || 1;

  // If teleport distance is absurdly large (e.g. > viewport diag * 0.9), prefer linear interpolation via an intermediate point
  const viewportDiag = Math.hypot(window.innerWidth, window.innerHeight);
  const MAX_SAFE_JUMP = viewportDiag * 0.9;
  if (dist > MAX_SAFE_JUMP) {
    // first move to center-ish to avoid teleport bounce, then continue
    const midX = Math.round(window.innerWidth / 2);
    const midY = Math.round(window.innerHeight / 2);
    await moveToPoint(midX, midY, msPer100px); // recursive but will use last known pos now
    // continue to final
  }

  const steps = Math.max(10, Math.floor(dist / 10));
  const dur = Math.max(80, Math.floor((dist / 100) * msPer100px) / Math.max(0.2, CTRL.speed));
  const dt = dur / steps;

  for (let i = 1; i <= steps; i++) {
    if (shouldAbort()) return;
    while (CTRL.paused && !CTRL.stepArmed && !CTRL.stopRequested) { await sleep(40); }
    if (CTRL.stepArmed) CTRL.stepArmed = false;

    const t = i / steps;
    const nx = Math.round(fromX + dx * t);
    const ny = Math.round(fromY + dy * t);

    // set style (px)
    cur.style.left = `${nx}px`;
    cur.style.top  = `${ny}px`;

    // record stable, clamped positions
    timelineRecord(nx, ny);
    await sleep(dt);
  }

  // ensure final set exactly target
  cur.style.left = `${targetX}px`;
  cur.style.top  = `${targetY}px`;
  timelineRecord(targetX, targetY);
}

async function moveToEl(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  try {
    // Prefer instant scroll to stabilize getBoundingClientRect
    try { node.scrollIntoView({ block: 'center', behavior: 'auto' }); } catch { try { node.scrollIntoView(); } catch {} }
  } catch {}
  // small delay to allow layout to settle
  await sleep(80);

  if (shouldAbort()) return;
  let r;
  try { r = node.getBoundingClientRect(); } catch { r = null; }
  if (!r || !Number.isFinite(r.left) || !Number.isFinite(r.top)) {
    // fallback to center of viewport
    const px = Math.round(window.innerWidth / 2);
    const py = Math.round(window.innerHeight / 2);
    await moveToPoint(px, py);
    return;
  }
  await moveToPoint(r.left + Math.min(r.width - 2, offX), r.top + Math.min(r.height - 2, offY));
}

function fireMouse(node) {
  if (!node || shouldAbort()) return;
  const r = node.getBoundingClientRect();
  const centerX = r.left + r.width / 2;
  const centerY = r.top + r.height / 2;
  for (const type of ['mousedown', 'mouseup', 'click']) {
    if (shouldAbort()) return;
    node.dispatchEvent(new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: centerX, clientY: centerY, button: 0
    }));
  }
}

async function click(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  await moveToEl(node, offX, offY);
  if (shouldAbort()) return;
  fireMouse(node);
  await sleep(80);
}

async function typeInto(input, text, perCharMs = 28) {
  if (shouldAbort() || !input) return;
  await click(input);
  if (shouldAbort()) return;
  input.focus();
  input.value = '';
  input.dispatchEvent(new Event('input', { bubbles: true }));
  for (const ch of String(text)) {
    if (shouldAbort()) return;
    input.value += ch;
    input.dispatchEvent(new Event('input', { bubbles: true }));
    await sleep(perCharMs);
  }
}

async function selectByText(selectEl, text) {
  if (shouldAbort() || !selectEl) return;
  const target = String(text).toLowerCase();
  const options = [...selectEl.options];
  for (const opt of options) {
    if (shouldAbort()) return;
    if (opt.textContent.toLowerCase() === target) {
      await click(selectEl);
      if (shouldAbort()) return;
      await sleep(120);
      opt.selected = true;
      opt.scrollIntoView({ block: 'center', behavior: 'auto' });
      await click(opt);
      if (shouldAbort()) return;
      selectByBrowser(selectEl); // change event for UI handlers
      await sleep(120);
      return;
    }
  }
}

function selectByBrowser(selectEl) {
  if (shouldAbort() || !selectEl) return;
  selectEl.dispatchEvent(new Event('change', { bubbles: true }));
}

function multiSelectByTexts(selectEl, labels = []) {
  if (shouldAbort() || !selectEl) return;
  const wanted = new Set(labels.map(x => String(x).toLowerCase()));
  for (const opt of selectEl.options) {
    if (shouldAbort()) return;
    opt.selected = wanted.has(opt.textContent.toLowerCase());
  }
  selectByBrowser(selectEl);
}

/* ---------------- Simulation artifacts cleanup (UI only) ---------------- */
const SIM_TRACES = { nodes: new Set(), classAdds: [] };

export function simMarkEl(node) {
  if (!node) return null;
  try { node.setAttribute('data-sim', ''); } catch {}
  SIM_TRACES.nodes.add(node);
  return node;
}
export function simAddTempClass(node, className) {
  if (!node || !className) return;
  try {
    node.classList.add(className);
    SIM_TRACES.classAdds.push([node, className]);
  } catch {}
}

export function simCleanupUI() {
  // 1) remove cursor
  removeCursor();
  // 2) remove elements tagged as simulation artifacts
  try { document.querySelectorAll('[data-sim]').forEach(n => n.remove()); } catch {}
  // 3) remove temp classes
  SIM_TRACES.classAdds.forEach(([n, cls]) => { try { n.classList.remove(cls); } catch {} });
  SIM_TRACES.classAdds.length = 0;
  // 4) timeline reset
  timelineClear();
  safeUpdateButtons();
}

/* ---------------- Public gesture API used by scenarios ---------------- */
export const g = {
  el: (id) => document.getElementById(id),
  wait: sleep,
  moveToEl,
  click,
  typeInto,
  selectByText,
  multiSelectByTexts,
  // tagging helpers for cleanup
  markEl: simMarkEl,
  addClassTemp: simAddTempClass,
  // keep toolbar toggling consistent
  disableTopButtons: (disabled = true) => disableTopButtons(disabled),
  ensureInView: (node, block = 'center') => {
    try { node?.scrollIntoView({ block, behavior: 'auto' }); } catch {}
  }
};

/* =========================================================
   Scenario runner
   ========================================================= */

async function runScenarioObject(sc) {
  try {
    await sc.fn(g);
  } catch (e) {
    if (!CTRL.stopRequested) console.error(e);
  }
}

export async function runSimulation(opts = {}) {
  if (CTRL.running) return;     // avoid concurrent runs
  CTRL.stopRequested = false;
  CTRL.paused = false;
  CTRL.stepArmed = false;
  readSpeedFromUI();

  // Take a state snapshot so STOP can fully roll back.
  takeSnapshot();

  // Fresh cursor/timeline/UI artifacts
  simCleanupUI();

  disableTopButtons(true);
  CTRL.running = true;

  for (const sc of SCENARIOS) {
    if (shouldAbort()) break;
    await runScenarioObject(sc);
    if (shouldAbort()) break;
    await sleep(300);
  }

  CTRL.running = false;
  disableTopButtons(false);

  // If aborted, restore snapshot so *nothing* from the scenario sticks.
  if (shouldAbort()) {
    restoreSnapshot();
  }

  // Always clean UI artifacts
  simCleanupUI();

  // Render after finishing/aborting
  if (typeof opts.renderCallback === 'function') {
    try { opts.renderCallback(); } catch {}
  }
}

/* ---------------- State queries for UI ---------------- */
export function simIsRunning() { return CTRL.running; }
export function simIsPaused()  { return CTRL.paused; }
export function simHasStopRequest() { return CTRL.stopRequested; }

/* ---------------- Default export ---------------- */
export default {
  registerScenario,
  runSimulation,
  simPlay, simPause, simToggle, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simCanStepBack, simCanStepForward,
  simIsRunning, simIsPaused, simHasStopRequest,
  simCleanupUI, simMarkEl, simAddTempClass,
  g,
  SCENARIOS
};

===== ./js/paths.js =====
// js/paths.js
// Graph path enumeration for ENVULN

/**
 * Build a map id -> target object for quick lookups.
 */
function targetMap(state) {
  const m = Object.create(null);
  (state.targets || []).forEach(t => { m[t.id] = t; });
  return m;
}

export function nameOfTarget(state, id) {
  return (state.targets || []).find(t => t.id === id)?.name || String(id || '');
}

function outsFrom(map, id) {
  if (!map) return [];
  const s = map[id];
  if (!s) return [];
  return Array.isArray(s) ? s.slice() : Array.from(s);
}

/**
 * Return unique outgoing neighbors from a node, honoring the includeLateral / includeContains flags.
 */
export function adjacency(state, id, opts = { includeLateral: true, includeContains: true }) {
  const out = new Set();
  const e = state.edges || {};
  outsFrom(e.direct, id).forEach(x => out.add(x));
  if (opts.includeLateral) outsFrom(e.lateral, id).forEach(x => out.add(x));
  if (opts.includeContains) outsFrom(e.contains, id).forEach(x => out.add(x));
  return Array.from(out);
}

/**
 * Fast cycle check (DFS colors) honoring adjacency options.
 */
export function isDAG(state, opts = { includeLateral: true, includeContains: true }) {
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = Object.create(null);
  for (const t of (state.targets || [])) color[t.id] = WHITE;
  let hasCycle = false;

  function dfs(u) {
    color[u] = GRAY;
    const nexts = adjacency(state, u, opts);
    for (const v of nexts) {
      if (color[v] === GRAY) { hasCycle = true; return; }
      if (color[v] === WHITE) dfs(v);
      if (hasCycle) return;
    }
    color[u] = BLACK;
  }

  for (const t of (state.targets || [])) {
    if (color[t.id] === WHITE) dfs(t.id);
    if (hasCycle) break;
  }
  return !hasCycle;
}

/* -------- DAG enumeration (memoized). Do NOT stop on exits here. -------- */
function enumeratePaths_DAG_from(state, startId, memo, opts /* stopSet unused */) {
  if (memo.has(startId)) return memo.get(startId);

  const results = [];
  const nexts = adjacency(state, startId, opts);
  const t = (state.targets || []).find(x => x.id === startId);
  const isFinal = !!(t && t.final);

  // Stop only on: no outgoing edges OR explicit final node.
  if (nexts.length === 0 || isFinal) {
    results.push([startId]);
  } else {
    for (const v of nexts) {
      const subs = enumeratePaths_DAG_from(state, v, memo, opts);
      for (const sub of subs) {
        results.push([startId, ...sub]);
      }
    }
  }

  memo.set(startId, results);
  return results;
}

export function enumeratePaths_DAG(state, starts, opts, stopSet /* kept for API parity */) {
  const memo = new Map();
  let all = [];
  for (const s of starts) {
    const sub = enumeratePaths_DAG_from(state, s, memo, opts, stopSet);
    all = all.concat(sub);
  }
  return all;
}

/* -------- General graph (cycles allowed). Do NOT stop on exits here. -------- */
export function enumeratePaths_General(state, starts, opts, stopSet /* used later */, maxPaths = 5000) {
  const paths = [];
  let cycles = false;

  const adj = (id) => adjacency(state, id, opts);

  function dfs(u, visited, stack) {
    if (paths.length >= maxPaths) return;

    const t = (state.targets || []).find(x => x.id === u);
    const isFinal = !!(t && t.final);
    const nexts = adj(u);

    // If node is explicit final, record the path and stop.
    if (isFinal) {
      paths.push([...stack, u]);
      return;
    }

    // Split neighbors by visited status to keep paths simple.
    const unvisited = [];
    for (const v of nexts) {
      if (visited.has(v)) { cycles = true; continue; }
      unvisited.push(v);
    }

    // If there are no unvisited neighbors, this is a maximal simple path → record it.
    if (unvisited.length === 0) {
      paths.push([...stack, u]);
      return;
    }

    // Otherwise, continue DFS on each unvisited neighbor.
    visited.add(u);
    for (const v of unvisited) {
      if (paths.length >= maxPaths) break;
      dfs(v, visited, [...stack, u]);
    }
    visited.delete(u);
  }

  for (const s of starts) {
    dfs(s, new Set(), []);
    if (paths.length >= maxPaths) break;
  }

  return { paths, cycles };
}

/**
 * Compute all simple paths for a single attacker.
 * - Traversal does NOT stop on exits; exits are used only as an end-filter.
 * - Honors lateral/contains inclusion flags.
 * - Applies a per-attacker path ceiling in cyclic graphs.
 */
export function computePathsForAttacker(
  state,
  attackerId,
  opts = { includeLateral: true, includeContains: true },
  maxPaths = 5000
) {
  const attacker = (state.attackers || []).find(a => a.id === attackerId);
  if (!attacker) return { paths: [], cycles: false, truncated: false };

  const starts = Array.from(attacker.entries || []).map(String);
  if (starts.length === 0) return { paths: [], cycles: false, truncated: false };

  // Exits selected in the UI are treated as allowed END nodes (filtering step only).
  const exits = new Set(Array.from(attacker.exits || []).map(String));

  const dag = isDAG(state, opts);

  let nodePaths = [];
  let cycles = false;

  if (dag) {
    nodePaths = enumeratePaths_DAG(state, starts, opts, exits);
  } else {
    const out = enumeratePaths_General(state, starts, opts, exits, maxPaths);
    nodePaths = out.paths;
    cycles = out.cycles;
  }

  // Keep only those that end on an exit if exits were provided.
  if (exits.size > 0) {
    nodePaths = nodePaths.filter(path => exits.has(String(path[path.length - 1])));
  }

  const targetsById = targetMap(state);
  const normalized = nodePaths.map(nodes => ({
    attackerId: attacker.id,
    attackerName: attacker.name,
    nodes: nodes.map(id => targetsById[id]).filter(Boolean),
    vulnsPerNode: nodes.map(id => {
      const t = targetsById[id];
      if (!t) return [];
      const list = Array.isArray(t.vulns) ? t.vulns : Array.from(t.vulns || []);
      return list
        .map(vId => (state.vulns || []).find(x => x.id === vId)?.name || vId)
        .filter(Boolean);
    })
  }));

  const truncated = (!dag && nodePaths.length >= maxPaths);
  return { paths: normalized, cycles, truncated };
}

/**
 * Compute paths for all attackers, concatenated.
 */
export function computeAllPaths(
  state,
  opts = { includeLateral: true, includeContains: true },
  maxPathsPerAttacker = 5000
) {
  const all = [];
  let anyCycles = false;
  let anyTruncated = false;

  for (const a of (state.attackers || [])) {
    const out = computePathsForAttacker(state, a.id, opts, maxPathsPerAttacker);
    all.push(...out.paths);
    if (out.cycles) anyCycles = true;
    if (out.truncated) anyTruncated = true;
  }

  return { paths: all, cycles: anyCycles, truncated: anyTruncated };
}


===== ./js/diagram.js =====
// /js/diagram.js
// ES module that builds and renders the attack path SVG diagrams.

export function buildSVGForPath(pathObj, state, options = {}) {
  // ---- options with sane defaults ----
  const {
    padX = 20,
    padY = 22,
    boxW = 220,
    boxH = 70,
    gap = 60,
    corner = 10,
    fontFamily = 'Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial',
    showVulns = true,
    vulnLineHeight = 14,
    maxTitleChars = 28,
    maxSubtitleChars = 34,
    maxVulnChars = 60,
    colors = {
      bg: '#0b1224',
      title: '#e6eef8',
      subtitle: '#9fb0c6',
      note: '#cbd5e1',
      strokeBase: '#a7b8cf',
      strokeDirect: '#a7b8cf',
      strokeLateral: '#fbbf24',
      strokeContains: '#60a5fa',
      boxBase: '#0b1730',
      boxAtt: '#a855f7',
      boxEntry: '#f59e0b',
      boxTarget: '#22c55e',
      boxFinal: '#16a34a'
    }
  } = options;

  // ---- guards ----
  if (!pathObj || !Array.isArray(pathObj.nodes) || !pathObj.nodes.length) {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="640" height="120" viewBox="0 0 640 120" role="img" aria-label="Empty path">
      <rect x="0" y="0" width="640" height="120" fill="${colors.bg}"/>
      <text x="16" y="64" fill="${colors.title}" font-family="${fontFamily}" font-size="14">Empty path</text>
    </svg>`;
  }

  // ---- helpers ----
  const esc = s => String(s || '').replace(/[&<>"]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
  const wrap = (text, max = 28) => {
    const t = String(text || '');
    if (t.length <= max) return [t];
    const words = t.split(/\s+/);
    const lines = [];
    let cur = '';
    for (const w of words) {
      if ((cur ? cur + ' ' : '') .length + w.length > max) {
        if (cur) lines.push(cur);
        cur = w;
      } else {
        cur = cur ? cur + ' ' + w : w;
      }
    }
    if (cur) lines.push(cur);
    return lines.slice(0, 3);
  };

  const nameOf = (id) => (state.targets.find(t => t.id === id) || { name: '?' }).name;

  // Decide edge type between consecutive nodes in the path
  const isInSet = (map, from, to) => {
    const set = map[from];
    if (!set) return false;
    // map can be Set or Array depending on how state was loaded
    if (set instanceof Set) return set.has(to);
    return Array.isArray(set) ? set.includes(to) : false;
  };
  const edgeTypeBetween = (fromId, toId) => {
    if (isInSet(state.edges?.lateral || {}, fromId, toId)) return 'lateral';
    if (isInSet(state.edges?.contains || {}, fromId, toId)) return 'contains';
    return 'direct';
  };

  // ---- build "steps" sequence ----
  const entriesNames = [...(state.attackers.find(a => a.id === pathObj.attackerId)?.entries || new Set())].map(nameOf);
  const steps = [
    { kind: 'attacker', title: 'Attacker', subtitle: pathObj.attacker || '—' },
    { kind: 'entries',  title: 'Entries',  subtitle: entriesNames.length ? entriesNames.join(', ') : '—' },
    ...pathObj.nodes.map((n, i) => ({
      kind: 'target',
      title: `Target ${i + 1}${i === pathObj.nodes.length - 1 ? ' (final)' : ''}`,
      subtitle: n.name,
      isFinal: i === pathObj.nodes.length - 1,
      vulns: (pathObj.vulnsPerNode?.[i] || [])
    }))
  ];

  // Determine canvas base dimensions
  const anyTarget = steps.some(s => s.kind === 'target');
  const baseH = padY * 2 + boxH + (anyTarget && showVulns ? (vulnLineHeight + 18) : 0);
  const baseW = padX * 2 + steps.length * boxW + (steps.length - 1) * gap;

  // ---- SVG construction ----
  let x = padX, y = padY;
  let svg = `
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 ${baseW} ${baseH}" width="${Math.min(baseW, 1600)}" height="${baseH}"
     role="img" aria-label="Attack path diagram">
  <defs>
    <marker id="arrowHead" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
      <polygon points="0,0 12,4 0,8" fill="${colors.strokeBase}"/>
    </marker>
    <style>
      .title { font: 600 14px ${fontFamily}; fill: ${colors.title}; }
      .subtitle { font: 12px ${fontFamily}; fill: ${colors.subtitle}; }
      .note { font: 12px ${fontFamily}; fill: ${colors.note}; }
      .box { fill: ${colors.boxBase}; stroke-width: 1.4; rx: ${corner}; ry: ${corner}; }
      .box-att { stroke: ${colors.boxAtt}; }
      .box-entry { stroke: ${colors.boxEntry}; }
      .box-target { stroke: ${colors.boxTarget}; }
      .box-final { stroke: ${colors.boxFinal}; stroke-width: 2; }
      .arrow { stroke: ${colors.strokeDirect}; stroke-width: 1.6; fill: none; marker-end: url(#arrowHead); }
      .arrow-lat { stroke: ${colors.strokeLateral}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 6 4; }
      .arrow-contains { stroke: ${colors.strokeContains}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 2 4; }
      .bg { fill: ${colors.bg}; }
    </style>
  </defs>
  <rect class="bg" x="0" y="0" width="${baseW}" height="${baseH}" rx="${corner}" ry="${corner}"/>
`;

  // precompute edge types between consecutive target nodes
  const pathTargetIds = pathObj.nodes.map(n => n.id);
  const hopTypes = [];
  for (let i = 0; i < pathTargetIds.length - 1; i++) {
    hopTypes[i] = edgeTypeBetween(pathTargetIds[i], pathTargetIds[i + 1]);
  }

  function drawBox(className, title, subtitle, isFinal) {
    svg += `<rect class="box ${className} ${isFinal ? 'box-final' : ''}" x="${x}" y="${y}" width="${boxW}" height="${boxH}" />`;
    let ty = y + 24;
    wrap(title, maxTitleChars).forEach(ln => { svg += `<text class="title" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 16; });
    wrap(subtitle, maxSubtitleChars).forEach(ln => { svg += `<text class="subtitle" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 14; });
  }

  steps.forEach((s, i) => {
    const cls =
      s.kind === 'attacker' ? 'box-att' :
      s.kind === 'entries'  ? 'box-entry' : 'box-target';

    drawBox(cls, s.title, s.subtitle, s.isFinal);

    if (s.kind === 'target' && showVulns) {
      const text = s.vulns && s.vulns.length
        ? `Vulns: ${truncateList(s.vulns, maxVulnChars)}`
        : 'No vulnerabilities';
      svg += `<text class="note" x="${x + 10}" y="${y + boxH + 22}">${esc(text)}</text>`;
    }

    if (i < steps.length - 1) {
      // Draw edge to next step, deciding style by hop type (only between target→target)
      const nx = x + boxW + gap;
      const midY = y + boxH / 2;
      let clsArrow = 'arrow'; // default direct
      if (s.kind === 'target') {
        const idx = i - 2; // because steps[0]=attacker, steps[1]=entries
        if (idx >= 0 && idx < hopTypes.length) {
          const t = hopTypes[idx];
          if (t === 'lateral') clsArrow = 'arrow-lat';
          else if (t === 'contains') clsArrow = 'arrow-contains';
        }
      }
      svg += `<path class="${clsArrow}" d="M ${x + boxW} ${midY} C ${x + boxW + gap / 2} ${midY} ${nx - gap / 2} ${midY} ${nx} ${midY}" />`;
      x = nx;
    }
  });

  svg += `</svg>`;
  return svg;

  // truncate comma-joined lists to a max char count (soft)
  function truncateList(arr, max) {
    const s = arr.join(', ');
    if (s.length <= max) return s;
    // Try to keep full items, not mid-word cut
    let out = '';
    for (let i = 0; i < arr.length; i++) {
      const next = out ? out + ', ' + arr[i] : arr[i];
      if (next.length > max) break;
      out = next;
    }
    return out ? out + '…' : s.slice(0, max - 1) + '…';
  }
}

/**
 * Render the diagram into a container element.
 * @param {HTMLElement} containerEl - target container (e.g., document.getElementById('diagramBox'))
 * @param {Object} pathObj - result item { attacker, attackerId, nodes: [{id,name}], vulnsPerNode: [...] }
 * @param {Object} state - full app state (targets, edges, attackers...)
 * @param {Object} options - same as buildSVGForPath options (optional)
 * @returns {SVGElement|null}
 */
export function renderDiagram(containerEl, pathObj, state, options = {}) {
  if (!containerEl) return null;
  const svgStr = buildSVGForPath(pathObj, state, options);
  containerEl.innerHTML = svgStr;
  const svg = containerEl.querySelector('svg');
  // small QoL: enable horizontal scroll with Shift+wheel
  containerEl.style.overflowX = 'auto';
  containerEl.style.overflowY = 'hidden';
  containerEl.onwheel = (ev) => {
    if (ev.shiftKey) {
      containerEl.scrollLeft += ev.deltaY;
      ev.preventDefault();
    }
  };
  return svg || null;
}

/**
 * Download an existing <svg> as an .svg file.
 * @param {SVGElement} svgEl
 * @param {string} filename
 */
export function downloadSVG(svgEl, filename = 'attack-diagram.svg') {
  if (!svgEl) return;
  const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/* ===== Usage example (in UI code) =====
import { renderDiagram, downloadSVG } from './diagram.js';
import { State } from './state.js';

const svg = renderDiagram(document.getElementById('diagramBox'), pathItem, State, {
  showVulns: true,
  gap: 68
});
document.getElementById('btnDownloadSVG').onclick = () => downloadSVG(svg, 'attack-diagram.svg');
*/

===== ./js/main.js =====
// js/main.js
// Main UI logic with immediate persistence and dual playback:
// - dataset playback for computed paths (left/right navigation)
// - simulation playback bridge (play/pause/stop/restart/step; speed control)

import './simulation/scenarios.js';

import { el, norm } from './helpers.js';
import * as StateMod from './state.js';
import { saveToLocal, loadFromLocal, exportJSON, importJSON, clearLocal } from './storage.js';
import {
  renderAttackers,
  renderTargets,
  renderVulns,
  populateSelectors,
  renderLinksInspector,
  setOptions,
  hydrateEntriesSelect,
  hydrateExitsSelect,
  hydrateVulnSelectors
} from './ui/lists.js';
import { wireLinksUI } from './ui/links.js';
import { computeAllPaths } from './paths.js';
import { buildSVGForPath } from './diagram.js';
import { exportODS } from './exportODS.js';
import {
  runSimulation,
  disableTopButtons,
  enableTopButtons,
  simPlay, simPause, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simIsRunning, simIsPaused,
  simCanStepBack, simCanStepForward
} from './simulation/index.js';

let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

/* -------------------------------------------------------------------------- */
/* UI selection store (remember current attacker + vuln target)               */
/* -------------------------------------------------------------------------- */
const UI_STORE_KEY = 'envuln-lite-ui';
function saveUISelection(){
  try {
    localStorage.setItem(UI_STORE_KEY, JSON.stringify({
      attackerId: el('selAttacker')?.value || null,
      vulnTargetId: el('selVulnElement')?.value || null
    }));
  } catch {}
}
function loadUISelection(){
  try { return JSON.parse(localStorage.getItem(UI_STORE_KEY) || '{}'); }
  catch { return {}; }
}

/* -------------------------------------------------------------------------- */
/* Status                                                                     */
/* -------------------------------------------------------------------------- */
function renderStatus(s) {
  const sEl = el('status');
  if (sEl) sEl.textContent = s;
}

/* -------------------------------------------------------------------------- */
/* Global rerender                                                            */
/* -------------------------------------------------------------------------- */
function emitStateChanged() {
  try { saveToLocal(StateMod.State); } catch {}
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Playback UI helpers                                                        */
/* -------------------------------------------------------------------------- */
let playbackControlsEnabled = false; // source of truth for enabling the row

function setPlayPauseVisual(isPlaying) {
  const btn = el('btnPlayPause');
  if (!btn) return;
  btn.textContent = isPlaying ? '⏸' : '▶';
}

function setPlaybackEnabled(enabled) {
  playbackControlsEnabled = !!enabled;
  const ids = ['btnPlayPause','btnStop','btnRestart','btnStepBack','btnStepForward'];
  ids.forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !playbackControlsEnabled || !playback.dataset.length;
  });
  const row = document.getElementById('playbackRow');
  if (row) row.classList.toggle('is-disabled', !playbackControlsEnabled);
  if (!playbackControlsEnabled) setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Full wipe (used by Reset All) — clears state + results + diagram + playback */
/* -------------------------------------------------------------------------- */
function resetAllApp() {
  // 1) stop any running simulation and remove cursor
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor'); if (cur) cur.remove();

  // 2) wipe domain state
  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  // 3) storage and last-results cache
  try { clearLocal(); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}
  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  // 4) clear UI
  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram   = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div');
    ph.className = 'small';
    ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }
  const svgSizeEl = el('svgSize'); if (svgSizeEl) svgSizeEl.textContent = '—';
  const statusEl  = el('status');  if (statusEl)  statusEl.textContent  = '—';

  const inAtt = el('attackerName'); if (inAtt) inAtt.value = '';
  const inTar = el('targetName');   if (inTar) inTar.value = '';
  const inVul = el('vulnName');     if (inVul) inVul.value = '';

  // 5) clear playback dataset and reset playback
  playback_setDataset([]);
  playback_resetToStart();

  // 6) disable playback controls and rerender
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Bridge playback controls to simulation engine                              */
/* -------------------------------------------------------------------------- */
function bridgeSimulationPlayback() {
  // intentionally empty: unified handlers in wirePlaybackControls()
}

/* -------------------------------------------------------------------------- */
/* Hidden buttons for scenarios that call add/remove link by clicking         */
/* -------------------------------------------------------------------------- */
function ensureSimScenarioLinkButtons() {
  const byId = (id) => document.getElementById(id);

  ['btnAddLink','btnRemoveLink'].forEach(id => {
    if (!byId(id)) {
      const b = document.createElement('button');
      b.id = id;
      b.type = 'button';
      b.hidden = true;
      document.body.appendChild(b);
    }
  });

  const btnAdd = byId('btnAddLink');
  const btnDel = byId('btnRemoveLink');

  const srcSel  = byId('linkSource');
  const dstSel  = byId('linkDest');
  const typeSel = byId('linkType');

  const apply = (mode) => {
    const from = srcSel?.value;
    const type = typeSel?.value || 'direct';
    if (!from || !dstSel) return;

    const selectedTos = [...dstSel.selectedOptions].map(o => o.value);
    if (!selectedTos.length) return;

    selectedTos.forEach(to => {
      try {
        if (mode === 'add') {
          StateMod.addEdge(type, from, to);
        } else {
          StateMod.removeEdge(type, from, to);
        }
      } catch {}
    });

    try { saveToLocal(StateMod.State); } catch {}
    renderLinksInspector();
  };

  if (btnAdd) btnAdd.addEventListener('click', () => apply('add'));
  if (btnDel) btnDel.addEventListener('click', () => apply('del'));
}

/* -------------------------------------------------------------------------- */
/* Initialization                                                             */
/* -------------------------------------------------------------------------- */
async function init() {
  const loaded = loadFromLocal();
  if (loaded) StateMod.hydrate(loaded);

  StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));

  renderAllUI();

  // Restore UI selection (attacker + vuln target)
  const ui = loadUISelection();
  if (ui.attackerId) {
    const selAtt = el('selAttacker');
    if (selAtt && [...selAtt.options].some(o => o.value === ui.attackerId)) {
      selAtt.value = ui.attackerId;
      hydrateEntriesSelect(StateMod.State);
      hydrateExitsSelect(StateMod.State);
    }
  }
  if (ui.vulnTargetId) {
    const selT = el('selVulnElement');
    if (selT && [...selT.options].some(o => o.value === ui.vulnTargetId)) {
      selT.value = ui.vulnTargetId;
      hydrateVulnSelectors(StateMod.State);
    }
  }

  wireAddControls();
  wireAttackerSelection();
  wireEntries();
  wireExits();
  wireVulns();
  wireLinksUI();
  wireTopActions();
  wireSimulationButton();
  wirePlaybackControls();
  bridgeSimulationPlayback();
  ensureSimScenarioLinkButtons();

  // playback disabled by default until a simulation is started
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  playback_setDataset([]);
  playback_renderCurrent();
  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Rendering                                                                  */
/* -------------------------------------------------------------------------- */
function renderAllUI() {
  renderAttackers(StateMod.State);
  renderTargets(StateMod.State);
  renderVulns(StateMod.State);
  populateSelectors(StateMod.State);

  hydrateEntriesSelect(StateMod.State);
  hydrateExitsSelect(StateMod.State);
  hydrateVulnSelectors(StateMod.State);

  renderLinksInspector();

  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Add controls + Reset All                                                   */
/* -------------------------------------------------------------------------- */
function wireAddControls() {
  el('btnAddAttacker').onclick = () => {
    const name = norm(el('attackerName').value);
    if (!name) return;
    StateMod.createAttacker(name);
    el('attackerName').value = '';
    emitStateChanged();
  };

  el('btnAddTarget').onclick = () => {
    const name = norm(el('targetName').value);
    if (!name) return;
    const id = StateMod.createTarget(name);
    StateMod.ensureEdgeMaps(id);
    el('targetName').value = '';
    emitStateChanged();
  };

  el('btnAddVuln').onclick = () => {
    const name = norm(el('vulnName').value);
    if (!name) return;
    StateMod.createVuln(name);
    el('vulnName').value = '';
    emitStateChanged();
  };

  const btnResetAll = el('btnResetAll');
  if (btnResetAll) {
    btnResetAll.onclick = () => {
      if (confirm('This will erase all attackers, targets, vulnerabilities, links, results and local storage. Continue?')) {
        resetAllApp();
      }
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Attacker selection                                                         */
/* -------------------------------------------------------------------------- */
function wireAttackerSelection() {
  el('selAttacker').addEventListener('change', () => {
    hydrateEntriesSelect(StateMod.State);
    hydrateExitsSelect(StateMod.State);
    saveUISelection(); // remember current attacker in UI store
  });
}

/* -------------------------------------------------------------------------- */
/* Entries (real-time + clear)                                                */
/* -------------------------------------------------------------------------- */
function wireEntries() {
  const sel = el('selEntriesAll');
  const btnClear = el('btnClearEntries');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerEntries(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerEntries(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Exits (real-time + clear)                                                  */
/* -------------------------------------------------------------------------- */
function wireExits() {
  const sel = el('selExitsAll');
  const btnClear = el('btnClearExits');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerExits(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerExits(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Vulnerabilities (real-time + clear)                                        */
/* -------------------------------------------------------------------------- */
function wireVulns() {
  const selTarget = el('selVulnElement');
  const selVulns = el('selVulnsForElement');
  const btnClear = el('btnClearVulnSelection');

  if (!selTarget || !selVulns) return;

  const applySelectionToState = () => {
    const targetId = selTarget.value;
    if (!targetId) return;
    const vids = [...selVulns.selectedOptions].map(o => o.value);
    const t = StateMod.State.targets.find(x => x.id === targetId);
    if (!t) return;
    t.vulns = new Set(vids);
    emitStateChanged();
  };

  selTarget.addEventListener('change', () => {
    hydrateVulnSelectors(StateMod.State); // repopulate + reselect
    saveUISelection();                    // remember current vuln target in UI store
  });

  selVulns.addEventListener('change', applySelectionToState);

  if (btnClear) {
    btnClear.onclick = () => {
      [...selVulns.options].forEach(o => o.selected = false);
      applySelectionToState();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Results rendering                                                          */
/* -------------------------------------------------------------------------- */
function renderResultsList(results) {
  const cont = el('results');
  const svgSizeEl = el('svgSize');
  cont.innerHTML = '';
  if (!results.length) {
    // Provide a useful reason when the list is empty
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const msg = (filterOn && (lastResults?.length || 0) > 0)
      ? 'No paths match the "Only vulnerable paths" filter.'
      : 'No paths.';
    cont.innerHTML = `<div class="small">${msg}</div>`;
    if (svgSizeEl) svgSizeEl.textContent = '—';
    playback_setDataset([]);
    return;
  }

  results.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';

    const left = document.createElement('div');
    left.className = 'left';
    const title = document.createElement('div');
    title.innerHTML = `<strong>${p.attackerName}</strong>`;
    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.append(title, chain);

    const btn = document.createElement('button');
    btn.className = 'ghost';
    btn.textContent = 'Diagram';
    btn.onclick = () => playback_showIndex(idx, true);

    row.append(left, btn);
    cont.appendChild(row);
  });

  playback_setDataset(results);
}

/* -------------------------------------------------------------------------- */
/* Top actions (compute/export/import/download)                               */
/* -------------------------------------------------------------------------- */
function wireTopActions() {
  const chkOnlyVuln = el('chkOnlyVuln');

  const summarize = (count, meta) => {
    const parts = [];
    parts.push(`${count} path${count === 1 ? '' : 's'}`);
    if (meta.cycles) parts.push('cycles detected (simple paths)');
    if (meta.truncated) parts.push('truncated by ceiling');
    renderStatus(parts.join(' • '));
  };

  // Consider a path "vulnerable everywhere" only from the second node onward
  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);

  const renderFiltered = () => {
    const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
    const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
    renderResultsList(display);
    summarize(display.length, lastMeta);
  };

  el('btnFindPaths').onclick = () => {
    const opts = {
      includeLateral: el('includeLateral').checked,
      includeContains: el('includeContains').checked
    };
    const max = parseInt(el('maxPaths').value, 10);
    const out = computeAllPaths(StateMod.State, opts, max);
    lastResults = out.paths || [];
    lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };
    renderFiltered();
    playback_resetToStart();
  };

  if (chkOnlyVuln) chkOnlyVuln.addEventListener('change', () => {
    renderFiltered();
    playback_resetToStart();
  });

  el('btnDownloadSVG').onclick = () => {
    const svg = el('diagramBox')?.querySelector('svg');
    if (!svg) return;
    const blob = new Blob([svg.outerHTML], { type: 'image/svg+xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `attack-diagram-${new Date().toISOString().replace(/[:.]/g, '-')}.svg`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 0);
  };

  const btnODS = el('btnExportODS');
  if (btnODS) {
    btnODS.onclick = () => {
      const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
      const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
      if (!display.length) return alert('No paths to export.');
      exportODS(StateMod.State, { results: display });
    };
  }

  const btnExportJSON = el('btnExportJSON');
  const btnImportJSON = el('btnImportJSON');
  const fileIn = el('fileIn');

  if (btnExportJSON) {
    btnExportJSON.onclick = () => {
      saveToLocal(StateMod.State);
      exportJSON(StateMod.State);
    };
  }

  if (btnImportJSON && fileIn) {
    btnImportJSON.onclick = () => fileIn.click();
    fileIn.onchange = async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const txt = await file.text();
      const state = importJSON(txt);
      if (!state) return alert('Invalid JSON.');
      StateMod.hydrate(state);
      StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));
      renderAllUI();
      fileIn.value = '';
      playback_resetToStart();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Simulation launcher button (auto-scenarios)                                */
/* -------------------------------------------------------------------------- */
function wireSimulationButton() {
  const btn = el('btnSimu');
  if (!btn) return;
  btn.onclick = async () => {
    try {
      disableTopButtons(true);
      setPlaybackEnabled(true);
      setPlayPauseVisual(true);
      playback_updateButtons();
      btn.textContent = 'Simulating…';
      btn.disabled = true;
      await runSimulation({ renderCallback: () => renderAllUI() });
    } finally {
      btn.textContent = 'Simulation';
      btn.disabled = false;
      enableTopButtons();
      setPlayPauseVisual(false);
      setPlaybackEnabled(false);
      renderAllUI();
      playback_resetToStart?.();
      playback_updateButtons();
    }
  };
}

/* -------------------------------------------------------------------------- */
/* Fresh simulation reset helper                                              */
/* -------------------------------------------------------------------------- */
function resetForFreshSimulation() {
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor');
  if (cur) cur.remove();

  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div'); ph.className = 'small'; ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }

  const svgSizeEl1 = el('svgSize'); if (svgSizeEl1) svgSizeEl1.textContent = '—';
  const statusEl  = el('status');   if (statusEl)  statusEl.textContent = '—';

  try { localStorage.removeItem('envuln-lite-store'); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}

  renderAllUI();
  if (typeof playback_resetToStart === 'function') playback_resetToStart();
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Results playback (diagram paging)                                          */
/* -------------------------------------------------------------------------- */
const playback = {
  dataset: [],
  index: 0,
  playing: false,
  timer: null,
  speed: 1.0,
  baseDelayMs: 1200
};

window.__updatePlaybackButtons = () => playback_updateButtons();

function playback_setDataset(results) {
  playback.dataset = Array.isArray(results) ? results.slice() : [];
  playback.index = 0;
  playback_updateButtons();
}
function playback_current() {
  return playback.dataset[playback.index] || null;
}
function playback_renderCurrent() {
  const p = playback_current();
  const box = el('diagramBox');
  const svgSizeEl = el('svgSize');
  if (!p || !box) {
    if (box) box.innerHTML = '<div class="small">Select a path → Diagram</div>';
    if (svgSizeEl) svgSizeEl.textContent = '—';
    return;
  }
  const svgStr = buildSVGForPath(p, StateMod.State);
  box.innerHTML = svgStr;
  const svg = box.querySelector('svg');
  if (svg && svgSizeEl) {
    const w = +svg.getAttribute('width') || svg.viewBox?.baseVal?.width || svg.getBoundingClientRect().width;
    const h = +svg.getAttribute('height') || svg.viewBox?.baseVal?.height || svg.getBoundingClientRect().height;
    svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
  }
}
function playback_updateButtons() {
  const btnPP          = el('btnPlayPause');
  const btnStop        = el('btnStop');
  const btnRestart     = el('btnRestart');
  const btnStepBack    = el('btnStepBack');
  const btnStepForward = el('btnStepForward');

  const simRunning = (typeof simIsRunning === 'function') && simIsRunning();
  const simPaused  = (typeof simIsPaused  === 'function') && simIsPaused();
  const hasData    = playback.dataset.length > 0;

  // enable the row when (a) sim is running OR (b) dataset is present, and the row is globally enabled
  const enableRow  = playbackControlsEnabled && (simRunning || hasData);

  [btnPP, btnStop, btnRestart, btnStepBack, btnStepForward].forEach(b => {
    if (b) b.disabled = !enableRow;
  });

  // step buttons: use sim stepping when sim is running, otherwise dataset edges
  if (enableRow) {
    if (simRunning) {
      if (btnStepBack)    btnStepBack.disabled    = !(typeof simCanStepBack === 'function' && simCanStepBack());
      if (btnStepForward) btnStepForward.disabled = !(typeof simCanStepForward === 'function' && simCanStepForward());
    } else {
      if (btnStepBack)    btnStepBack.disabled    = playback.index <= 0;
      if (btnStepForward) btnStepForward.disabled = playback.index >= (playback.dataset.length - 1);
    }
  }

  // icon logic: simulation state wins; dataset playback is used when no sim is running
  if (btnPP) {
    if (simRunning) {
      btnPP.textContent = simPaused ? '▶' : '⏸';
    } else {
      btnPP.textContent = playback.playing ? '⏸' : '▶';
    }
  }
}
function playback_tick() {
  if (!playback.playing) return;
  const delay = Math.max(200, Math.floor(playback.baseDelayMs / Math.max(0.2, playback.speed)));
  clearTimeout(playback.timer);
  playback.timer = setTimeout(() => {
    playback_stepForward();
    if (playback.playing) playback_tick();
  }, delay);
}
function playback_play() {
  if (!playback.dataset.length) return;
  playback.playing = true;
  playback_updateButtons();
  setPlayPauseVisual(true);
  playback_tick();
}
function playback_pause() {
  playback.playing = false;
  clearTimeout(playback.timer);
  playback_updateButtons();
  setPlayPauseVisual(false);
}
function playback_stop() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_restart() {
  playback.index = 0;
  playback_renderCurrent();
  if (playback.playing) playback_tick();
}
function playback_stepForward() {
  if (!playback.dataset.length) return;
  if (playback.index < playback.dataset.length - 1) {
    playback.index += 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_stepBack() {
  if (!playback.dataset.length) return;
  if (playback.index > 0) {
    playback.index -= 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_setSpeed(mult) {
  playback.speed = Math.max(0.2, Math.min(3, +mult || 1));
  const lab = el('simSpeedValue');
  if (lab) lab.textContent = `×${playback.speed.toFixed(1)}`;
  if (playback.playing) playback_tick();
}
function playback_resetToStart() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_showIndex(idx, pauseAfter = false) {
  if (!playback.dataset.length) return;
  playback.index = Math.max(0, Math.min(playback.dataset.length - 1, idx));
  playback_renderCurrent();
  if (pauseAfter) playback_pause();
}
function playback_computeIfNeededAndStart() {
  if (playback.dataset.length > 0) {
    playback_play();
    return;
  }
  const opts = {
    includeLateral: !!el('includeLateral')?.checked,
    includeContains: !!el('includeContains')?.checked
  };
  const max = parseInt(el('maxPaths')?.value || '2000', 10);
  const out = computeAllPaths(StateMod.State, opts, max);
  lastResults = out.paths || [];
  lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };

  const chkOnlyVuln = el('chkOnlyVuln');
  // Same "everywhere" definition as in wireTopActions
  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);
  const display = chkOnlyVuln && chkOnlyVuln.checked
    ? lastResults.filter(hasVulnsEverywhere)
    : lastResults;

  renderResultsList(display);

  if (display.length) {
    playback_renderCurrent();
    playback_play();
  } else {
    // Provide a status hint about probable cause
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const anyExits = (StateMod.State.attackers || []).some(a => (a.exits instanceof Set ? a.exits.size : (a.exits || []).length) > 0);
    if (filterOn && (lastResults?.length || 0) > 0) {
      renderStatus('0 paths • all were excluded by "Only vulnerable paths".');
    } else if (anyExits) {
      renderStatus('0 paths • check exit nodes are actually reachable.');
    } else {
      renderStatus('0 paths • check entries, links and options.');
    }
  }
}

/* -------------------------------------------------------------------------- */
/* Wire dataset + simulation playback controls                                */
/* -------------------------------------------------------------------------- */
function wirePlaybackControls() {
  const btnPP         = el('btnPlayPause');
  const btnStop       = el('btnStop');
  const btnRestart    = el('btnRestart');
  const btnStepBack   = el('btnStepBack');
  const btnStepForward= el('btnStepForward');
  const speed         = el('simSpeed');

  // Play / Pause
  if (btnPP) {
    btnPP.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        if (simIsPaused && simIsPaused()) {
          try { simPlay(); } catch {}
          setPlayPauseVisual(true);
        } else {
          try { simPause(); } catch {}
          setPlayPauseVisual(false);
        }
        playback_updateButtons();
        return;
      }
      // Dataset playback
      if (playback.playing) {
        playback_pause();
      } else {
        if (!playback.dataset.length) {
          playback_computeIfNeededAndStart();
        } else {
          if (!el('diagramBox')?.querySelector('svg')) playback_renderCurrent();
          playback_play();
        }
      }
      playback_updateButtons();
    };
  }

  // Stop
  if (btnStop) {
    btnStop.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}
        setPlayPauseVisual(false);
        setPlaybackEnabled(false);
        playback_updateButtons();
        return;
      }
      // Dataset playback stop
      playback_stop();
      playback_updateButtons();
    };
  }

  if (btnRestart) {
    btnRestart.onclick = async () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}

        try {
          disableTopButtons(true);
          setPlaybackEnabled(true);
          setPlayPauseVisual(true);
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulating…'; b.disabled = true; }
          await runSimulation({ renderCallback: () => renderAllUI() });
        } finally {
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulation'; b.disabled = false; }
          enableTopButtons();
          setPlayPauseVisual(false);
          setPlaybackEnabled(false);
          renderAllUI();
          playback_resetToStart?.();
          playback_updateButtons();
        }
        return;
      }
      playback_restart();
      playback_updateButtons();
    };
  }

  // Step back
  if (btnStepBack) {
    btnStepBack.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepBack(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepBack();
      playback_updateButtons();
    };
  }

  // Step forward
  if (btnStepForward) {
    btnStepForward.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepForward(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepForward();
      playback_updateButtons();
    };
  }

  // Speed
  if (speed) {
    playback_setSpeed(speed.value || 1);
    try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    const lab = el('simSpeedValue');
    if (lab) lab.textContent = `×${(+speed.value || 1).toFixed(1)}`;
    speed.addEventListener('input', () => {
      playback_setSpeed(speed.value);
      try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    });
  }

  // initial clean state
  playback_updateButtons();
  playback_renderCurrent();
}

/* -------------------------------------------------------------------------- */
/* Convenience export if needed elsewhere                                     */
/* -------------------------------------------------------------------------- */
function playback_setExternalResults(results) {
  playback_setDataset(results);
  playback_resetToStart();
}

/* -------------------------------------------------------------------------- */
/* Boot                                                                       */
/* -------------------------------------------------------------------------- */
window.__envuln_boot = {
  State: StateMod.State,
  computeAllPaths,
  playback_setExternalResults
};
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

===== ./js/state.js =====
// js/state.js
// Global application state

import { uid } from './helpers.js';

export const State = {
  version: 4,
  attackers: [],   // { id, name, entries:Set<targetId>, exits:Set<targetId> }
  targets: [],     // { id, name, vulns:Set<vulnId>, final:boolean }
  vulns: [],       // { id, name }
  edges: {
    direct: {},
    lateral: {},
    contains: {}
  }
};

export function ensureEdgeMaps(id){
  State.edges.direct[id]   = State.edges.direct[id]   || new Set();
  State.edges.lateral[id]  = State.edges.lateral[id]  || new Set();
  State.edges.contains[id] = State.edges.contains[id] || new Set();
}

function uniqueNameExists(list, name){
  return list.some(x => x.name.trim().toLowerCase() === name.trim().toLowerCase());
}

export function createAttacker(name){
  name = name.trim();
  if(!name) throw new Error('Attacker name required');
  if(uniqueNameExists(State.attackers, name)) throw new Error('Attacker already exists');
  const id = uid();
  State.attackers.push({ id, name, entries:new Set(), exits:new Set() });
  return id;
}

export function renameAttacker(id, newName){
  const a = State.attackers.find(x=>x.id===id);
  if(!a) throw new Error('Unknown attacker');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.attackers,newName) && a.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  a.name = newName;
}

export function deleteAttacker(id){
  State.attackers = State.attackers.filter(a=>a.id!==id);
}

export function createTarget(name, isFinal=false){
  name = name.trim();
  if(!name) throw new Error('Target name required');
  if(uniqueNameExists(State.targets,name)) throw new Error('Target already exists');
  const id = uid();
  State.targets.push({ id, name, vulns:new Set(), final:!!isFinal });
  ensureEdgeMaps(id);
  return id;
}

export function renameTarget(id, newName){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.targets,newName) && t.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  t.name = newName;
}

export function setTargetFinal(id, val){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  t.final = !!val;
}

export function deleteTarget(id){
  State.targets = State.targets.filter(t=>t.id!==id);
  for(const m of Object.values(State.edges)){
    delete m[id];
    for(const k in m) m[k].delete(id);
  }
  State.attackers.forEach(a => {
    a.entries?.delete(id);
    a.exits?.delete(id);
  });
}

export function createVuln(name){
  name = name.trim();
  if(!name) throw new Error('Vulnerability name required');
  if(uniqueNameExists(State.vulns,name)) throw new Error('Vulnerability already exists');
  const id = uid();
  State.vulns.push({ id, name });
  return id;
}

export function deleteVuln(id){
  State.vulns = State.vulns.filter(v=>v.id!==id);
  State.targets.forEach(t => t.vulns.delete(id));
}

export function toggleVulnOnTarget(targetId, vulnId, enable){
  const t = State.targets.find(x=>x.id===targetId);
  if(!t) throw new Error('Unknown target');
  if(!(t.vulns instanceof Set)) t.vulns = new Set(t.vulns || []);
  if(enable) t.vulns.add(vulnId); else t.vulns.delete(vulnId);
}

export function setAttackerEntries(attackerId, entryIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.entries = new Set(entryIds);
}

export function setAttackerExits(attackerId, exitIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.exits = new Set(exitIds);
}

export function addEdge(type, fromId, toId){
  if(!State.edges[type]) throw new Error('Invalid edge type');
  ensureEdgeMaps(fromId);
  State.edges[type][fromId].add(toId);
}

export function removeEdge(type, fromId, toId){
  if(!State.edges[type]) return;
  if(State.edges[type][fromId]) State.edges[type][fromId].delete(toId);
}

export const getAttackers = ()=> State.attackers;
export const getTargets   = ()=> State.targets;
export const getVulns     = ()=> State.vulns;

export function getTargetName(id){
  return (State.targets.find(t=>t.id===id)?.name) || '?';
}

// --- Add below: helpers for reviving JSON into live state -------------------
function asSet(x) {
  if (x instanceof Set) return x;
  if (Array.isArray(x)) return new Set(x);
  if (x && typeof x === 'object') return new Set(Object.keys(x)); // tolerate old shapes
  return new Set();
}
function reviveEdgeMap(rawMap = {}) {
  const out = {};
  for (const [fromId, tos] of Object.entries(rawMap)) {
    out[fromId] = asSet(tos);
  }
  return out;
}

// --- Exported: hydrate() to load a plain object into the live State ---------
export function hydrate(raw = {}) {
  // attackers
  State.attackers = Array.isArray(raw.attackers) ? raw.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: asSet(a.entries),
    exits:   asSet(a.exits)
  })) : [];

  // targets
  State.targets = Array.isArray(raw.targets) ? raw.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: asSet(t.vulns),
    final: !!t.final
  })) : [];

  // vulns
  State.vulns = Array.isArray(raw.vulns) ? raw.vulns.map(v => ({ id: v.id, name: v.name })) : [];

  // edges
  const edges = raw.edges || {};
  State.edges = {
    direct:   reviveEdgeMap(edges.direct),
    lateral:  reviveEdgeMap(edges.lateral),
    contains: reviveEdgeMap(edges.contains)
  };

  // ensure edge maps exist for every target id
  State.targets.forEach(t => ensureEdgeMaps(t.id));

  // bump/keep version
  State.version = Number.isFinite(raw.version) ? raw.version : State.version;
}

// (optional but handy) convert live state back to JSON-safe structure
export function dehydrate() {
  const edgeToObj = (m) => {
    const obj = {};
    for (const [k, v] of Object.entries(m)) obj[k] = Array.from(v || []);
    return obj;
  };
  return {
    version: State.version,
    attackers: State.attackers.map(a => ({
      id: a.id, name: a.name,
      entries: Array.from(a.entries || []),
      exits:   Array.from(a.exits   || [])
    })),
    targets: State.targets.map(t => ({
      id: t.id, name: t.name, final: !!t.final,
      vulns: Array.from(t.vulns || [])
    })),
    vulns: State.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   edgeToObj(State.edges.direct),
      lateral:  edgeToObj(State.edges.lateral),
      contains: edgeToObj(State.edges.contains)
    }
  };
}

if(typeof window !== 'undefined'){
  window.State = State;
}

===== ./js/helpers.js =====
/*************************************************************
 * helpers.js — tiny shared utilities for Envuln
 * ⚙️ 100% client-side / no UI logic / no state mutations
 *************************************************************/

/**
 * Query DOM by ID (shorter to type)
 */
export const el = id => document.getElementById(id);

/**
 * Normalized string: trim + collapse spaces
 */
export const norm = s => (s || '').trim().replace(/\s+/g, ' ');

/**
 * Cheap unique ID — enough for UI graph nodes
 */
export const uid = () =>
  Math.random().toString(36).slice(2, 9) + '-' + Date.now().toString(36);

/**
 * Escape text for safe HTML/SVG insertion (no DOMParser needed)
 */
export const esc = s =>
  String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

/**
 * Safe integer parsing with fallback
 */
export const toInt = (v, fallback = 0) => {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
};

/**
 * Clamp number between min and max
 */
export const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

/**
 * Remove duplicates while preserving order
 */
export const unique = arr => [...new Set(arr)];

/**
 * DOM: small utility to create elements faster
 * ex: div('.badge') or div({ class:'item', text:'Click!' })
 */
export function div(arg){
  const el = document.createElement('div');
  if(typeof arg === 'string'){
    el.className = arg.replace(/^\./,'');
  } else if(arg && typeof arg === 'object'){
    if(arg.class) el.className = arg.class;
    if(arg.text) el.textContent = arg.text;
    if(arg.html) el.innerHTML = arg.html;
  }
  return el;
}

/**
 * Scroll node into center view if needed (no crash if missing)
 */
export function ensureInView(node, block='center'){
  try { node?.scrollIntoView({ behavior:'smooth', block }); } catch {}
}

/**
 * Async wait helper (ms)
 */
export const wait = ms => new Promise(res => setTimeout(res, ms));

/**
 * Toggle class for a short pulse highlight
 */
export function pulse(node, duration = 600){
  if(!node) return;
  node.classList.add('sim-pulse');
  setTimeout(()=> node.classList.remove('sim-pulse'), duration);
}

===== ./js/exportODS.js =====
// exportODS.js
// Generate a Flat ODS (.fods) spreadsheet fully client-side

import { computeAllPaths, nameOfTarget } from './paths.js';

/**
 * Export results into a Flat ODS file (.fods)
 * @param {Object} state Current state (from state.js)
 * @param {Object} options Optional: { results?:Array, filter?:Function }
 *   - results: precomputed paths array (same shape as computeAllPaths(...).paths)
 *   - filter : (path) => boolean  (to include/exclude rows)
 */
export function exportODS(state, options = {}) {
  const pre = (options.results && Array.isArray(options.results)) ? options.results : null;
  const results = pre ?? computeAllPaths(state).paths;

  const filterFn = typeof options.filter === 'function' ? options.filter : () => true;

  const filtered = results.filter(filterFn);
  if (!filtered.length) {
    alert("No paths to export.");
    return;
  }

  // Helpers
  const esc = s => String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

  // ===== HEADERS =====
  const headPaths  = ['#','Attacker','Chain','Length','Final','Vulnerabilities (summary)'];
  const headDetail = ['Attacker','Step','Target','Final?','Vulnerabilities'];
  const headGraph  = ['Type','Source','Destination'];

  // ===== ROW BUILDERS =====
  const rowsPaths = filtered.map((p, idx) => {
    const chain = p.nodes.map(n => n.name).join(' → ');
    const len = p.nodes.length;
    const finale = len ? p.nodes[len - 1].name : '';
    const vulnSummary = p.vulnsPerNode.map((vs, i) => {
      const n = p.nodes[i]?.name || '?';
      return `[${n}: ${vs?.length ? vs.join(', ') : '—'}]`;
    }).join(' ');
    return [ String(idx+1), p.attackerName || p.attacker || '', chain, String(len), finale, vulnSummary ];
  });

  const rowsDetail = [];
  filtered.forEach(p => {
    p.nodes.forEach((n, i) => {
      const vs = p.vulnsPerNode?.[i] || [];
      rowsDetail.push([
        p.attackerName || p.attacker || '',
        String(i + 1),
        n?.name || '',
        (i === p.nodes.length - 1) ? 'Yes' : 'No',
        vs.length ? vs.join(', ') : '—'
      ]);
    });
  });

  const rowsGraph = [];
  const pushEdges = (type, map) => {
    for (const from in map) {
      const tos = Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []);
      tos.forEach(to => {
        rowsGraph.push([
          type,
          nameOfTarget(state, from),
          nameOfTarget(state, to)
        ]);
      });
    }
  };
  pushEdges('direct',   state.edges?.direct || {});
  pushEdges('lateral',  state.edges?.lateral || {});
  pushEdges('contains', state.edges?.contains || {});

  // ===== STYLE (readability) =====
  const styles = `
  <office:styles>
    <!-- Bold header -->
    <style:style style:name="hdr" style:family="table-cell">
      <style:text-properties fo:font-weight="bold"/>
      <style:table-cell-properties fo:background-color="#0b1730"
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"/>
      <style:paragraph-properties fo:margin="0cm"/>
    </style:style>

    <!-- Zebra row styles -->
    <style:style style:name="z1" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <style:style style:name="z2" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        fo:background-color="#0f223f" style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Wrapped text -->
    <style:style style:name="wrap" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Column widths -->
    <style:style style:name="colNarrow" style:family="table-column">
      <style:table-column-properties style:column-width="1.2cm"/>
    </style:style>
    <style:style style:name="colMed" style:family="table-column">
      <style:table-column-properties style:column-width="4.2cm"/>
    </style:style>
    <style:style style:name="colWide" style:family="table-column">
      <style:table-column-properties style:column-width="9.5cm"/>
    </style:style>
    <style:style style:name="colXL" style:family="table-column">
      <style:table-column-properties style:column-width="14cm"/>
    </style:style>
  </office:styles>`;

  // ===== XML TABLE UTILS =====
  const mkHeader = heads => `
    <table:table-header-rows>
      <table:table-row>
        ${heads.map(h =>
          `<table:table-cell office:value-type="string" table:style-name="hdr">
             <text:p>${esc(h)}</text:p>
           </table:table-cell>`
        ).join('')}
      </table:table-row>
    </table:table-header-rows>`;

  const mkRow = (cells, zebra=false, wrapIdx=new Set()) => `
    <table:table-row>
      ${cells.map((c,i)=>{
        const style = wrapIdx.has(i) ? 'wrap' : (zebra ? 'z2' : 'z1');
        return `<table:table-cell office:value-type="string" table:style-name="${style}">
                  <text:p>${esc(c)}</text:p>
                </table:table-cell>`;
      }).join('')}
    </table:table-row>`;

  // Columns that should wrap
  const wrapPaths  = new Set([2, 5]); // Chain, Vulnerabilities (summary)
  const wrapDetail = new Set([4]);    // Vulnerabilities
  const wrapGraph  = new Set([]);     // None

  // Build table bodies
  const headerPaths  = mkHeader(headPaths);
  const bodyPaths    = rowsPaths.map((r,i)=> mkRow(r, i%2===1, wrapPaths)).join('');
  const headerDetail = mkHeader(headDetail);
  const bodyDetail   = rowsDetail.map((r,i)=> mkRow(r, i%2===1, wrapDetail)).join('');
  const headerGraph  = mkHeader(headGraph);
  const bodyGraph    = rowsGraph.map((r,i)=> mkRow(r, i%2===1, wrapGraph)).join('');

  // Column layouts
  const colsPaths = `
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsDetail = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsGraph = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>`;

  // ===== ASSEMBLY =====
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document
 xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0"
 xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0"
 xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0"
 xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0"
 xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"
 office:version="1.2"
 office:mimetype="application/vnd.oasis.opendocument.spreadsheet">
 ${styles}
 <office:body>
   <office:spreadsheet>

     <!-- Paths sheet -->
     <table:table table:name="Paths">
       ${colsPaths}
       ${headerPaths}
       ${bodyPaths}
     </table:table>

     <!-- Detail sheet -->
     <table:table table:name="Detail">
       ${colsDetail}
       ${headerDetail}
       ${bodyDetail}
     </table:table>

     <!-- Graph sheet -->
     <table:table table:name="Graph">
       ${colsGraph}
       ${headerGraph}
       ${bodyGraph}
     </table:table>

   </office:spreadsheet>
 </office:body>
</office:document>`;

  // ===== DOWNLOAD =====
  const blob = new Blob(
    [xml],
    { type: 'application/vnd.oasis.opendocument.spreadsheet' }
  );
  const filename = `envuln-export-${new Date().toISOString().replace(/[:.]/g,'-')}.fods`;

  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

===== ./js/storage.js =====
/**
 * storage.js
 * Save and load application state to/from localStorage.
 * Converts runtime structures (Sets) to plain arrays for persistence.
 */

const KEY = 'envuln-lite-store';
const CURRENT_VERSION = 4;

/* ------------ Public API ------------ */

/**
 * Serialize runtime state to localStorage.
 * @param {object} state
 */
export function saveToLocal(state) {
  try {
    localStorage.setItem(KEY, JSON.stringify(toSerializable(state)));
  } catch (e) {
    console.warn('[storage] save error:', e);
  }
}

/**
 * Load from localStorage and convert back to runtime state.
 * @returns {object|null}
 */
export function loadFromLocal() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return null;

    const obj = JSON.parse(raw);
    if (!obj.version || obj.version !== CURRENT_VERSION) {
      console.warn('[storage] version mismatch: resetting storage');
      return null;
    }
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] load error -> reset storage:', e);
    return null;
  }
}

/** Clear storage */
export function clearLocal() {
  localStorage.removeItem(KEY);
}

/** Export JSON to a downloadable file */
export function exportJSON(state) {
  const serial = toSerializable(state);
  const blob = new Blob([JSON.stringify(serial, null, 2)], { type: 'application/json' });
  const ts = new Date().toISOString().replace(/[:.]/g, '-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `envuln-export-${ts}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/**
 * Convert a JSON string previously exported back into runtime state.
 * The caller is responsible for assigning it to the live singleton.
 */
export function importJSON(jsonStr) {
  try {
    const obj = JSON.parse(jsonStr);
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] invalid import JSON', e);
    return null;
  }
}

/* ------------ Runtime → serial ------------ */

function toSerializable(state) {
  return {
    version: CURRENT_VERSION,
    attackers: state.attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: [...a.entries],
      exits:   [...a.exits]
    })),
    targets: state.targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: [...t.vulns],
      final: !!t.final
    })),
    vulns: state.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   setsToArrays(state.edges.direct),
      lateral:  setsToArrays(state.edges.lateral),
      contains: setsToArrays(state.edges.contains),
    }
  };
}

/* ------------ Serial → runtime ------------ */

function fromSerializable(obj) {
  if (!obj || typeof obj !== 'object') {
    console.warn('[storage] fromSerializable failed');
    return null;
  }

  const {
    attackers = [],
    targets = [],
    vulns = [],
    edges = {}
  } = obj;

  return {
    version: obj.version ?? CURRENT_VERSION,
    vulns: vulns.map(v => ({ id: v.id, name: v.name })),
    targets: targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: new Set(t.vulns || []),
      final: !!t.final
    })),
    attackers: attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: new Set(a.entries || []),
      exits:   new Set(a.exits   || [])
    })),
    edges: {
      direct:   arraysToSets(edges.direct   || {}),
      lateral:  arraysToSets(edges.lateral  || {}),
      contains: arraysToSets(edges.contains || {})
    }
  };
}

/* ------------ Helpers ------------ */

function setsToArrays(map) {
  const out = {};
  for (const k in map) {
    out[k] = [...(map[k] || [])];
  }
  return out;
}

function arraysToSets(map) {
  const out = {};
  for (const k in map) {
    out[k] = new Set(map[k] || []);
  }
  return out;
}

===== ./styles/app.css =====
/* =====================
   Global theme
===================== */
:root {
  --bg: #071022;
  --panel: #0d1726;
  --muted: #9fb0c6;
  --accent: #2b8af6;
  --glass: rgba(255,255,255,0.03);

  --border-light: rgba(255,255,255,0.06);
  --border-soft: rgba(255,255,255,0.04);
  --border-strong: rgba(255,255,255,0.08);

  --text-main: #e6eef8;
  --text-muted: #9fb0c6;

  --shadow: 0 6px 18px rgba(0,0,0,0.6);
  --radius: 10px;
}

html, body {
  margin: 0;
  height: 100%;
  font-family: Inter, system-ui, Arial, sans-serif;
  background: linear-gradient(180deg, #041022, #021018);
  color: var(--text-main);
  user-select: none;
}

/* =====================
   Layout
===================== */
.wrap {
  display: grid;
  height: 100vh;
  box-sizing: border-box;
  padding: 18px;
  grid-template-columns: 300px 1fr 380px;
  gap: 16px;
}

.panel {
  min-height: 0;
  padding: 12px;
  overflow: auto;
  border-radius: var(--radius);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  box-shadow: var(--shadow);
}

/* Responsive */
@media (max-width: 1100px) {
  .wrap {
    grid-template-columns: 1fr;
    grid-auto-rows: minmax(0, auto);
  }
}

/* =====================
   Typography
===================== */
h3 {
  margin: 6px 0 10px;
  font-size: 14px;
  font-weight: 600;
}

.small {
  font-size: 13px;
  color: var(--text-muted);
}

.mini {
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Controls
===================== */
input[type=text],
input[type=number],
input[type=range],
select,
textarea {
  width: 100%;
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-light);
  background: rgba(255,255,255,0.02);
  color: inherit;
  box-sizing: border-box;
}

button {
  background: var(--accent);
  border: none;
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: opacity .2s ease;
}
button:hover {
  opacity: 0.9;
}

button.ghost {
  background: transparent;
  border: 1px dashed var(--border-light);
  color: var(--text-muted);
}
button.ghost:hover {
  color: #fff;
  border-color: var(--accent);
}

/* =====================
   Lists & Items
===================== */
.list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: var(--glass);
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-soft);
}

.item .left {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.badge {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Result cards
===================== */
.path-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.path {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  align-items: flex-start;
  padding: 8px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
}

.path .left {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* =====================
   Diagram panel
===================== */
.uml {
  overflow-x: auto;
  overflow-y: hidden;
  min-height: 260px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius);
  padding: 8px;
}

/* =====================
   Simulation visual markers
===================== */
.sim-pulse {
  box-shadow: 0 0 0 3px rgba(59,130,246,0.35) !important;
}

/* nice scrolling everywhere */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.12);
  border-radius: 8px;
}
::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.22);
}

/* small fade hover on list items */
.item:hover,
.path:hover {
  background: rgba(255,255,255,0.04);
}

/* =====================
   Playback
===================== */
/* Playback disabled look */
#playbackRow.is-disabled {
  opacity: 0.45;
  filter: grayscale(0.6);
  pointer-events: none; /* clicks blocked while disabled */
}

/* Align items inside attacker/target/vulnerability lists */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#panelEntities .list > div {
  display: flex;
  flex-direction: column;
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  padding: 10px 12px;
  position: relative;
}

/* Force actions to right side — horizontally aligned */
#panelEntities .list > div button {
  align-self: flex-end; /* right-align actions */
  margin-top: 6px;      /* spacing from text */
}

/* Ensure Rename and Delete align together nicely */
#panelEntities .list > div button + button {
  margin-left: 8px;
}

/* ===============================
   Compact lists in the left panel
==================================== */

#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;                 /* space between cards */
}

#panelEntities .list > div {
  position: relative;        /* required to position the buttons on the right */
  padding: 12px 180px 12px 14px; /* space reserved on the right for the buttons */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* Title + meta on a single line when possible */
#panelEntities .list > div > div {
  display: inline;           /* “Attacker A  Entries: …” stays on the same line */
}

/* Right-aligned buttons, same line, no wrapper needed */
#panelEntities .list > div > button:nth-last-of-type(2) {
  position: absolute;
  top: 12px;
  right: 96px;               /* positions the “Rename” button to the left of Delete */
}
#panelEntities .list > div > button:last-of-type {
  position: absolute;
  top: 12px;
  right: 14px;               /* “Delete” button on the far right */
}

/* Small visual adjustments */
#panelEntities .list > div > button {
  margin: 0;                 /* removes vertical margin that added unnecessary spacing */
}

/* === Left panel list cards: full width, no squeeze === */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Carte = grid: [contenu flexible] [Rename] [Delete]  */
#panelEntities .list > div {
  display: grid;
  grid-template-columns: 1fr auto auto; /* contenu prend toute la largeur */
  align-items: start;
  gap: 10px;
  padding: 12px;                /* ← plus de padding droit réservé */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
  position: static;             /* ← plus d'absolu */
}

/* Colonne contenu = prend tout l'espace  */
#panelEntities .list > div .left {
  grid-column: 1 / 2;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  min-width: 0;                 /* ← autorise l'expansion */
}

/* Les deux boutons sur la droite, alignés en haut */
#panelEntities .list > div > button {
  position: static;             /* ← supprime l'absolu */
  align-self: start;
  margin: 0;
}
#panelEntities .list > div > button:nth-last-of-type(2) { grid-column: 2 / 3; }
#panelEntities .list > div > button:last-of-type       { grid-column: 3 / 4; }

/* Ajustements de texte/badges pour éviter les colonnes étroites */
#panelEntities .list .badge { display: inline-block; }
#panelEntities .list .mini  { white-space: normal; word-break: break-word; }

/* Optionnel: cartes génériques .item → s'étirent aussi */
.item {
  display: grid;
  grid-template-columns: 1fr auto; /* contenu + actions */
  align-items: start;
  gap: 10px;
}
.item .left { min-width: 0; }

@media (max-width: 520px) {
  #panelEntities .list > div {
    grid-template-columns: 1fr;    /* contenu pleine largeur */
  }
  #panelEntities .list > div > button {
    grid-column: 1 / -1;           /* boutons passent dessous */
    justify-self: end;
  }
}

/* === Left panel: cartes pleine largeur, contenu fluide === */

/* 1) Annule les anciens hacks (inline/absolute/padding réservé) */
#panelEntities .list > div > div { display: block !important; }
#panelEntities .list > div > button { position: static !important; }
#panelEntities .list > div { padding-right: 12px !important; }

/* 2) La carte .item devient une grid: [contenu][Rename][Delete] */
#panelEntities .list .item {
  display: grid !important;
  grid-template-columns: 1fr auto auto;   /* contenu prend tout, boutons autos */
  align-items: start;
  gap: 12px;
  padding: 12px;
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* 3) Colonne contenu: laisse respirer le texte */
#panelEntities .list .item .left {
  min-width: 0;            /* autorise l’expansion */
  display: flex;
  flex-direction: column;  /* badge au-dessus, mini dessous */
  gap: 6px;
}

/* 4) Texte des "mini" non étriqué */
#panelEntities .list .mini {
  white-space: normal;     /* pas de contrainte inline */
  word-break: break-word;
  line-height: 1.25;
}

/* 5) Groupe de boutons alignés à droite sans chevauchement */
#panelEntities .list .item > div:last-child {
  display: flex;
  gap: 8px;
  align-items: start;
}

/* Option mobile: empile les boutons sous le contenu */
@media (max-width: 560px) {
  #panelEntities .list .item {
    grid-template-columns: 1fr;
  }
  #panelEntities .list .item > div:last-child {
    justify-self: end;
  }
}


===== ./index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ENVULN — Threat Path Explorer</title>
  <link rel="stylesheet" href="./styles/app.css">
</head>

<body>
<div class="wrap">

  <!-- LEFT PANEL — Add + Manage Entities -->
  <div class="panel" id="panelEntities">
    <h3>Add & Manage</h3>
    <div class="small">Add, rename, or delete entities here.</div>

    <!-- Add forms -->
    <div class="form-block">
      <label>New attacker</label>
      <div class="row">
        <input id="attackerName" placeholder="Attacker name">
        <button id="btnAddAttacker">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New target</label>
      <div class="row">
        <input id="targetName" placeholder="Target name">
        <button id="btnAddTarget">Add</button>
      </div>
    </div>

    <div class="form-block">
      <label>New vulnerability</label>
      <div class="row">
        <input id="vulnName" placeholder="Vulnerability name">
        <button id="btnAddVuln">Add</button>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnResetAll" class="ghost">Reset all</button>
    </div>

    <hr>

    <!-- Entity Lists -->
    <h3>Attackers</h3>
    <div id="attackerList" class="list"></div>

    <h3>Attacker targets</h3>
    <div id="targetList" class="list"></div>

    <h3>Vulnerabilities</h3>
    <div id="vulnList" class="list"></div>
  </div>

  <!-- CENTER PANEL — Associations / Compute / Results -->
  <div class="panel" id="panelAssociations">
    <h3>Configuration & Exploration</h3>

    <div class="row ceiling-row">
      <!-- (Simulation speed and Path limit moved to the right panel) -->
    </div>

    <hr>

    <!-- Attacker selection -->
    <h3>Attacker selection</h3>
    <div class="small">Choose the current attacker.</div>
    <div class="row">
      <select id="selAttacker"></select>
    </div>

    <hr>

    <!-- Entry points selection -->
    <h3>Attacker entry points</h3>
    <div class="small">Select targets that act as entry points for the attacker.</div>
    <div class="row">
      <select id="selEntriesAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearEntries" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Exit points selection -->
    <h3>Attacker exit points</h3>
    <div class="small">Select targets that act as exit points for the attacker.</div>
    <div class="row">
      <select id="selExitsAll" multiple size="6"></select>
    </div>
    <div class="row">
      <button id="btnClearExits" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Vulnerability association -->
    <h3>Vulnerabilities</h3>
    <div class="small">Pick an element, then select/unselect the vulnerabilities to associate.</div>

    <div class="row">
      <div class="col">
        <label>Element to edit</label>
        <select id="selVulnElement">
          <!-- filled by JS -->
        </select>
      </div>

      <div class="col">
        <label>Vulnerabilities (multi)</label>
        <select id="selVulnsForElement" multiple size="6"></select>
      </div>
    </div>

    <div class="row">
      <button id="btnClearVulnSelection" class="ghost">Clear selection</button>
    </div>

    <hr>

    <!-- Links -->
    <h3>Links between targets</h3>
    <div class="row">
      <select id="linkSource"></select>
      <select id="linkDest" multiple size="4"></select>
      <select id="linkType">
        <option value="direct">direct</option>
        <option value="lateral">lateral</option>
        <option value="contains">contains</option>
      </select>
    </div>

    <div class="row">
      <button id="btnClearLinkSelection" class="ghost">Clear selection</button>
    </div>
    <div class="row">
      <label><input type="checkbox" id="includeLateral" checked> include lateral</label>
      <label><input type="checkbox" id="includeContains" checked> include contains</label>
    </div>

    <div id="linksInspector" class="small"></div>

    <hr>

    <!-- Actions -->
    <div class="row top-actions">
      <button id="btnFindPaths">Compute paths</button>
      <button id="btnExportODS" class="ghost">Export ODS</button>
      <button id="btnImportJSON" class="ghost">Import JSON</button>
      <button id="btnExportJSON" class="ghost">Export JSON</button>
      <button id="btnSimu" class="ghost">Simulation</button>
      <input type="file" id="fileIn" accept="application/json" hidden>
      <span id="status" class="small">—</span>
    </div>

    <hr>

    <!-- Results -->
    <h3 style="display:flex;align-items:center;gap:10px">
      Results
      <label class="small" style="display:inline-flex;align-items:center;gap:6px">
        <input type="checkbox" id="chkOnlyVuln">
        Vulnerable paths only
      </label>
    </h3>

    <div id="results" class="path-list"></div>
  </div>

  <!-- RIGHT PANEL — Tutorial + Configuration + Diagram -->
  <div class="panel" id="panelDetailsRight">
    <h3>Tutorial</h3>
    <ol id="tutorial" class="small">
      <li>Add attackers, targets, and vulnerabilities in the left panel.</li>
      <li>Select the current attacker from “Attacker selection”.</li>
      <li>Choose attacker entry points, then use “Clear selection” if needed.</li>
      <li>Choose attacker exit points, then use “Clear selection” if needed.</li>
      <li>Select an element and pick vulnerabilities to associate; use “Clear selection” to reset.</li>
      <li>Configure links between targets; use “Clear selection” to reset the link pickers.</li>
      <li>Adjust path visibility (include lateral/contains) using the checkboxes.</li>
      <li>Click “Compute paths” to generate results.</li>
      <li>Select a path to view the attack diagram.</li>
      <li>Use the playback controls to play, pause, stop, restart, step back, or step forward the simulation.</li>
      <li>Export data as needed (JSON/ODS).</li>
    </ol>

    <hr>

    <!-- Playback controls (above simulation speed) -->
    <div class="row" id="playbackRow" style="justify-content:center;gap:10px">
      <button id="btnStepBack" class="ghost" title="Step back" aria-label="Step back">⏮</button>
      <button id="btnPlayPause" title="Play/Pause" aria-label="Play or pause">▶</button>
      <button id="btnStepForward" class="ghost" title="Step forward" aria-label="Step forward">⏭</button>
      <button id="btnStop" class="ghost" title="Stop" aria-label="Stop">⏹</button>
      <button id="btnRestart" class="ghost" title="Restart" aria-label="Restart">↺</button>
    </div>
    
    <div class="row">
      <div class="col speed-col">
        <label for="simSpeed">Simulation speed</label>
        <input id="simSpeed" type="range" min="0.2" max="3" step="0.1" value="1">
        <span id="simSpeedValue">×1.0</span>
      </div>
    </div>

    <hr>

    <div class="row ceiling-row">
      <label for="maxPaths">Path limit</label>
      <input type="number" id="maxPaths" min="100" value="2000">
    </div>

    <hr>

    <h3>Attack diagram</h3>
    <div id="diagramBox" class="uml"><div class="small">Select a path → Diagram</div></div>

    <div class="row">
      <button id="btnDownloadSVG" class="ghost">Download SVG</button>
      <span id="svgSize" class="small">—</span>
    </div>
  </div>

</div>

<script type="module" src="./js/main.js"></script>
</body>
</html>

===== ./js/ui/links.js =====
// js/ui/links.js
// UI logic for managing links between targets using the selectors present in the page.

import { State, ensureEdgeMaps } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

/* =========================
   Internal helpers
========================= */

function nameOfTarget(id) {
  const t = State.targets.find(x => x.id === id);
  return t ? t.name : '?';
}

function getLinkMapByType(type) {
  if (type === 'direct')   return State.edges.direct;
  if (type === 'lateral')  return State.edges.lateral;
  if (type === 'contains') return State.edges.contains;
  return null;
}

function addLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map) return;
  ensureEdgeMaps(from);
  map[from].add(to);
}

function removeLink(type, from, to) {
  const map = getLinkMapByType(type);
  if (!map || !map[from]) return;
  map[from].delete(to);
}

function clearAndFillSelect(selectEl, items) {
  selectEl.innerHTML = '';
  items.forEach(({ id, name }) => {
    const o = document.createElement('option');
    o.value = id;
    o.textContent = name;
    selectEl.appendChild(o);
  });
}

/* =========================
   Populate selectors
========================= */

export function populateLinkSelectors() {
  const src = el('linkSource');
  const dst = el('linkDest');
  const type = el('linkType');

  if (!src || !dst || !type) return;

  const items = State.targets.map(t => ({ id: t.id, name: t.name }));
  clearAndFillSelect(src, items);
  clearAndFillSelect(dst, items);

  if (!['direct', 'lateral', 'contains'].includes(type.value)) {
    type.value = 'direct';
  }
}

/* =========================
   Links inspector
========================= */

export function renderLinksInspector() {
  const box = el('linksInspector');
  const src = el('linkSource')?.value;

  if (!box) return;

  if (!src) {
    box.innerHTML = '<div class="mini">Pick a source to view its links.</div>';
    return;
  }

  const makeGroup = (label, mapObj, typeKey) => {
    const set = mapObj[src] || new Set();
    const items = Array.isArray(set) ? set : [...set];
    if (!items.length) {
      return `<div style="margin-top:6px"><strong>${label}:</strong> —</div>`;
    }
    const chips = items.map(toId => {
      const tName = nameOfTarget(toId);
      const btn = `<button data-type="${typeKey}" data-to="${toId}" class="ghost" style="padding:2px 6px;border-radius:6px">Remove</button>`;
      return `<span class="badge" style="display:inline-flex;align-items:center;gap:6px;margin:4px 6px 0 0">${tName}${btn}</span>`;
    }).join(' ');
    return `<div style="margin-top:6px"><strong>${label}:</strong><div style="margin-top:4px">${chips}</div></div>`;
  };

  box.innerHTML = [
    `<div class="mini">Links from <strong>${nameOfTarget(src)}</strong> (use "Remove" to delete)</div>`,
    makeGroup('direct',   State.edges.direct,   'direct'),
    makeGroup('lateral',  State.edges.lateral,  'lateral'),
    makeGroup('contains', State.edges.contains, 'contains'),
  ].join('');

  box.onclick = (e) => {
    const btn = e.target.closest('button[data-to]');
    if (!btn) return;
    const type = btn.getAttribute('data-type');
    const to   = btn.getAttribute('data-to');
    removeLink(type, src, to);
    saveToLocal(State);
    renderLinksInspector();
    // Keep the destination multiselect visually in sync
    syncDestSelectionFromState();
  };
}

/* =========================
   Event wiring
========================= */

let _syncDestSelectionFromState = null;
function syncDestSelectionFromState() {
  // late-bound to avoid accessing elements before ready
  if (typeof _syncDestSelectionFromState === 'function') {
    _syncDestSelectionFromState();
  }
}

export function wireLinksUI() {
  const srcSel   = el('linkSource');
  const dstSel   = el('linkDest');
  const typeSel  = el('linkType');
  const btnClear = el('btnClearLinkSelection');

  if (!srcSel || !dstSel || !typeSel) return;

  _syncDestSelectionFromState = () => {
    const from = srcSel.value;
    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    const set = map[from] || new Set();
    const current = new Set(Array.isArray(set) ? set : Array.from(set));
    [...dstSel.options].forEach(o => { o.selected = current.has(o.value); });
    renderLinksInspector();
  };

  srcSel.addEventListener('change', _syncDestSelectionFromState);
  typeSel.addEventListener('change', _syncDestSelectionFromState);

  // Real-time persistence on every change
  dstSel.addEventListener('change', () => {
    const from = srcSel.value;
    if (!from) return;

    const type = typeSel.value;
    const map = getLinkMapByType(type) || {};
    ensureEdgeMaps(from);

    const before = new Set(Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []));
    const after  = new Set([...dstSel.selectedOptions].map(o => o.value));

    for (const to of after) {
      if (!before.has(to)) addLink(type, from, to);
    }
    for (const to of before) {
      if (!after.has(to)) removeLink(type, from, to);
    }

    saveToLocal(State);
    renderLinksInspector();
  });

  // Clear selection button: clears UI and state through the change handler
  if (btnClear) {
    btnClear.onclick = () => {
      [...dstSel.options].forEach(o => o.selected = false);
      dstSel.dispatchEvent(new Event('change', { bubbles: true }));
    };
  }

  populateLinkSelectors();
  _syncDestSelectionFromState();
}

===== ./js/ui/results.js =====
// js/ui/results.js
// Module responsible for rendering computed attack paths (results panel).
// Exports: initResultsPanel, renderResults, computeAndRenderAll, renderDiagramForPath, getLastResults, getLastMeta
// Dependencies: ../helpers.js (el, esc), ../paths.js (computeAllPaths), ../diagram.js (buildSVGForPath), ../state.js (State)

import { el, esc } from '../helpers.js';
import { computeAllPaths } from '../paths.js';
import { buildSVGForPath } from '../diagram.js';
import { State } from '../state.js';
import { exportODS } from '../exportODS.js'; // optional: if you implemented exporter

// Internal cache
let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

// UI element references (populated on init)
let resultsBox = null;
let chkOnlyVuln = null;
let statusEl = null;
let svgContainer = null;
let svgSizeEl = null;
let downloadSvgBtn = null;

/* ---------- UTIL ---------- */
// By design, we ignore the *first* node of the path for the vuln-everywhere filter,
// because entry nodes often don't carry a vulnerability in the model.
const hasVulnsEverywhere = (path) => {
  if (!Array.isArray(path.vulnsPerNode)) return false;
  const slice = path.vulnsPerNode.slice(1);
  if (!slice.length) return false;
  return slice.every(vs => Array.isArray(vs) && vs.length > 0);
};

const getDisplayResults = () => {
  if (chkOnlyVuln && chkOnlyVuln.checked) {
    return lastResults.filter(hasVulnsEverywhere);
  }
  return lastResults;
};

function renderSummary(count, meta = {}) {
  if (!statusEl) return;
  const parts = [];
  parts.push(`${count} path${count === 1 ? '' : 's'}`);
  if (meta.cycles) parts.push('cycles detected (simple paths)');
  if (meta.truncated) parts.push('truncated by ceiling');
  statusEl.textContent = parts.join(' • ');
}

/* ---------- RENDER RESULTS ---------- */
function renderResults(resultsArray, meta = {}) {
  if (!resultsBox) return;
  // Cache full (unfiltered) set and metadata
  lastResults = Array.isArray(resultsArray) ? resultsArray.slice() : [];
  lastMeta = Object.assign({}, meta);

  // Decide what to display
  const toDisplay = getDisplayResults();

  resultsBox.innerHTML = '';
  if (!toDisplay.length) {
    const empty = document.createElement('div');
    empty.className = 'small';
    const filtered = !!(chkOnlyVuln && chkOnlyVuln.checked);
    empty.textContent = filtered
      ? 'No paths match the “only vulnerable” filter.'
      : 'No paths (check entry points, finals and link types).';
    resultsBox.appendChild(empty);
    renderSummary(0, meta);
    return;
  }

  // Build entries
  toDisplay.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.alignItems = 'flex-start';
    row.style.gap = '10px';
    row.style.padding = '8px';
    row.style.borderRadius = '8px';
    row.style.background = 'rgba(255,255,255,0.02)';

    // Left column: attacker + chain + vulns summary
    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.flexDirection = 'column';
    left.style.gap = '6px';

    const title = document.createElement('div');
    title.innerHTML = `<strong>${esc(p.attacker)}</strong>`;
    left.appendChild(title);

    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.appendChild(chain);

    const vulnSummary = document.createElement('div');
    vulnSummary.className = 'mini';
    vulnSummary.style.fontSize = '12px';
    vulnSummary.style.color = 'var(--muted)';
    vulnSummary.textContent = p.vulnsPerNode.map((vs, i) =>
      vs && vs.length ? `[${p.nodes[i].name}: ${vs.join(', ')}]` : `[${p.nodes[i].name}: —]`
    ).join(' ');
    left.appendChild(vulnSummary);

    // Optionally grey-out impossible paths
    if (!hasVulnsEverywhere(p)) {
      row.style.opacity = '0.72';
      row.title = 'One or more targets have no vulnerabilities (path theoretically impossible)';
    }

    // Right column: actions
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.flexDirection = 'column';
    right.style.gap = '6px';
    right.style.alignItems = 'flex-end';

    const btnDiagram = document.createElement('button');
    btnDiagram.textContent = 'Diagram';
    btnDiagram.className = 'ghost';
    btnDiagram.onclick = () => {
      renderDiagramForPath(p);
      // focus diagram in UI
      if (svgContainer) svgContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
    };

    const btnZoom = document.createElement('button');
    btnZoom.textContent = 'Zoom';
    btnZoom.className = 'ghost';
    btnZoom.onclick = () => {
      // If a diagram is already rendered for this path, try to center it
      if (svgContainer) {
        svgContainer.style.boxShadow = '0 0 0 4px rgba(59,130,246,0.18)';
        setTimeout(() => svgContainer.style.boxShadow = 'none', 800);
      }
    };

    right.appendChild(btnDiagram);
    right.appendChild(btnZoom);

    row.appendChild(left);
    row.appendChild(right);
    resultsBox.appendChild(row);
  });

  renderSummary(toDisplay.length, meta);
}

/* ---------- DIAGRAM rendering + download ---------- */
function renderDiagramForPath(pathObj) {
  if (!svgContainer) return;
  try {
    // Pass live State so the builder can resolve entries, edge types, etc.
    const svgStr = buildSVGForPath(pathObj, State);
    svgContainer.innerHTML = svgStr;

    // store last svg for download
    const svgEl = svgContainer.querySelector('svg');
    if (svgEl) {
      // update size display (if provided)
      if (svgSizeEl) {
        const w = svgEl.getAttribute('width') || svgEl.viewBox?.baseVal?.width || svgEl.getBoundingClientRect().width;
        const h = svgEl.getAttribute('height') || svgEl.viewBox?.baseVal?.height || svgEl.getBoundingClientRect().height;
        svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
      }
      // attach download helper
      if (downloadSvgBtn) {
        downloadSvgBtn.onclick = () => {
          const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
          const ts = new Date().toISOString().replace(/[:.]/g, '-');
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `attack-diagram-${ts}.svg`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(a.href), 0);
        };
      }
    }
  } catch (err) {
    console.error('renderDiagramForPath:', err);
    if (svgContainer) svgContainer.innerHTML = `<div class="small">Failed to render diagram: ${esc(String(err))}</div>`;
  }
}

/* ---------- Compute (bridge to paths.js) ---------- */
async function computeAndRenderAll(state, opts = { includeLateral: true, includeContains: true, maxPaths: 2000 }) {
  // computeAllPaths returns an object { paths, cycles, truncated }
  const out = computeAllPaths(state, opts, opts.maxPaths);
  const arr = Array.isArray(out?.paths) ? out.paths : [];

  // ensure normalized shape: nodes are target objects and vulnsPerNode array exists
  const normalized = arr.map(r => {
    return {
      attacker: r.attackerName || r.attacker || r.attackerId || '',
      attackerId: r.attackerId || '',
      nodes: r.nodes || (r.nodeIds || []).map(id => ({ id, name: id })), // fallback
      vulnsPerNode: Array.isArray(r.vulnsPerNode) ? r.vulnsPerNode : (r.nodes ? r.nodes.map(() => []) : [])
    };
  });

  const meta = { cycles: !!out.cycles, truncated: !!out.truncated };

  // render
  renderResults(normalized, meta);
  return normalized;
}

/* ---------- Initialization ---------- */
function initResultsPanel(opts = {}) {
  resultsBox = el(opts.resultsBoxId || 'results');
  chkOnlyVuln = el(opts.chkOnlyVulnId || 'chkOnlyVuln');
  statusEl = el(opts.statusId || 'status');
  svgContainer = el(opts.svgContainerId || 'diagramBox');
  svgSizeEl = el(opts.svgSizeId || 'svgSize');
  downloadSvgBtn = el(opts.downloadSvgBtnId || 'btnDownloadSVG');

  // bind checkbox to re-render current cache
  if (chkOnlyVuln) {
    chkOnlyVuln.addEventListener('change', () => {
      renderResults(getDisplayResults(), lastMeta);
    });
  }

  // wire export ODS (if exporter present)
  const exportBtn = el(opts.exportOdsBtnId || 'btnExportODS');
  if (exportBtn && typeof exportODS === 'function') {
    exportBtn.addEventListener('click', () => {
      // Use filtered display results if checkbox on, else use full
      const toExport = chkOnlyVuln && chkOnlyVuln.checked ? getDisplayResults() : lastResults;
      if (!toExport || !toExport.length) return alert('No paths to export.');
      exportODS(State, { results: toExport });
    });
  }
}

/* ---------- accessors for other modules / app -------- */
function getLastResults() { return lastResults.slice(); }
function getLastMeta() { return Object.assign({}, lastMeta); }

export {
  initResultsPanel,
  renderResults,
  computeAndRenderAll,
  renderDiagramForPath,
  getLastResults,
  getLastMeta
};

===== ./js/ui/editors.js =====
// js/ui/editors.js
// Editor UI module: target editor, attacker editor, details panel
// Imports expected from the modular structure:
//  - State (singleton) from ../state.js
//  - saveToLocal(state) from ../storage.js
//  - helpers: el, norm
//
// The module emits `document.dispatchEvent(new CustomEvent('state:changed'))`
// after any mutation so other UI modules can re-render.

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el, norm } from '../helpers.js';

function emitChange() {
  try { saveToLocal(State); } catch (e) { console.warn('save failed', e); }
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------- Target editor (vulns / final flag) ---------- */
export function renderTargetEditor(targetId) {
  const details = el('details');
  if (!details) return;

  const target = State.targets.find(t => t.id === targetId);
  if (!target) {
    details.innerHTML = `<div class="small">Select a target to edit its vulnerabilities and properties.</div>`;
    return;
  }

  // Build editor UI
  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  // Header: name + rename button
  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(target.name)}</strong>`;
  const headerRow = document.createElement('div');
  headerRow.className = 'row';
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename target', target.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    // check duplicates
    if (State.targets.some(t => t.name.toLowerCase() === n.toLowerCase() && t.id !== target.id)) return alert('Name already used');
    target.name = n;
    emitChange();
  };
  const finalLabel = document.createElement('label');
  finalLabel.className = 'small';
  finalLabel.style.display = 'inline-flex';
  finalLabel.style.alignItems = 'center';
  finalLabel.style.gap = '8px';
  const finalCb = document.createElement('input');
  finalCb.type = 'checkbox';
  finalCb.checked = !!target.final;
  finalCb.onchange = () => {
    target.final = finalCb.checked;
    emitChange();
  };
  finalLabel.append(finalCb, document.createTextNode(' Final flag'));
  headerRow.append(header, finalLabel, renameBtn);
  wrapper.appendChild(headerRow);

  // Vulnerabilities editor
  const vLabel = document.createElement('div');
  vLabel.className = 'small';
  vLabel.textContent = 'Vulnerabilities (check all that apply)';
  wrapper.appendChild(vLabel);

  const vulnBox = document.createElement('div');
  vulnBox.className = 'col';
  vulnBox.style.marginTop = '6px';

  // For each global vulnerability, show checkbox
  State.vulns.forEach(v => {
    const lab = document.createElement('label');
    lab.className = 'small';
    lab.style.display = 'flex';
    lab.style.alignItems = 'center';
    lab.style.gap = '8px';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    const currentVulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    cb.checked = currentVulns.has(v.id);
    cb.onchange = () => {
      target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
      if (cb.checked) target.vulns.add(v.id);
      else target.vulns.delete(v.id);
      emitChange();
    };
    const span = document.createElement('span');
    span.textContent = v.name;
    lab.append(cb, span);
    vulnBox.appendChild(lab);
  });

  // Add quick "add new vuln" line
  const addVRow = document.createElement('div');
  addVRow.className = 'row';
  addVRow.style.marginTop = '6px';
  const inputNewV = document.createElement('input');
  inputNewV.type = 'text';
  inputNewV.placeholder = 'New vulnerability name';
  inputNewV.style.flex = '1';
  const addVBtn = document.createElement('button');
  addVBtn.textContent = 'Add & attach';
  addVBtn.onclick = () => {
    const name = norm(inputNewV.value);
    if (!name) return alert('Name required');
    // avoid duplicate vulnerability names
    if (State.vulns.some(x => x.name.toLowerCase() === name.toLowerCase())) {
      // attach existing vuln if present
      const existing = State.vulns.find(x => x.name.toLowerCase() === name.toLowerCase());
      if (existing) {
        target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
        target.vulns.add(existing.id);
        inputNewV.value = '';
        emitChange();
        return;
      }
      return;
    }
    // create new vuln id and add globally
    const id = (Date.now().toString(36) + Math.random().toString(36).slice(2,6));
    State.vulns.push({ id, name });
    // attach to target
    target.vulns = target.vulns instanceof Set ? target.vulns : new Set(target.vulns || []);
    target.vulns.add(id);
    inputNewV.value = '';
    emitChange();
  };
  addVRow.append(inputNewV, addVBtn);

  wrapper.appendChild(vulnBox);
  wrapper.appendChild(addVRow);

  // Links quick view (read-only summary)
  const linksLabel = document.createElement('div');
  linksLabel.className = 'small';
  linksLabel.style.marginTop = '10px';
  linksLabel.textContent = 'Outgoing links (summary)';
  wrapper.appendChild(linksLabel);

  const linksSummary = document.createElement('div');
  linksSummary.className = 'small';
  linksSummary.style.marginTop = '6px';
  // summarise by type
  const outDirect = (State.edges.direct[target.id] || new Set());
  const outLat = (State.edges.lateral[target.id] || new Set());
  const outContains = (State.edges.contains[target.id] || new Set());
  linksSummary.innerHTML = `
    <div><strong>Direct:</strong> ${[...outDirect].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Lateral:</strong> ${[...outLat].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
    <div><strong>Contains:</strong> ${[...outContains].map(id => (State.targets.find(t => t.id === id) || {name:'?'}).name).join(', ') || '—'}</div>
  `;
  wrapper.appendChild(linksSummary);

  // put everything in details
  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Attacker editor (entries multi-select) ---------- */
export function renderAttackerEditor(attackerId) {
  const details = el('details');
  if (!details) return;

  const attacker = State.attackers.find(a => a.id === attackerId);
  if (!attacker) {
    details.innerHTML = `<div class="small">Select an attacker to edit its entry points.</div>`;
    return;
  }

  const wrapper = document.createElement('div');
  wrapper.className = 'col';

  const header = document.createElement('div');
  header.innerHTML = `<strong>${escapeHtml(attacker.name)}</strong>`;
  const renameBtn = document.createElement('button');
  renameBtn.textContent = 'Rename';
  renameBtn.onclick = () => {
    const newName = prompt('Rename attacker', attacker.name);
    if (newName === null) return;
    const n = norm(newName);
    if (!n) return alert('Invalid name');
    if (State.attackers.some(x => x.name.toLowerCase() === n.toLowerCase() && x.id !== attacker.id)) return alert('Name already used');
    attacker.name = n;
    emitChange();
  };
  header.appendChild(renameBtn);
  wrapper.appendChild(header);

  // Entries multi-select
  const lbl = document.createElement('div');
  lbl.className = 'small';
  lbl.textContent = 'Entry points (select one or many from targets below)';
  wrapper.appendChild(lbl);

  const sel = document.createElement('select');
  sel.id = 'editorEntriesSelect';
  sel.multiple = true;
  sel.size = Math.min(10, Math.max(6, State.targets.length));
  sel.style.width = '100%';

  // Normalize attacker.entries to a Set before checking membership
  const entriesSet = attacker.entries instanceof Set ? attacker.entries : new Set(attacker.entries || []);

  State.targets.forEach(t => {
    const o = document.createElement('option');
    o.value = t.id;
    o.textContent = t.name;
    o.selected = entriesSet.has(t.id);
    sel.appendChild(o);
  });

  sel.onchange = () => {
    const picked = [...sel.selectedOptions].map(o => o.value);
    attacker.entries = new Set(picked);
    emitChange();
  };

  wrapper.appendChild(sel);

  // Quick helpers: select all / none
  const btnRow = document.createElement('div');
  btnRow.className = 'row';
  const btnAll = document.createElement('button');
  btnAll.textContent = 'Select all';
  btnAll.onclick = () => {
    for (const o of sel.options) { o.selected = true; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  const btnNone = document.createElement('button');
  btnNone.textContent = 'Select none';
  btnNone.className = 'ghost';
  btnNone.onclick = () => {
    for (const o of sel.options) { o.selected = false; }
    sel.dispatchEvent(new Event('change', { bubbles: true }));
  };
  btnRow.append(btnAll, btnNone);
  wrapper.appendChild(btnRow);

  details.innerHTML = '';
  details.appendChild(wrapper);
}

/* ---------- Helpers & init ---------- */
function escapeHtml(s) {
  return String(s||'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
}

/**
 * Re-render whichever details panel is relevant to the current selection.
 * If a target is selected, render the target editor; otherwise, if an attacker is
 * selected, render the attacker editor. If nothing is selected, clear the panel.
 */
export function hydrateDetailsPanel() {
  const details = el('details');
  if (!details) return;

  const selTarget = el('selectTarget') || el('linkSource');
  const selAttacker = el('selAttacker');

  if (selTarget && selTarget.value) {
    renderTargetEditor(selTarget.value);
    return;
  }
  if (selAttacker && selAttacker.value) {
    renderAttackerEditor(selAttacker.value);
    return;
  }
  details.innerHTML = `<div class="small">Select an attacker or target to edit.</div>`;
}

/**
 * initEditors
 * - wires main high-level editor controls: when selectAttacker changes, render attacker editor;
 *   when selectTarget changes, render target editor.
 * - listens to global `state:changed` to re-populate selects (targets / vulns) so editors remain live.
 */
export function initEditors() {
  // populate initial selects in the central UI if they exist
  const selAttacker = el('selAttacker');
  const selTarget = el('selectTarget') || el('linkSource'); // support both naming conventions
  // When attacker selection changes, present attacker editor
  if (selAttacker) {
    selAttacker.onchange = () => {
      renderAttackerEditor(selAttacker.value);
    };
  }

  // When target selection changes, present target editor
  if (selTarget) {
    selTarget.onchange = () => {
      renderTargetEditor(selTarget.value);
    };
  }

  // when global state changes, re-populate selects so editors remain in sync
  document.addEventListener('state:changed', () => {
    // re-fill attacker select
    if (selAttacker) {
      const cur = selAttacker.value;
      selAttacker.innerHTML = '';
      State.attackers.forEach(a => {
        const o = document.createElement('option');
        o.value = a.id; o.textContent = a.name;
        selAttacker.appendChild(o);
      });
      if (State.attackers.some(a=>a.id===cur)) selAttacker.value = cur;
    }
    // re-fill central target selects used by UI
    const selTargets = [ 'selectTarget', 'linkSource', 'linkDest', 'selEntriesAll', 'selectStartPool' ];
    selTargets.forEach(id => {
      const s = el(id);
      if (!s) return;
      const prev = s.value;
      const selectedValues = [...(s.selectedOptions || [])].map(o => o.value);
      s.innerHTML = '';
      State.targets.forEach(t => {
        const o = document.createElement('option'); o.value = t.id; o.textContent = t.name;
        // re-select previously selected items if still present
        if (selectedValues.includes(o.value)) o.selected = true;
        s.appendChild(o);
      });
      if (prev && [...s.options].some(o => o.value === prev)) s.value = prev;
    });

    // If there is a currently rendered details editor, re-render it to reflect vulnerabilities and flags
    hydrateDetailsPanel();
  });

  // initial population in case DOM is already ready
  document.dispatchEvent(new CustomEvent('state:changed'));
}

===== ./js/ui/lists.js =====
// js/ui/lists.js
// Utilities and renderers for side lists and central selectors.

import { State, deleteAttacker, deleteTarget, deleteVuln } from '../state.js';
import { saveToLocal } from '../storage.js';
import { el } from '../helpers.js';

import { hydrateDetailsPanel } from './editors.js';
import { renderLinksInspector as _renderLinksInspector } from './links.js';
import { renderResults } from './results.js';

/* ---------------------------------------------------------- */
/* Small DOM helpers                                           */
/* ---------------------------------------------------------- */
function createButton(label, onClick, ghost = false){
  const b = document.createElement('button');
  b.textContent = label;
  b.className = ghost ? 'ghost' : '';
  b.onclick = onClick;
  return b;
}

function badge(text){
  const d = document.createElement('div');
  d.className = 'badge';
  d.textContent = text;
  return d;
}

function mini(text){
  const d = document.createElement('div');
  d.className = 'mini';
  d.textContent = text;
  return d;
}

function emitStateChanged() {
  try { saveToLocal(State); } catch(e) {}
  document.dispatchEvent(new CustomEvent('state:changed'));
}

/* ---------------------------------------------------------- */
/* setOptions : peuple un <select> et conserve la sélection    */
/* - Si `selected` est fourni (Set), il est prioritaire.       */
/* - Sinon on restaure la sélection précédente (multi/single). */
/* ---------------------------------------------------------- */
export function setOptions(
  selectEl,
  items,
  { getValue = x => x.id, getLabel = x => x.name, selected = null } = {}
){
  if(!selectEl) return;

  const wasMultiple = !!selectEl.multiple;

  // capture sélection courante
  const prevSelected = wasMultiple
    ? new Set([...selectEl.selectedOptions].map(o => String(o.value)))
    : new Set(selectEl.value ? [String(selectEl.value)] : []);

  const prevValue = selectEl.value;

  // rebuild
  selectEl.innerHTML = '';
  (items || []).forEach(item => {
    const val = String(getValue(item));
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = String(getLabel(item));

    // priorité: selected (fourni) > sélection précédente
    if (selected instanceof Set) {
      opt.selected = selected.has(val);
    } else if (prevSelected.has(val)) {
      opt.selected = true;
    }

    selectEl.appendChild(opt);
  });

  // pour les selects non-multiples, restaurer la value si possible
  if (!wasMultiple && prevValue && [...selectEl.options].some(o => o.value === prevValue)) {
    selectEl.value = prevValue;
  }
}

/* ---------------------------------------------------------- */
/* Side panel : ATTACKERS                                     */
/* ---------------------------------------------------------- */
export function renderAttackers(){
  const container = el('attackerList');
  if(!container) return;
  container.innerHTML = '';

  (State.attackers || []).forEach(a => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    const entries = a.entries instanceof Set ? a.entries : new Set(a.entries || []);
    left.appendChild(badge(a.name));
    left.appendChild(mini(`Entries: ${[...entries].map(id => {
      const t = (State.targets || []).find(x => x.id === id);
      return t ? t.name : '?';
    }).join(', ') || '—'}`));

    const right = document.createElement('div');

    // rename
    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename attacker', a.name);
      if(!name) return;
      a.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    // delete
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete attacker?')){
        deleteAttacker(a.id);
        emitStateChanged();
        renderAllLists();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : TARGETS                                       */
/* ---------------------------------------------------------- */
export function renderTargets(){
  const container = el('targetList');
  if(!container) return;
  container.innerHTML = '';

  (State.targets || []).forEach(t => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';

    left.appendChild(badge(t.name));

    const vulnsSet = t.vulns instanceof Set ? t.vulns : new Set(t.vulns || []);
    left.appendChild(mini(`Vulns: ${
      [...vulnsSet].map(id => (State.vulns || []).find(v => v.id === id)?.name || '?').join(', ') || '—'
    }`));

    const right = document.createElement('div');

    right.appendChild(createButton('Rename', () => {
      const name = prompt('Rename target', t.name);
      if(!name) return;
      t.name = name;
      emitStateChanged();
      renderAllLists();
    }));

    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete target?')){
        deleteTarget(t.id);
        emitStateChanged();
        renderAllLists();
        renderLinksInspector();
        renderResults([]);
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Side panel : VULNERABILITIES                               */
/* ---------------------------------------------------------- */
export function renderVulns(){
  const container = el('vulnList');
  if(!container) return;
  container.innerHTML = '';

  (State.vulns || []).forEach(v => {
    const row = document.createElement('div');
    row.className = 'item';

    const left = document.createElement('div');
    left.className = 'left';
    left.appendChild(badge(v.name));

    const right = document.createElement('div');
    right.appendChild(createButton('Delete', () => {
      if(confirm('Delete vulnerability?')){
        deleteVuln(v.id);
        emitStateChanged();
        renderAllLists();
        hydrateDetailsPanel();
      }
    }, true));

    row.append(left, right);
    container.appendChild(row);
  });
}

/* ---------------------------------------------------------- */
/* Re-render lists globally                                   */
/* ---------------------------------------------------------- */
export function renderAllLists(){
  renderAttackers();
  renderTargets();
  renderVulns();
  hydrateDetailsPanel();
}

/* ---------------------------------------------------------- */
/* Populate ALL selectors (menus)                             */
/* ---------------------------------------------------------- */
export function populateSelectors(state = State){
  setOptions(el('selAttacker'), state.attackers || []);

  setOptions(el('selEntriesAll'), state.targets || []);
  setOptions(el('selExitsAll'),   state.targets || []);

  setOptions(el('linkSource'), state.targets || []);
  setOptions(el('linkDest'),   state.targets || []);

  hydrateEntriesSelect(state);
  hydrateExitsSelect(state);
  hydrateVulnSelectors(state);

  renderLinksInspector();
}

/* ---------------------------------------------------------- */
/* Hydrate Entries (multi)                                    */
/* ---------------------------------------------------------- */
export function hydrateEntriesSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selEntriesAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.entries ? [...att.entries].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Exits (multi)                                      */
/* ---------------------------------------------------------- */
export function hydrateExitsSelect(state = State){
  const selAtt = el('selAttacker');
  const sel = el('selExitsAll');
  if(!selAtt || !sel) return;

  const att = (state.attackers || []).find(a => String(a.id) === String(selAtt.value));
  const selected = new Set(att?.exits ? [...att.exits].map(String) : []);
  [...sel.options].forEach(o => { o.selected = selected.has(o.value); });
}

/* ---------------------------------------------------------- */
/* Hydrate Vulns (multi, persist visuellement)                */
/* ---------------------------------------------------------- */
export function hydrateVulnSelectors(state = State){
  const selT = el('selVulnElement');
  const selV = el('selVulnsForElement');
  if(!selT || !selV) return;

  // (1) cibles
  setOptions(selT, state.targets || []);

  // (2) vulns de la cible courante
  const t = (state.targets || []).find(x => String(x.id) === String(selT.value));
  const current = t ? (t.vulns instanceof Set ? t.vulns : new Set(t.vulns || [])) : new Set();
  const selected = new Set([...current].map(String));

  setOptions(selV, state.vulns || [], { selected });
}

/* ---------------------------------------------------------- */
/* Re-export                                                  */
/* ---------------------------------------------------------- */
export const renderLinksInspector = _renderLinksInspector;

===== ./js/simulation/scenarios.js =====
/* =========================================================
   simulation/scenarios.js
   Scénarios "humains" : chaque lien est créé via un vrai clic
   sur le bouton Add Link, puis la sélection est nettoyée pour
   éviter les boucles infinies.
   ========================================================= */

import { registerScenario, g } from './index.js';

// --- ROBUST LINK COMMIT: bypass UI and write directly into State ---
import * as StateMod from '../state.js';
import { saveToLocal } from '../storage.js';
import { renderLinksInspector } from '../ui/links.js';

window.humanCommitLinks = async function humanCommitLinks(fromName, toNames = [], type = 'direct') {
  const map = new Map(StateMod.State.targets.map(t => [t.name.toLowerCase(), t.id]));
  const fromId = map.get(String(fromName).toLowerCase());
  const toIds  = (toNames || []).map(n => map.get(String(n).toLowerCase())).filter(Boolean);

  if (!fromId || !toIds.length) return;

  // add edges directly; no DOM select / no virtual cursor
  toIds.forEach(to => StateMod.addEdge(type, fromId, to));

  try { saveToLocal(StateMod.State); } catch {}
  try { renderLinksInspector(); } catch {}
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
};

/* ---------------------------------------------------------
   Helpers: commit *comme un humain*
   --------------------------------------------------------- */

// Compte les arêtes pour détecter "rien n'a changé"
function __edgeCount(state) {
  const E = state?.edges || { direct:{}, lateral:{}, contains:{} };
  const sum = (m) => Object.values(E[m] || {}).reduce((n, s) => n + (s?.size || 0), 0);
  return { d: sum('direct'), l: sum('lateral'), c: sum('contains') };
}

/** Clique le vrai bouton "Add link" si présent, sinon fallback "change". Puis CLEAR la sélection. */
async function clickAddLinkButton() {
  const tryIds = ['btnAddLink','addLink','linkAdd','btnLinkAdd','btn-add-link','action-add-link'];
  let btn = null;
  for (const id of tryIds) { const n = g.el(id); if (n) { btn = n; break; } }

  // snapshot avant
  const S = window.__envuln_boot?.State || window.State;
  const before = __edgeCount(S);

  if (btn) {
    await g.click(btn);
  } else {
    // fallback: déclenchement par change pour UIs sans bouton
    const sel = g.el('linkDest');
    if (sel) sel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // laisser le temps aux handlers d'ajouter les liens
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  await g.wait(40);

  // CLEAR la sélection pour éviter les re-commits infinis
  const destSel = g.el('linkDest');
  if (destSel) {
    [...destSel.options].forEach(o => o.selected = false);
    destSel.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // garde-fou : si rien n'a changé, on n'insiste pas
  const after = __edgeCount(S);
  const delta = (after.d - before.d) + (after.l - before.l) + (after.c - before.c);
  if (delta <= 0) {
    await g.wait(80);
  }
}

/** S'assure du type de lien (direct/lateral/contains) si le select existe. */
async function ensureLinkType(type = 'direct') {
  const selType = g.el('linkType');
  if (!selType) return;
  if (String(selType.value).toLowerCase() === String(type).toLowerCase()) return;
  await g.click(selType);
  await g.wait(40);
  await g.selectByText(selType, type);
  await g.wait(60);
}

/** Commit "humain" : source → type → destinations → Add → CLEAR selection. */
async function humanCommitLinks(fromLabel, toLabels = [], type = 'direct') {
  // source
  await g.selectByText(g.el('linkSource'), fromLabel);
  await g.wait(60);

  // type
  await ensureLinkType(type);

  // destinations
  const destSel = g.el('linkDest');
  if (!destSel) return;
  await g.click(destSel);
  await g.wait(40);
  g.multiSelectByTexts(destSel, toLabels);
  await g.wait(40);

  // commit via bouton (avec clear + vérif delta)
  await clickAddLinkButton();
}

/** Commit de la sélection de vulnérabilités (multi-select change). */
function commitVulnSelection() {
  const sel = g.el('selVulnsForElement');
  if (!sel) return;
  sel.dispatchEvent(new Event('change', { bubbles: true }));
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* Ajouts via la vraie UI */
async function ensureVuln(name) {
  const inp = g.el('vulnName');
  if (!inp) return;
  await g.typeInto(inp, name);
  await g.click(g.el('btnAddVuln'));
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

async function addTarget(label) {
  await g.typeInto(g.el('targetName'), label);
  await g.click(g.el('btnAddTarget'));
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Scénarios (créent explicitement les liens nécessaires)
   --------------------------------------------------------- */

/* 1) Minimal web app chain — Internet LB -> Web Server -> App Server -> Database */
async function scenario_small_webapp() {
  await g.typeInto(g.el('attackerName'), 'Threat Actor — WebApp');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(240);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = ['Internet LB', 'Web Server', 'App Server', 'Database'];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Auth RCE');

  await g.selectByText(g.el('selAttacker'), 'Threat Actor — WebApp');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Database']);
  await g.wait(140);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens
  await humanCommitLinks('Internet LB', ['Web Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('Web Server', ['App Server'], 'direct');
  await g.wait(100);
  await humanCommitLinks('App Server', ['Database'], 'direct');
  await g.wait(120);

  // Vuln
  await g.selectByText(g.el('selVulnElement'), 'Web Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth RCE']);
  commitVulnSelection();
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(420);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 2) Corporate network — plusieurs chemins + lien latéral depuis Mail */
async function scenario_corporate_network() {
  await g.typeInto(g.el('attackerName'), 'APT — Corporate');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const targets = [
    'Internet Gateway', 'Perimeter FW', 'Proxy', 'Mail Server',
    'VPN Gateway', 'Edge VM', 'Internal App', 'DB Cluster', 'Secrets Store'
  ];
  for (const t of targets) await addTarget(t);

  await ensureVuln('Open Port');
  await ensureVuln('Phishing OTP');
  await ensureVuln('Priv Esc');

  await g.selectByText(g.el('selAttacker'), 'APT — Corporate');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Internet Gateway', 'Mail Server']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Secrets Store']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Topologie
  await humanCommitLinks('Internet Gateway', ['Perimeter FW', 'Mail Server'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Perimeter FW', ['Proxy', 'VPN Gateway'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Proxy', ['Edge VM', 'Internal App'], 'direct');
  await g.wait(120);
  await humanCommitLinks('Edge VM', ['Internal App'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Internal App', ['DB Cluster'], 'direct');
  await g.wait(80);
  await humanCommitLinks('DB Cluster', ['Secrets Store'], 'direct');
  await g.wait(100);

  // Lateral : Mail -> Edge VM
  await humanCommitLinks('Mail Server', ['Edge VM'], 'lateral');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Mail Server');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Phishing OTP']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Edge VM');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Open Port']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Internal App');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Priv Esc']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(700);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 3) Cloud containers — direct + contains + chemin vers Backup */
async function scenario_cloud_containers() {
  await g.typeInto(g.el('attackerName'), 'Cloud Operator Bug');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const hosts = ['LB', 'Web Pod', 'App Pod', 'Cache Pod', 'DB Pod', 'Backup Pod'];
  for (const h of hosts) await addTarget(h);

  await ensureVuln('Container Escape');
  await ensureVuln('Unpatched Service');

  await g.selectByText(g.el('selAttacker'), 'Cloud Operator Bug');
  await g.wait(120);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['LB']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Backup Pod']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Flots directs
  await humanCommitLinks('LB', ['Web Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('Web Pod', ['App Pod'], 'direct');
  await g.wait(90);
  await humanCommitLinks('App Pod', ['DB Pod', 'Cache Pod'], 'direct');
  await g.wait(90);

  // Chemin vers exit
  await humanCommitLinks('DB Pod', ['Backup Pod'], 'direct');
  await g.wait(90);

  // Contains (sémantique)
  await humanCommitLinks('App Pod', ['Cache Pod'], 'contains');
  await g.wait(120);

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Web Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Unpatched Service']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'App Pod');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Container Escape']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(650);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 4) IoT/OT dense — Sensors -> Aggregator -> Edge -> Admin -> PLC */
async function scenario_iot_ot_dense() {
  await g.typeInto(g.el('attackerName'), 'Script Kiddie — IoT Wave');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(260);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const devices = [];
  for (let i = 1; i <= 10; i++) {
    const name = `Sensor-${i}`;
    devices.push(name);
    await addTarget(name);
  }
  const core = ['Aggregator', 'Edge Controller', 'Admin Console', 'Historian', 'PLC'];
  for (const c of core) await addTarget(c);

  await ensureVuln('Default Creds');
  await ensureVuln('Telnet Open');
  await ensureVuln('Weak Auth');

  await g.selectByText(g.el('selAttacker'), 'Script Kiddie — IoT Wave');
  await g.wait(120);

  // entries & exits
  g.multiSelectByTexts(g.el('selEntriesAll'), devices.slice(0, 6));
  g.multiSelectByTexts(g.el('selExitsAll'), ['PLC']);
  await g.wait(160);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Liens Sensors -> Aggregator / Edge / Admin
  await humanCommitLinks('Sensor-1', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-2', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-3', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-4', ['Aggregator', 'Edge Controller'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-5', ['Aggregator'], 'direct');
  await g.wait(60);
  await humanCommitLinks('Sensor-6', ['Aggregator', 'Admin Console'], 'direct');
  await g.wait(80);

  await humanCommitLinks('Aggregator', ['Edge Controller'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Edge Controller', ['Admin Console'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Admin Console', ['PLC', 'Historian'], 'direct');
  await g.wait(80);
  await humanCommitLinks('Historian', ['PLC'], 'direct');
  await g.wait(80);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Sensor-2');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Sensor-4');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Default Creds']);
  commitVulnSelection();
  await g.wait(40);

  await g.selectByText(g.el('selVulnElement'), 'Edge Controller');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Telnet Open']);
  commitVulnSelection();
  await g.wait(80);

  await g.selectByText(g.el('selVulnElement'), 'Admin Console');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Weak Auth']);
  commitVulnSelection();
  await g.wait(100);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(900);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* 5) High-connectivity mesh — DAG dense A..G */
async function scenario_high_connectivity_mesh() {
  await g.typeInto(g.el('attackerName'), 'Black Hat — Mesh Experiment');
  await g.click(g.el('btnAddAttacker'));
  await g.wait(220);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  const nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
  for (const n of nodes) await addTarget(`Node ${n}`);

  await ensureVuln('Service X RCE');
  await ensureVuln('Auth Bypass');

  await g.selectByText(g.el('selAttacker'), 'Black Hat — Mesh Experiment');
  await g.wait(100);

  g.multiSelectByTexts(g.el('selEntriesAll'), ['Node A']);
  g.multiSelectByTexts(g.el('selExitsAll'),   ['Node G']);
  await g.wait(120);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // DAG dense: A -> B..G, B -> C..G, etc.
  for (let i = 0; i < nodes.length; i++) {
    const from = `Node ${nodes[i]}`;
    const toList = [];
    for (let j = i + 1; j < nodes.length; j++) toList.push(`Node ${nodes[j]}`);
    if (toList.length) {
      await humanCommitLinks(from, toList, 'direct');
      await g.wait(60);
    }
  }
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Vulns
  await g.selectByText(g.el('selVulnElement'), 'Node B');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Service X RCE']);
  commitVulnSelection();
  await g.wait(50);

  await g.selectByText(g.el('selVulnElement'), 'Node D');
  g.multiSelectByTexts(g.el('selVulnsForElement'), ['Auth Bypass']);
  commitVulnSelection();
  await g.wait(70);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}

  // Compute
  await g.click(g.el('btnFindPaths'));
  await g.wait(1000);
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------------------------------------------------
   Catalogue & enregistrement (un scénario aléatoire)
   --------------------------------------------------------- */

const CATALOG = [
  { name: 'Small webapp chain', fn: scenario_small_webapp },
  { name: 'Corporate network', fn: scenario_corporate_network },
  { name: 'Cloud containers', fn: scenario_cloud_containers },
  { name: 'IoT / OT dense', fn: scenario_iot_ot_dense },
  { name: 'High-connectivity mesh', fn: scenario_high_connectivity_mesh }
];

registerScenario('Random: pick one realistic scenario', async () => {
  const i = Math.floor(Math.random() * CATALOG.length);
  const picked = CATALOG[i];
  try {
    const txt = `Running scenario: ${picked.name}`;
    const statusEl = g.el('status');
    if (statusEl) statusEl.textContent = txt;
    await picked.fn();
  } finally {
    try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
  }
});

===== ./js/simulation/index.js =====
/* =========================================================
   simulation/index.js
   UI-driven simulation with a virtual cursor (mouse gestures)
   Controller supports play / pause / stop / restart /step,
   speed control, and cursor timeline stepping.
   ========================================================= */

import { State } from '../state.js';
import { saveToLocal } from '../storage.js';

const SCENARIOS = [];

/* ---------------- Registry ---------------- */
export function registerScenario(name, fn, weight = 1) {
  SCENARIOS.push({ name, fn, weight: Math.max(0, +weight || 1) });
}

/* ---------------- Global controller state ---------------- */
const CTRL = {
  paused: false,
  stopRequested: false,
  running: false,
  stepArmed: false,   // single-step gate for "step forward"
  speed: 1.0          // 0.2..3.0
};

/* ---------------- Abort helper ---------------- */
function shouldAbort() { return CTRL.stopRequested === true; }

/* ---------------- State snapshot / restore (sandbox) ---------------- */
let _snapshot = null;

function takeSnapshot() {
  try {
    // structuredClone preserves Sets/Maps/Date; good for our State shape.
    _snapshot = structuredClone(State);
  } catch {
    // last resort: shallow rebuild (Sets will still be Sets because current State uses Sets)
    _snapshot = JSON.parse(JSON.stringify({
      version: State.version,
      attackers: State.attackers.map(a => ({
        id: a.id, name: a.name,
        entries: [...a.entries],
        exits:   [...a.exits]
      })),
      targets: State.targets.map(t => ({
        id: t.id, name: t.name,
        vulns: [...t.vulns],
        final: !!t.final
      })),
      edges: {
        direct:   Object.fromEntries(Object.entries(State.edges.direct   || {}).map(([k,v]) => [k, [...v]])),
        lateral:  Object.fromEntries(Object.entries(State.edges.lateral  || {}).map(([k,v]) => [k, [...v]])),
        contains: Object.fromEntries(Object.entries(State.edges.contains || {}).map(([k,v]) => [k, [...v]])),
      }
    }));
    // Rehydrate Sets
    _snapshot.targets.forEach(t => t.vulns = new Set(t.vulns || []));
    _snapshot.attackers.forEach(a => {
      a.entries = new Set(a.entries || []);
      a.exits   = new Set(a.exits   || []);
    });
    for (const m of ['direct','lateral','contains']) {
      for (const k in _snapshot.edges[m]) {
        _snapshot.edges[m][k] = new Set(_snapshot.edges[m][k] || []);
      }
    }
  }
}

function restoreSnapshot() {
  if (!_snapshot) return;

  // Replace State fields in-place (keep same object reference)
  State.version   = _snapshot.version;
  State.attackers = _snapshot.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: new Set(a.entries),
    exits:   new Set(a.exits)
  }));
  State.targets   = _snapshot.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: new Set(t.vulns),
    final: !!t.final
  }));
  State.edges = { direct:{}, lateral:{}, contains:{} };
  for (const m of ['direct','lateral','contains']) {
    for (const k in _snapshot.edges[m]) {
      State.edges[m][k] = new Set(_snapshot.edges[m][k]);
    }
  }

  try { saveToLocal(State); } catch {}
  try { document.dispatchEvent(new CustomEvent('state:changed')); } catch {}
}

/* ---------------- Cursor timeline (for step back/forward) ---------------- */
const TIMELINE = { points: [], idx: -1 };

function timelineClear() { TIMELINE.points.length = 0; TIMELINE.idx = -1; safeUpdateButtons(); }

// last known cursor position (px)
let __lastCursorPos = { x: null, y: null };

// clamp helper
function _clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

// record timeline but ignore invalid/meaningless points and duplicates
function timelineRecord(x, y) {
  // sanitize
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
  // clamp to viewport + small margin
  const margin = 8;
  const px = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth) - margin));
  const py = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  // ignore duplicate consecutive points
  const last = TIMELINE.points.length ? TIMELINE.points[TIMELINE.points.length - 1] : null;
  if (last && last.x === px && last.y === py) {
    TIMELINE.idx = TIMELINE.points.length - 1;
    return;
  }

  const t = performance.now();
  TIMELINE.points.push({ x: px, y: py, t });
  TIMELINE.idx = TIMELINE.points.length - 1;

  // update last known cursor pos
  __lastCursorPos.x = px;
  __lastCursorPos.y = py;

  safeUpdateButtons();
}

function timelineGoto(index) {
  const i = Math.max(0, Math.min(TIMELINE.points.length - 1, index));
  const p = TIMELINE.points[i];
  if (!p) return;
  const c = document.getElementById(CURSOR_ID) || ensureCursor();
  c.style.left = `${p.x}px`;
  c.style.top  = `${p.y}px`;
  TIMELINE.idx = i;
  safeUpdateButtons();
}

/* ---------------- Speed helpers ---------------- */
function readSpeedFromUI() {
  const el = document.getElementById('simSpeed');
  const v = el ? parseFloat(el.value) : 1;
  CTRL.speed = Math.max(0.2, Math.min(3, Number.isFinite(v) ? v : 1));
  const lab = document.getElementById('simSpeedValue');
  if (lab) lab.textContent = `×${CTRL.speed.toFixed(1)}`;
}
readSpeedFromUI();

/* ---------------- Public controls ---------------- */
export function simSetSpeed(mult) { CTRL.speed = Math.max(0.2, Math.min(3, +mult || 1)); }
export function simPlay() { CTRL.paused = false; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simPause(){ CTRL.paused = true;  CTRL.stepArmed = false; safeUpdateButtons(); }
export function simToggle(){ CTRL.paused = !CTRL.paused; CTRL.stepArmed = false; safeUpdateButtons(); }
export function simStop() {
  CTRL.stopRequested = true;
  CTRL.paused = false;     // allow sleepers to exit
  CTRL.stepArmed = false;
  simCleanupUI();          // UI artifacts
}

/* one-step while paused */
export function simStep() { CTRL.stepArmed = true; }

/* step back/forward on cursor timeline (no state mutation) */
export function simStepBack(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.max(0, TIMELINE.idx - Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simStepForward(steps = 10) {
  CTRL.paused = true; CTRL.stepArmed = false;
  if (!TIMELINE.points.length) return;
  const next = Math.min(TIMELINE.points.length - 1, TIMELINE.idx + Math.max(1, steps | 0));
  timelineGoto(next);
}
export function simCanStepBack()    { return TIMELINE.idx > 0; }
export function simCanStepForward() { return TIMELINE.idx >= 0 && TIMELINE.idx < (TIMELINE.points.length - 1); }

/* ---------------- DOM helpers ---------------- */
const $ = (id) => document.getElementById(id);
export function disableTopButtons(disabled = true) {
  ['btnSimu', 'btnFindPaths', 'btnExportODS', 'btnImportJSON', 'btnExportJSON'].forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !!disabled;
  });
}
export function enableTopButtons() { disableTopButtons(false); }
function safeUpdateButtons() { try { window.__updatePlaybackButtons && window.__updatePlaybackButtons(); } catch {} }

/* Sleep that honors pause/step/stop and speed */
function sleep(ms) {
  const base = Math.max(0, +ms || 0);
  const scaled = Math.max(10, Math.floor(base / Math.max(0.2, CTRL.speed)));
  return new Promise((resolve) => {
    const start = performance.now();
    function loop() {
      if (CTRL.stopRequested) return resolve();
      if (CTRL.paused && !CTRL.stepArmed) return setTimeout(loop, 40);
      if (CTRL.stepArmed) CTRL.stepArmed = false;
      const elapsed = performance.now() - start;
      if (elapsed >= scaled) return resolve();
      setTimeout(loop, 16);
    }
    loop();
  });
}

/* ---------------- Cursor rendering ---------------- */
const CURSOR_ID = '__sim_cursor';
function ensureCursor() {
  let c = document.getElementById(CURSOR_ID);
  if (c) return c;
  c = document.createElement('div');
  c.id = CURSOR_ID;
  Object.assign(c.style, {
    position: 'fixed',
    zIndex: 999999,
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    background: 'rgba(59,130,246,.9)',
    boxShadow: '0 0 0 6px rgba(59,130,246,.18)',
    pointerEvents: 'none',
    transform: 'translate(-50%, -50%)',
    transition: 'transform 80ms linear, left 120ms linear, top 120ms linear'
  });
  // put it at center by default
  const cx = Math.round(window.innerWidth / 2);
  const cy = Math.round(window.innerHeight / 2);
  c.style.left = `${cx}px`;
  c.style.top  = `${cy}px`;
  __lastCursorPos.x = cx;
  __lastCursorPos.y = cy;
  document.body.appendChild(c);
  return c;
}

function removeCursor() {
  const c = document.getElementById(CURSOR_ID);
  if (c) c.remove();
}

/* --------- FAST-ABORT GUARDS inside helpers (critical!) --------- */
async function moveToPoint(x, y, msPer100px = 120) {
  if (shouldAbort()) return;
  const cur = ensureCursor();

  // coordonnées cibles valides ?
  if (!Number.isFinite(x) || !Number.isFinite(y)) return;

  const margin = 8;
  const targetX = _clamp(Math.round(x), margin, Math.max(margin, Math.round(window.innerWidth)  - margin));
  const targetY = _clamp(Math.round(y), margin, Math.max(margin, Math.round(window.innerHeight) - margin));

  // point de départ fiable
  let fromX = __lastCursorPos.x;
  let fromY = __lastCursorPos.y;
  if (!Number.isFinite(fromX) || !Number.isFinite(fromY)) {
    try {
      const r0 = cur.getBoundingClientRect();
      fromX = Number.isFinite(r0.left) ? r0.left + 6 : Math.round(window.innerWidth  / 2);
      fromY = Number.isFinite(r0.top)  ? r0.top  + 6 : Math.round(window.innerHeight / 2);
    } catch {
      fromX = Math.round(window.innerWidth  / 2);
      fromY = Math.round(window.innerHeight / 2);
    }
  }

  const dx = targetX - fromX, dy = targetY - fromY;
  const dist = Math.hypot(dx, dy) || 1;

  // ► Ne plus "téléporter" via le centre : trajet direct, toujours
  const steps = Math.max(10, Math.floor(dist / 10));
  const dur   = Math.max(80, Math.floor((dist / 100) * msPer100px) / Math.max(0.2, CTRL.speed));
  const dt    = dur / steps;

  for (let i = 1; i <= steps; i++) {
    if (shouldAbort()) return;
    while (CTRL.paused && !CTRL.stepArmed && !CTRL.stopRequested) { await sleep(40); }
    if (CTRL.stepArmed) CTRL.stepArmed = false;

    const t = i / steps;
    const nx = Math.round(fromX + dx * t);
    const ny = Math.round(fromY + dy * t);

    cur.style.left = `${nx}px`;
    cur.style.top  = `${ny}px`;

    __lastCursorPos.x = nx;
    __lastCursorPos.y = ny;
    timelineRecord(nx, ny);
    await sleep(dt);
  }

  // set exact target at end
  cur.style.left = `${targetX}px`;
  cur.style.top  = `${targetY}px`;
  __lastCursorPos.x = targetX;
  __lastCursorPos.y = targetY;
  timelineRecord(targetX, targetY);
}

async function moveToEl(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  try {
    // scroll "instant" mais seulement si l'élément est dehors du viewport
    const r0 = node.getBoundingClientRect();
    const out =
      !r0 || r0.bottom < 0 || r0.top > window.innerHeight ||
      r0.right < 0 || r0.left > window.innerWidth;
    if (out) { try { node.scrollIntoView({ block: 'center', behavior: 'instant' }); } catch {} }
  } catch {}

  // petit délai pour laisser le layout se stabiliser
  await sleep(50);

  // si l'élément a été re-rendu, ré-obtenir une référence fraîche
  if (!node.isConnected) {
    try { node = document.getElementById(node.id) || node; } catch {}
  }

  // re-lire le rect et valider
  let r;
  try { r = node.getBoundingClientRect(); } catch { r = null; }

  if (!r || !Number.isFinite(r.left) || !Number.isFinite(r.top) || r.width < 1 || r.height < 1) {
    // si rect invalide → rester sur la dernière position connue (pas de "coin haut-gauche")
    return;
  }

  await moveToPoint(r.left + Math.min(Math.max(2, r.width - 2), offX),
                    r.top  + Math.min(Math.max(2, r.height - 2), offY));
}

function fireMouse(node) {
  if (!node || shouldAbort()) return;
  const r = node.getBoundingClientRect();
  const centerX = r.left + r.width / 2;
  const centerY = r.top + r.height / 2;
  for (const type of ['mousedown', 'mouseup', 'click']) {
    if (shouldAbort()) return;
    node.dispatchEvent(new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: centerX, clientY: centerY, button: 0
    }));
  }
}

async function click(node, offX = 6, offY = 6) {
  if (shouldAbort() || !node) return;
  await moveToEl(node, offX, offY);
  if (shouldAbort()) return;
  fireMouse(node);
  await sleep(80);
}

async function typeInto(input, text, perCharMs = 28) {
  if (shouldAbort() || !input) return;
  await click(input);
  if (shouldAbort()) return;
  input.focus();
  input.value = '';
  input.dispatchEvent(new Event('input', { bubbles: true }));
  for (const ch of String(text)) {
    if (shouldAbort()) return;
    input.value += ch;
    input.dispatchEvent(new Event('input', { bubbles: true }));
    await sleep(perCharMs);
  }
}

async function selectByText(selectEl, text) {
  if (shouldAbort() || !selectEl) return;
  const target = String(text).toLowerCase();
  const options = [...selectEl.options];
  for (const opt of options) {
    if (shouldAbort()) return;
    if (opt.textContent.toLowerCase() === target) {
      await click(selectEl);
      if (shouldAbort()) return;
      await sleep(120);
      opt.selected = true;
      opt.scrollIntoView({ block: 'center', behavior: 'auto' });
      await click(opt);
      if (shouldAbort()) return;
      selectByBrowser(selectEl); // change event for UI handlers
      await sleep(120);
      return;
    }
  }
}

function selectByBrowser(selectEl) {
  if (shouldAbort() || !selectEl) return;
  selectEl.dispatchEvent(new Event('change', { bubbles: true }));
}

function multiSelectByTexts(selectEl, labels = []) {
  if (shouldAbort() || !selectEl) return;
  const wanted = new Set(labels.map(x => String(x).toLowerCase()));
  for (const opt of selectEl.options) {
    if (shouldAbort()) return;
    opt.selected = wanted.has(opt.textContent.toLowerCase());
  }
  selectByBrowser(selectEl);
}

/* ---------------- Simulation artifacts cleanup (UI only) ---------------- */
const SIM_TRACES = { nodes: new Set(), classAdds: [] };

export function simMarkEl(node) {
  if (!node) return null;
  try { node.setAttribute('data-sim', ''); } catch {}
  SIM_TRACES.nodes.add(node);
  return node;
}
export function simAddTempClass(node, className) {
  if (!node || !className) return;
  try {
    node.classList.add(className);
    SIM_TRACES.classAdds.push([node, className]);
  } catch {}
}

export function simCleanupUI() {
  // 1) remove cursor
  removeCursor();
  // 2) remove elements tagged as simulation artifacts
  try { document.querySelectorAll('[data-sim]').forEach(n => n.remove()); } catch {}
  // 3) remove temp classes
  SIM_TRACES.classAdds.forEach(([n, cls]) => { try { n.classList.remove(cls); } catch {} });
  SIM_TRACES.classAdds.length = 0;
  // 4) timeline reset
  timelineClear();
  safeUpdateButtons();
}

/* ---------------- Public gesture API used by scenarios ---------------- */
export const g = {
  el: (id) => document.getElementById(id),
  wait: sleep,
  moveToEl,
  click,
  typeInto,
  selectByText,
  multiSelectByTexts,
  // tagging helpers for cleanup
  markEl: simMarkEl,
  addClassTemp: simAddTempClass,
  // keep toolbar toggling consistent
  disableTopButtons: (disabled = true) => disableTopButtons(disabled),
  ensureInView: (node, block = 'center') => {
    try { node?.scrollIntoView({ block, behavior: 'auto' }); } catch {}
  }
};

/* =========================================================
   Scenario runner
   ========================================================= */

async function runScenarioObject(sc) {
  try {
    await sc.fn(g);
  } catch (e) {
    if (!CTRL.stopRequested) console.error(e);
  }
}

export async function runSimulation(opts = {}) {
  if (CTRL.running) return;     // avoid concurrent runs
  CTRL.stopRequested = false;
  CTRL.paused = false;
  CTRL.stepArmed = false;
  readSpeedFromUI();

  // Take a state snapshot so STOP can fully roll back.
  takeSnapshot();

  // Fresh cursor/timeline/UI artifacts
  simCleanupUI();

  disableTopButtons(true);
  CTRL.running = true;

  for (const sc of SCENARIOS) {
    if (shouldAbort()) break;
    await runScenarioObject(sc);
    if (shouldAbort()) break;
    await sleep(300);
  }

  CTRL.running = false;
  disableTopButtons(false);

  // If aborted, restore snapshot so *nothing* from the scenario sticks.
  if (shouldAbort()) {
    restoreSnapshot();
  }

  // Always clean UI artifacts
  simCleanupUI();

  // Render after finishing/aborting
  if (typeof opts.renderCallback === 'function') {
    try { opts.renderCallback(); } catch {}
  }
}

/* ---------------- State queries for UI ---------------- */
export function simIsRunning() { return CTRL.running; }
export function simIsPaused()  { return CTRL.paused; }
export function simHasStopRequest() { return CTRL.stopRequested; }

/* ---------------- Default export ---------------- */
export default {
  registerScenario,
  runSimulation,
  simPlay, simPause, simToggle, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simCanStepBack, simCanStepForward,
  simIsRunning, simIsPaused, simHasStopRequest,
  simCleanupUI, simMarkEl, simAddTempClass,
  g,
  SCENARIOS
};

===== ./js/paths.js =====
// js/paths.js
// Graph path enumeration for ENVULN

/**
 * Build a map id -> target object for quick lookups.
 */
function targetMap(state) {
  const m = Object.create(null);
  (state.targets || []).forEach(t => { m[t.id] = t; });
  return m;
}

export function nameOfTarget(state, id) {
  return (state.targets || []).find(t => t.id === id)?.name || String(id || '');
}

function outsFrom(map, id) {
  if (!map) return [];
  const s = map[id];
  if (!s) return [];
  return Array.isArray(s) ? s.slice() : Array.from(s);
}

/**
 * Return unique outgoing neighbors from a node, honoring the includeLateral / includeContains flags.
 */
export function adjacency(state, id, opts = { includeLateral: true, includeContains: true }) {
  const out = new Set();
  const e = state.edges || {};
  outsFrom(e.direct, id).forEach(x => out.add(x));
  if (opts.includeLateral) outsFrom(e.lateral, id).forEach(x => out.add(x));
  if (opts.includeContains) outsFrom(e.contains, id).forEach(x => out.add(x));
  return Array.from(out);
}

/**
 * Fast cycle check (DFS colors) honoring adjacency options.
 */
export function isDAG(state, opts = { includeLateral: true, includeContains: true }) {
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = Object.create(null);
  for (const t of (state.targets || [])) color[t.id] = WHITE;
  let hasCycle = false;

  function dfs(u) {
    color[u] = GRAY;
    const nexts = adjacency(state, u, opts);
    for (const v of nexts) {
      if (color[v] === GRAY) { hasCycle = true; return; }
      if (color[v] === WHITE) dfs(v);
      if (hasCycle) return;
    }
    color[u] = BLACK;
  }

  for (const t of (state.targets || [])) {
    if (color[t.id] === WHITE) dfs(t.id);
    if (hasCycle) break;
  }
  return !hasCycle;
}

/* -------- DAG enumeration (memoized). Do NOT stop on exits here. -------- */
function enumeratePaths_DAG_from(state, startId, memo, opts /* stopSet unused */) {
  if (memo.has(startId)) return memo.get(startId);

  const results = [];
  const nexts = adjacency(state, startId, opts);
  const t = (state.targets || []).find(x => x.id === startId);
  const isFinal = !!(t && t.final);

  // Stop only on: no outgoing edges OR explicit final node.
  if (nexts.length === 0 || isFinal) {
    results.push([startId]);
  } else {
    for (const v of nexts) {
      const subs = enumeratePaths_DAG_from(state, v, memo, opts);
      for (const sub of subs) {
        results.push([startId, ...sub]);
      }
    }
  }

  memo.set(startId, results);
  return results;
}

export function enumeratePaths_DAG(state, starts, opts, stopSet /* kept for API parity */) {
  const memo = new Map();
  let all = [];
  for (const s of starts) {
    const sub = enumeratePaths_DAG_from(state, s, memo, opts, stopSet);
    all = all.concat(sub);
  }
  return all;
}

/* -------- General graph (cycles allowed). Do NOT stop on exits here. -------- */
export function enumeratePaths_General(state, starts, opts, stopSet /* used later */, maxPaths = 5000) {
  const paths = [];
  let cycles = false;

  const adj = (id) => adjacency(state, id, opts);

  function dfs(u, visited, stack) {
    if (paths.length >= maxPaths) return;

    const t = (state.targets || []).find(x => x.id === u);
    const isFinal = !!(t && t.final);
    const nexts = adj(u);

    // If node is explicit final, record the path and stop.
    if (isFinal) {
      paths.push([...stack, u]);
      return;
    }

    // Split neighbors by visited status to keep paths simple.
    const unvisited = [];
    for (const v of nexts) {
      if (visited.has(v)) { cycles = true; continue; }
      unvisited.push(v);
    }

    // If there are no unvisited neighbors, this is a maximal simple path → record it.
    if (unvisited.length === 0) {
      paths.push([...stack, u]);
      return;
    }

    // Otherwise, continue DFS on each unvisited neighbor.
    visited.add(u);
    for (const v of unvisited) {
      if (paths.length >= maxPaths) break;
      dfs(v, visited, [...stack, u]);
    }
    visited.delete(u);
  }

  for (const s of starts) {
    dfs(s, new Set(), []);
    if (paths.length >= maxPaths) break;
  }

  return { paths, cycles };
}

/**
 * Compute all simple paths for a single attacker.
 * - Traversal does NOT stop on exits; exits are used only as an end-filter.
 * - Honors lateral/contains inclusion flags.
 * - Applies a per-attacker path ceiling in cyclic graphs.
 */
export function computePathsForAttacker(
  state,
  attackerId,
  opts = { includeLateral: true, includeContains: true },
  maxPaths = 5000
) {
  const attacker = (state.attackers || []).find(a => a.id === attackerId);
  if (!attacker) return { paths: [], cycles: false, truncated: false };

  const starts = Array.from(attacker.entries || []).map(String);
  if (starts.length === 0) return { paths: [], cycles: false, truncated: false };

  // Exits selected in the UI are treated as allowed END nodes (filtering step only).
  const exits = new Set(Array.from(attacker.exits || []).map(String));

  const dag = isDAG(state, opts);

  let nodePaths = [];
  let cycles = false;

  if (dag) {
    nodePaths = enumeratePaths_DAG(state, starts, opts, exits);
  } else {
    const out = enumeratePaths_General(state, starts, opts, exits, maxPaths);
    nodePaths = out.paths;
    cycles = out.cycles;
  }

  // Keep only those that end on an exit if exits were provided.
  if (exits.size > 0) {
    nodePaths = nodePaths.filter(path => exits.has(String(path[path.length - 1])));
  }

  const targetsById = targetMap(state);
  const normalized = nodePaths.map(nodes => ({
    attackerId: attacker.id,
    attackerName: attacker.name,
    nodes: nodes.map(id => targetsById[id]).filter(Boolean),
    vulnsPerNode: nodes.map(id => {
      const t = targetsById[id];
      if (!t) return [];
      const list = Array.isArray(t.vulns) ? t.vulns : Array.from(t.vulns || []);
      return list
        .map(vId => (state.vulns || []).find(x => x.id === vId)?.name || vId)
        .filter(Boolean);
    })
  }));

  const truncated = (!dag && nodePaths.length >= maxPaths);
  return { paths: normalized, cycles, truncated };
}

/**
 * Compute paths for all attackers, concatenated.
 */
export function computeAllPaths(
  state,
  opts = { includeLateral: true, includeContains: true },
  maxPathsPerAttacker = 5000
) {
  const all = [];
  let anyCycles = false;
  let anyTruncated = false;

  for (const a of (state.attackers || [])) {
    const out = computePathsForAttacker(state, a.id, opts, maxPathsPerAttacker);
    all.push(...out.paths);
    if (out.cycles) anyCycles = true;
    if (out.truncated) anyTruncated = true;
  }

  return { paths: all, cycles: anyCycles, truncated: anyTruncated };
}


===== ./js/diagram.js =====
// /js/diagram.js
// ES module that builds and renders the attack path SVG diagrams.

export function buildSVGForPath(pathObj, state, options = {}) {
  // ---- options with sane defaults ----
  const {
    padX = 20,
    padY = 22,
    boxW = 220,
    boxH = 70,
    gap = 60,
    corner = 10,
    fontFamily = 'Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial',
    showVulns = true,
    vulnLineHeight = 14,
    maxTitleChars = 28,
    maxSubtitleChars = 34,
    maxVulnChars = 60,
    colors = {
      bg: '#0b1224',
      title: '#e6eef8',
      subtitle: '#9fb0c6',
      note: '#cbd5e1',
      strokeBase: '#a7b8cf',
      strokeDirect: '#a7b8cf',
      strokeLateral: '#fbbf24',
      strokeContains: '#60a5fa',
      boxBase: '#0b1730',
      boxAtt: '#a855f7',
      boxEntry: '#f59e0b',
      boxTarget: '#22c55e',
      boxFinal: '#16a34a'
    }
  } = options;

  // ---- guards ----
  if (!pathObj || !Array.isArray(pathObj.nodes) || !pathObj.nodes.length) {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="640" height="120" viewBox="0 0 640 120" role="img" aria-label="Empty path">
      <rect x="0" y="0" width="640" height="120" fill="${colors.bg}"/>
      <text x="16" y="64" fill="${colors.title}" font-family="${fontFamily}" font-size="14">Empty path</text>
    </svg>`;
  }

  // ---- helpers ----
  const esc = s => String(s || '').replace(/[&<>"]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
  const wrap = (text, max = 28) => {
    const t = String(text || '');
    if (t.length <= max) return [t];
    const words = t.split(/\s+/);
    const lines = [];
    let cur = '';
    for (const w of words) {
      if ((cur ? cur + ' ' : '') .length + w.length > max) {
        if (cur) lines.push(cur);
        cur = w;
      } else {
        cur = cur ? cur + ' ' + w : w;
      }
    }
    if (cur) lines.push(cur);
    return lines.slice(0, 3);
  };

  const nameOf = (id) => (state.targets.find(t => t.id === id) || { name: '?' }).name;

  // Decide edge type between consecutive nodes in the path
  const isInSet = (map, from, to) => {
    const set = map[from];
    if (!set) return false;
    // map can be Set or Array depending on how state was loaded
    if (set instanceof Set) return set.has(to);
    return Array.isArray(set) ? set.includes(to) : false;
  };
  const edgeTypeBetween = (fromId, toId) => {
    if (isInSet(state.edges?.lateral || {}, fromId, toId)) return 'lateral';
    if (isInSet(state.edges?.contains || {}, fromId, toId)) return 'contains';
    return 'direct';
  };

  // ---- build "steps" sequence ----
  const entriesNames = [...(state.attackers.find(a => a.id === pathObj.attackerId)?.entries || new Set())].map(nameOf);
  const steps = [
    { kind: 'attacker', title: 'Attacker', subtitle: pathObj.attacker || '—' },
    { kind: 'entries',  title: 'Entries',  subtitle: entriesNames.length ? entriesNames.join(', ') : '—' },
    ...pathObj.nodes.map((n, i) => ({
      kind: 'target',
      title: `Target ${i + 1}${i === pathObj.nodes.length - 1 ? ' (final)' : ''}`,
      subtitle: n.name,
      isFinal: i === pathObj.nodes.length - 1,
      vulns: (pathObj.vulnsPerNode?.[i] || [])
    }))
  ];

  // Determine canvas base dimensions
  const anyTarget = steps.some(s => s.kind === 'target');
  const baseH = padY * 2 + boxH + (anyTarget && showVulns ? (vulnLineHeight + 18) : 0);
  const baseW = padX * 2 + steps.length * boxW + (steps.length - 1) * gap;

  // ---- SVG construction ----
  let x = padX, y = padY;
  let svg = `
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 ${baseW} ${baseH}" width="${Math.min(baseW, 1600)}" height="${baseH}"
     role="img" aria-label="Attack path diagram">
  <defs>
    <marker id="arrowHead" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
      <polygon points="0,0 12,4 0,8" fill="${colors.strokeBase}"/>
    </marker>
    <style>
      .title { font: 600 14px ${fontFamily}; fill: ${colors.title}; }
      .subtitle { font: 12px ${fontFamily}; fill: ${colors.subtitle}; }
      .note { font: 12px ${fontFamily}; fill: ${colors.note}; }
      .box { fill: ${colors.boxBase}; stroke-width: 1.4; rx: ${corner}; ry: ${corner}; }
      .box-att { stroke: ${colors.boxAtt}; }
      .box-entry { stroke: ${colors.boxEntry}; }
      .box-target { stroke: ${colors.boxTarget}; }
      .box-final { stroke: ${colors.boxFinal}; stroke-width: 2; }
      .arrow { stroke: ${colors.strokeDirect}; stroke-width: 1.6; fill: none; marker-end: url(#arrowHead); }
      .arrow-lat { stroke: ${colors.strokeLateral}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 6 4; }
      .arrow-contains { stroke: ${colors.strokeContains}; stroke-width: 1.4; fill: none; marker-end: url(#arrowHead); stroke-dasharray: 2 4; }
      .bg { fill: ${colors.bg}; }
    </style>
  </defs>
  <rect class="bg" x="0" y="0" width="${baseW}" height="${baseH}" rx="${corner}" ry="${corner}"/>
`;

  // precompute edge types between consecutive target nodes
  const pathTargetIds = pathObj.nodes.map(n => n.id);
  const hopTypes = [];
  for (let i = 0; i < pathTargetIds.length - 1; i++) {
    hopTypes[i] = edgeTypeBetween(pathTargetIds[i], pathTargetIds[i + 1]);
  }

  function drawBox(className, title, subtitle, isFinal) {
    svg += `<rect class="box ${className} ${isFinal ? 'box-final' : ''}" x="${x}" y="${y}" width="${boxW}" height="${boxH}" />`;
    let ty = y + 24;
    wrap(title, maxTitleChars).forEach(ln => { svg += `<text class="title" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 16; });
    wrap(subtitle, maxSubtitleChars).forEach(ln => { svg += `<text class="subtitle" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 14; });
  }

  steps.forEach((s, i) => {
    const cls =
      s.kind === 'attacker' ? 'box-att' :
      s.kind === 'entries'  ? 'box-entry' : 'box-target';

    drawBox(cls, s.title, s.subtitle, s.isFinal);

    if (s.kind === 'target' && showVulns) {
      const text = s.vulns && s.vulns.length
        ? `Vulns: ${truncateList(s.vulns, maxVulnChars)}`
        : 'No vulnerabilities';
      svg += `<text class="note" x="${x + 10}" y="${y + boxH + 22}">${esc(text)}</text>`;
    }

    if (i < steps.length - 1) {
      // Draw edge to next step, deciding style by hop type (only between target→target)
      const nx = x + boxW + gap;
      const midY = y + boxH / 2;
      let clsArrow = 'arrow'; // default direct
      if (s.kind === 'target') {
        const idx = i - 2; // because steps[0]=attacker, steps[1]=entries
        if (idx >= 0 && idx < hopTypes.length) {
          const t = hopTypes[idx];
          if (t === 'lateral') clsArrow = 'arrow-lat';
          else if (t === 'contains') clsArrow = 'arrow-contains';
        }
      }
      svg += `<path class="${clsArrow}" d="M ${x + boxW} ${midY} C ${x + boxW + gap / 2} ${midY} ${nx - gap / 2} ${midY} ${nx} ${midY}" />`;
      x = nx;
    }
  });

  svg += `</svg>`;
  return svg;

  // truncate comma-joined lists to a max char count (soft)
  function truncateList(arr, max) {
    const s = arr.join(', ');
    if (s.length <= max) return s;
    // Try to keep full items, not mid-word cut
    let out = '';
    for (let i = 0; i < arr.length; i++) {
      const next = out ? out + ', ' + arr[i] : arr[i];
      if (next.length > max) break;
      out = next;
    }
    return out ? out + '…' : s.slice(0, max - 1) + '…';
  }
}

/**
 * Render the diagram into a container element.
 * @param {HTMLElement} containerEl - target container (e.g., document.getElementById('diagramBox'))
 * @param {Object} pathObj - result item { attacker, attackerId, nodes: [{id,name}], vulnsPerNode: [...] }
 * @param {Object} state - full app state (targets, edges, attackers...)
 * @param {Object} options - same as buildSVGForPath options (optional)
 * @returns {SVGElement|null}
 */
export function renderDiagram(containerEl, pathObj, state, options = {}) {
  if (!containerEl) return null;
  const svgStr = buildSVGForPath(pathObj, state, options);
  containerEl.innerHTML = svgStr;
  const svg = containerEl.querySelector('svg');
  // small QoL: enable horizontal scroll with Shift+wheel
  containerEl.style.overflowX = 'auto';
  containerEl.style.overflowY = 'hidden';
  containerEl.onwheel = (ev) => {
    if (ev.shiftKey) {
      containerEl.scrollLeft += ev.deltaY;
      ev.preventDefault();
    }
  };
  return svg || null;
}

/**
 * Download an existing <svg> as an .svg file.
 * @param {SVGElement} svgEl
 * @param {string} filename
 */
export function downloadSVG(svgEl, filename = 'attack-diagram.svg') {
  if (!svgEl) return;
  const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/* ===== Usage example (in UI code) =====
import { renderDiagram, downloadSVG } from './diagram.js';
import { State } from './state.js';

const svg = renderDiagram(document.getElementById('diagramBox'), pathItem, State, {
  showVulns: true,
  gap: 68
});
document.getElementById('btnDownloadSVG').onclick = () => downloadSVG(svg, 'attack-diagram.svg');
*/

===== ./js/main.js =====
// js/main.js
// Main UI logic with immediate persistence and dual playback:
// - dataset playback for computed paths (left/right navigation)
// - simulation playback bridge (play/pause/stop/restart/step; speed control)

import './simulation/scenarios.js';

import { el, norm, uid } from './helpers.js';
import * as StateMod from './state.js';
import { saveToLocal, loadFromLocal, clearLocal } from './storage.js';
import { exportJSONSelective, parseImportJSONPartial } from './storage.js';
import {
  renderAttackers,
  renderTargets,
  renderVulns,
  populateSelectors,
  renderLinksInspector,
  setOptions,
  hydrateEntriesSelect,
  hydrateExitsSelect,
  hydrateVulnSelectors
} from './ui/lists.js';
import { wireLinksUI } from './ui/links.js';
import { computeAllPaths } from './paths.js';
import { buildSVGForPath } from './diagram.js';
import { exportODS } from './exportODS.js';
import {
  runSimulation,
  disableTopButtons,
  enableTopButtons,
  simPlay, simPause, simStop, simStep, simSetSpeed,
  simStepBack, simStepForward,
  simIsRunning, simIsPaused,
  simCanStepBack, simCanStepForward,
  simCleanupUI
} from './simulation/index.js';

let lastResults = [];
let lastMeta = { cycles: false, truncated: false };

/* -------------------------------------------------------------------------- */
/* UI selection store                                                         */
/* -------------------------------------------------------------------------- */
const UI_STORE_KEY = 'envuln-lite-ui';
function saveUISelection(){
  try {
    localStorage.setItem(UI_STORE_KEY, JSON.stringify({
      attackerId: el('selAttacker')?.value || null,
      vulnTargetId: el('selVulnElement')?.value || null
    }));
  } catch {}
}
function loadUISelection(){
  try { return JSON.parse(localStorage.getItem(UI_STORE_KEY) || '{}'); }
  catch { return {}; }
}

/* -------------------------------------------------------------------------- */
/* Status                                                                     */
/* -------------------------------------------------------------------------- */
function renderStatus(s) {
  const sEl = el('status');
  if (sEl) sEl.textContent = s;
}

/* -------------------------------------------------------------------------- */
/* Global rerender                                                            */
/* -------------------------------------------------------------------------- */
function emitStateChanged() {
  try { saveToLocal(StateMod.State); } catch {}
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Playback UI helpers                                                        */
/* -------------------------------------------------------------------------- */
let playbackControlsEnabled = false;

function setPlayPauseVisual(isPlaying) {
  const btn = el('btnPlayPause');
  if (!btn) return;
  btn.textContent = isPlaying ? '⏸' : '▶';
}

function setPlaybackEnabled(enabled) {
  playbackControlsEnabled = !!enabled;
  const ids = ['btnPlayPause','btnStop','btnRestart','btnStepBack','btnStepForward'];
  ids.forEach(id => {
    const b = document.getElementById(id);
    if (b) b.disabled = !playbackControlsEnabled || !playback.dataset.length;
  });
  const row = document.getElementById('playbackRow');
  if (row) row.classList.toggle('is-disabled', !playbackControlsEnabled);
  if (!playbackControlsEnabled) setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Full wipe (used by Reset All)                                              */
/* -------------------------------------------------------------------------- */
function resetAllApp() {
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor'); if (cur) cur.remove();

  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  try { clearLocal(); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}
  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram   = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div');
    ph.className = 'small';
    ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }
  const svgSizeEl = el('svgSize'); if (svgSizeEl) svgSizeEl.textContent = '—';
  const statusEl  = el('status');  if (statusEl)  statusEl.textContent  = '—';

  const inAtt = el('attackerName'); if (inAtt) inAtt.value = '';
  const inTar = el('targetName');   if (inTar) inTar.value = '';
  const inVul = el('vulnName');     if (inVul) inVul.value = '';

  playback_setDataset([]);
  playback_resetToStart();

  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  renderAllUI();
}

/* -------------------------------------------------------------------------- */
/* Bridge playback controls to simulation engine                              */
/* -------------------------------------------------------------------------- */
function bridgeSimulationPlayback() {
  // no-op
}

/* --------------------------------------------------------------------------
   Hidden buttons for scenarios that call add/remove link by clicking
   -------------------------------------------------------------------------- */
function ensureSimScenarioLinkButtons() {
  const byId = (id) => document.getElementById(id);

  ['btnAddLink', 'btnRemoveLink'].forEach(id => {
    if (!byId(id)) {
      const b = document.createElement('button');
      b.id = id;
      b.type = 'button';
      b.hidden = true;
      document.body.appendChild(b);
    }
  });

  function ensureSelect(id, multiple = false) {
    let s = byId(id);
    if (!s) {
      s = document.createElement('select');
      s.id = id;
      if (multiple) s.multiple = true;
      s.hidden = true;
      document.body.appendChild(s);
    }
    return s;
  }

  const srcSel  = ensureSelect('linkSource', false);
  const dstSel  = ensureSelect('linkDest', true);
  const typeSel = ensureSelect('linkType', false);

  if (typeSel.options.length === 0) {
    ['direct','lateral','contains'].forEach(v => {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      typeSel.appendChild(opt);
    });
  }

  function populateTargetOptions() {
    [srcSel, dstSel].forEach(sel => {
      while (sel.firstChild) sel.removeChild(sel.firstChild);
    });

    (window.State?.targets || []).forEach(t => {
      const o1 = document.createElement('option');
      o1.value = t.id;
      o1.textContent = t.name;
      srcSel.appendChild(o1);

      const o2 = document.createElement('option');
      o2.value = t.id;
      o2.textContent = t.name;
      dstSel.appendChild(o2);
    });
  }

  populateTargetOptions();

  document.addEventListener('state:changed', () => {
    populateTargetOptions();
  });

  const btnAdd = byId('btnAddLink');
  const btnDel = byId('btnRemoveLink');

  const apply = (mode, btnClicked) => {
    populateTargetOptions();

    let from = srcSel?.value;
    const type = typeSel?.value || 'direct';
    let selectedTos = [...(dstSel?.selectedOptions || [])].map(o => o.value);

    if ((!from || !selectedTos.length) && btnClicked) {
      const ds = btnClicked.dataset || {};
      if (!from && ds.src) from = ds.src;
      if ((!selectedTos.length) && ds.tos) selectedTos = String(ds.tos).split(',').map(x=>x.trim()).filter(Boolean);
    }

    if (!from || !selectedTos.length) {
      console.warn('[sim links] apply() skipped: missing from or tos', { from, selectedTos, type });
      return;
    }

    try {
      selectedTos.forEach(to => {
        if (mode === 'add') {
          StateMod.addEdge(type, from, to);
        } else {
          StateMod.removeEdge(type, from, to);
        }
      });
    } catch (e) {
      console.error('[sim links] apply error', e);
    }

    try { saveToLocal(StateMod.State); } catch {}
    try { renderLinksInspector(); } catch {}
  };

  if (btnAdd) btnAdd.addEventListener('click', (ev) => apply('add', ev.currentTarget));
  if (btnDel) btnDel.addEventListener('click', (ev) => apply('del', ev.currentTarget));
}

/* -------------------------------------------------------------------------- */
/* Initialization                                                             */
/* -------------------------------------------------------------------------- */
async function init() {
  const loaded = loadFromLocal();
  if (loaded) StateMod.hydrate(loaded);

  StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));

  renderAllUI();

  const ui = loadUISelection();
  if (ui.attackerId) {
    const selAtt = el('selAttacker');
    if (selAtt && [...selAtt.options].some(o => o.value === ui.attackerId)) {
      selAtt.value = ui.attackerId;
      hydrateEntriesSelect(StateMod.State);
      hydrateExitsSelect(StateMod.State);
    }
  }
  if (ui.vulnTargetId) {
    const selT = el('selVulnElement');
    if (selT && [...selT.options].some(o => o.value === ui.vulnTargetId)) {
      selT.value = ui.vulnTargetId;
      hydrateVulnSelectors(StateMod.State);
    }
  }

  wireAddControls();
  wireAttackerSelection();
  wireEntries();
  wireExits();
  wireVulns();
  wireLinksUI();
  wireTopActions();
  wireSimulationButton();
  wirePlaybackControls();
  bridgeSimulationPlayback();
  ensureSimScenarioLinkButtons();

  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
  playback_setDataset([]);
  playback_renderCurrent();
  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Rendering                                                                  */
/* -------------------------------------------------------------------------- */
function renderAllUI() {
  renderAttackers(StateMod.State);
  renderTargets(StateMod.State);
  renderVulns(StateMod.State);
  populateSelectors(StateMod.State);

  hydrateEntriesSelect(StateMod.State);
  hydrateExitsSelect(StateMod.State);
  hydrateVulnSelectors(StateMod.State);

  renderLinksInspector();

  playback_updateButtons();
}

/* -------------------------------------------------------------------------- */
/* Add controls + Reset All                                                   */
/* -------------------------------------------------------------------------- */
function wireAddControls() {
  el('btnAddAttacker').onclick = () => {
    const name = norm(el('attackerName').value);
    if (!name) return;
    StateMod.createAttacker(name);
    el('attackerName').value = '';
    emitStateChanged();
  };

  el('btnAddTarget').onclick = () => {
    const name = norm(el('targetName').value);
    if (!name) return;
    const id = StateMod.createTarget(name);
    StateMod.ensureEdgeMaps(id);
    el('targetName').value = '';
    emitStateChanged();
  };

  el('btnAddVuln').onclick = () => {
    const name = norm(el('vulnName').value);
    if (!name) return;
    StateMod.createVuln(name);
    el('vulnName').value = '';
    emitStateChanged();
  };

  const btnResetAll = el('btnResetAll');
  if (btnResetAll) {
    btnResetAll.onclick = () => {
      if (confirm('This will erase all attackers, targets, vulnerabilities, links, results and local storage. Continue?')) {
        resetAllApp();
      }
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Attacker selection                                                         */
/* -------------------------------------------------------------------------- */
function wireAttackerSelection() {
  el('selAttacker').addEventListener('change', () => {
    hydrateEntriesSelect(StateMod.State);
    hydrateExitsSelect(StateMod.State);
    saveUISelection();
  });
}

/* -------------------------------------------------------------------------- */
/* Entries (real-time + clear)                                                */
/* -------------------------------------------------------------------------- */
function wireEntries() {
  const sel = el('selEntriesAll');
  const btnClear = el('btnClearEntries');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerEntries(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerEntries(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Exits (real-time + clear)                                                  */
/* -------------------------------------------------------------------------- */
function wireExits() {
  const sel = el('selExitsAll');
  const btnClear = el('btnClearExits');

  if (sel) {
    sel.addEventListener('change', () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      const ids = [...sel.selectedOptions].map(o => o.value);
      StateMod.setAttackerExits(attId, ids);
      emitStateChanged();
    });
  }

  if (btnClear) {
    btnClear.onclick = () => {
      const attId = el('selAttacker').value;
      if (!attId) return;
      [...sel.options].forEach(o => o.selected = false);
      StateMod.setAttackerExits(attId, []);
      emitStateChanged();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Vulnerabilities (real-time + clear)                                        */
/* -------------------------------------------------------------------------- */
function wireVulns() {
  const selTarget = el('selVulnElement');
  const selVulns = el('selVulnsForElement');
  const btnClear = el('btnClearVulnSelection');

  if (!selTarget || !selVulns) return;

  const applySelectionToState = () => {
    const targetId = selTarget.value;
    if (!targetId) return;
    const vids = [...selVulns.selectedOptions].map(o => o.value);
    const t = StateMod.State.targets.find(x => x.id === targetId);
    if (!t) return;
    t.vulns = new Set(vids);
    emitStateChanged();
  };

  selTarget.addEventListener('change', () => {
    hydrateVulnSelectors(StateMod.State);
    saveUISelection();
  });

  selVulns.addEventListener('change', applySelectionToState);

  if (btnClear) {
    btnClear.onclick = () => {
      [...selVulns.options].forEach(o => o.selected = false);
      applySelectionToState();
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Results rendering                                                          */
/* -------------------------------------------------------------------------- */
function renderResultsList(results) {
  const cont = el('results');
  const svgSizeEl = el('svgSize');
  cont.innerHTML = '';
  if (!results.length) {
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const msg = (filterOn && (lastResults?.length || 0) > 0)
      ? 'No paths match the "Only vulnerable paths" filter.'
      : 'No paths.';
    cont.innerHTML = `<div class="small">${msg}</div>`;
    if (svgSizeEl) svgSizeEl.textContent = '—';
    playback_setDataset([]);
    return;
  }

  results.forEach((p, idx) => {
    const row = document.createElement('div');
    row.className = 'path';

    const left = document.createElement('div');
    left.className = 'left';
    const title = document.createElement('div');
    title.innerHTML = `<strong>${p.attackerName}</strong>`;
    const chain = document.createElement('div');
    chain.className = 'small';
    chain.textContent = p.nodes.map(n => n.name).join(' → ');
    left.append(title, chain);

    const btn = document.createElement('button');
    btn.className = 'ghost';
    btn.textContent = 'Diagram';
    btn.onclick = () => playback_showIndex(idx, true);

    row.append(left, btn);
    cont.appendChild(row);
  });

  playback_setDataset(results);
}

/* -------------------------------------------------------------------------- */
/* Top actions (compute/export/import/download)                               */
/* -------------------------------------------------------------------------- */
function wireTopActions() {
  const chkOnlyVuln = el('chkOnlyVuln');

  const summarize = (count, meta) => {
    const parts = [];
    parts.push(`${count} path${count === 1 ? '' : 's'}`);
    if (meta.cycles) parts.push('cycles detected (simple paths)');
    if (meta.truncated) parts.push('truncated by ceiling');
    renderStatus(parts.join(' • '));
  };

  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);

  const renderFiltered = () => {
    const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
    const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
    renderResultsList(display);
    summarize(display.length, lastMeta);
  };

  el('btnFindPaths').onclick = () => {
    const opts = {
      includeLateral: el('includeLateral').checked,
      includeContains: el('includeContains').checked
    };
    const max = parseInt(el('maxPaths').value, 10);
    const out = computeAllPaths(StateMod.State, opts, max);
    lastResults = out.paths || [];
    lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };
    renderFiltered();
    playback_resetToStart();
  };

  if (chkOnlyVuln) chkOnlyVuln.addEventListener('change', () => {
    renderFiltered();
    playback_resetToStart();
  });

  el('btnDownloadSVG').onclick = () => {
    const svg = el('diagramBox')?.querySelector('svg');
    if (!svg) return;
    const blob = new Blob([svg.outerHTML], { type: 'image/svg+xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `attack-diagram-${new Date().toISOString().replace(/[:.]/g, '-')}.svg`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 0);
  };

  const btnODS = el('btnExportODS');
  if (btnODS) {
    btnODS.onclick = () => {
      const onlyVuln = !!(chkOnlyVuln && chkOnlyVuln.checked);
      const display = onlyVuln ? lastResults.filter(hasVulnsEverywhere) : lastResults;
      if (!display.length) return alert('No paths to export.');
      exportODS(StateMod.State, { results: display });
    };
  }

  const btnExportJSON = el('btnExportJSON');
  const btnImportJSON = el('btnImportJSON');
  const fileIn = el('fileIn');

  if (btnExportJSON) {
    btnExportJSON.onclick = () => {
      showExportJSONDialog();
    };
  }

  if (btnImportJSON && fileIn) {
    btnImportJSON.onclick = () => fileIn.click();

    fileIn.onchange = async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) { fileIn.value = ''; return; }
      const txt = await file.text();
      const autoParse = parseImportJSONPartial(txt, ['all']);
      if (!autoParse.ok) {
        alert('Invalid JSON file.');
        fileIn.value = '';
        return;
      }
      showImportJSONDialog(txt, autoParse.payload);
      fileIn.value = '';
    };
  }
}

/* -------------------------------------------------------------------------- */
/* Modal helpers and JSON import/export dialogs                               */
/* -------------------------------------------------------------------------- */
function showModal(titleText, bodyEl, buttons) {
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:999999';
  const box = document.createElement('div');
  box.style.cssText = 'width:520px;max-width:92%;background:#0b1224;border-radius:8px;padding:16px;color:#e6eef8;box-shadow:0 8px 30px rgba(0,0,0,0.6)';
  const title = document.createElement('div'); title.style.fontWeight = '600'; title.style.marginBottom = '10px'; title.textContent = titleText;
  const content = document.createElement('div'); content.appendChild(bodyEl);
  const btnRow = document.createElement('div'); btnRow.style.marginTop = '12px'; btnRow.style.display = 'flex'; btnRow.style.justifyContent = 'flex-end'; btnRow.style.gap = '8px';

  buttons.forEach(b => {
    const btn = document.createElement('button');
    btn.textContent = b.label;
    btn.type = 'button';
    if (!b.primary) btn.className = 'ghost';
    btn.onclick = () => { document.body.removeChild(overlay); b.onClick(); };
    btnRow.appendChild(btn);
  });

  box.appendChild(title);
  box.appendChild(content);
  box.appendChild(btnRow);
  overlay.appendChild(box);
  document.body.appendChild(overlay);
}

function showExportJSONDialog() {
  const form = document.createElement('div');

  const help = document.createElement('div');
  help.className = 'small';
  help.textContent = 'Select domains to include in the exported JSON.';
  help.style.marginBottom = '8px';
  form.appendChild(help);

  const domains = ['attackers','targets','vulns','edges'];
  const checks = {};
  domains.forEach(d => {
    const row = document.createElement('div');
    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.marginBottom = '6px';
    const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = (d !== 'edges');
    checks[d] = cb;
    const lab = document.createElement('label'); lab.appendChild(cb); lab.append(' ' + d);
    row.appendChild(lab);
    form.appendChild(row);
  });

  showModal('Export JSON - Select domains', form, [
    { label: 'Cancel', onClick: () => {}, primary:false },
    { label: 'Export', onClick: () => {
      const selected = Object.keys(checks).filter(k => checks[k].checked);
      if (selected.includes('targets') && !selected.includes('edges')) selected.push('edges');
      exportJSONSelective(StateMod.dehydrate(), selected);
    }, primary:true }
  ]);
}

function showImportJSONDialog(txt, payload) {
  const form = document.createElement('div');

  const info = document.createElement('div');
  info.className = 'small';
  info.textContent = 'Select domains to import. Merge adds to current state; Wipe replaces selected domains.';
  info.style.marginBottom = '8px';
  form.appendChild(info);

  const domains = ['attackers','targets','vulns'];
  const checks = {};
  domains.forEach(d => {
    const row = document.createElement('div');
    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.marginBottom = '6px';
    const cb = document.createElement('input'); cb.type = 'checkbox';
    cb.checked = Array.isArray(payload[d]) && payload[d].length > 0;
    checks[d] = cb;
    const lab = document.createElement('label'); lab.appendChild(cb); lab.append(' ' + d);
    row.appendChild(lab);
    form.appendChild(row);
  });

  const modeRow = document.createElement('div');
  modeRow.style.marginTop = '8px';
  const rWipe = document.createElement('input'); rWipe.type='radio'; rWipe.name='impMode'; rWipe.value='wipe'; rWipe.id='impWipe';
  const rMerge = document.createElement('input'); rMerge.type='radio'; rMerge.name='impMode'; rMerge.value='merge'; rMerge.id='impMerge'; rMerge.checked = true;
  const labW = document.createElement('label'); labW.appendChild(rWipe); labW.append(' Wipe (replace) ');
  const labM = document.createElement('label'); labM.appendChild(rMerge); labM.append(' Merge (add) ');
  modeRow.appendChild(labM); modeRow.appendChild(labW);
  form.appendChild(modeRow);

  const note = document.createElement('div'); note.className = 'small'; note.style.marginTop='8px';
  note.textContent = 'When merging, a namespace is required if duplicate names are detected. It must start with a letter and contain only letters, digits, or underscore.';
  form.appendChild(note);

  const nsRow = document.createElement('div');
  nsRow.style.marginTop = '8px';
  const nsLabel = document.createElement('label'); nsLabel.textContent = 'Namespace: ';
  const nsInput = document.createElement('input'); nsInput.type = 'text'; nsInput.placeholder = 'optional_namespace';
  nsInput.style.marginLeft = '8px';
  nsRow.appendChild(nsLabel); nsRow.appendChild(nsInput);
  form.appendChild(nsRow);

  function validateNamespace(s) {
    if (!s) return false;
    return /^[A-Za-z][A-Za-z0-9_]*$/.test(s);
  }

  showModal('Import JSON - Domains & mode', form, [
    { label: 'Cancel', onClick: () => {}, primary:false },
    { label: 'Next', onClick: () => {
      const selected = domains.filter(d => checks[d].checked);
      if (!selected.length) { alert('No domains selected.'); return; }
      const mode = rWipe.checked ? 'wipe' : 'merge';

      const parseRes = parseImportJSONPartial(txt, selected);
      if (!parseRes.ok) { alert('Failed to parse import JSON.'); return; }
      const imported = parseRes.payload;

      if (mode === 'wipe') {
        const current = StateMod.dehydrate();
        if (selected.includes('vulns')) current.vulns = imported.vulns || [];
        if (selected.includes('targets')) {
          current.targets = imported.targets || [];
          current.edges = imported.edges || {direct:{}, lateral:{}, contains:{}};
        }
        if (selected.includes('attackers')) current.attackers = imported.attackers || [];
        StateMod.hydrate(current);
        StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));
        try { saveToLocal(StateMod.State); } catch {}
        renderAllUI();
        return;
      }

      const cur = StateMod.dehydrate();
      const dupeInfo = { attackers: [], targets: [], vulns: [] };
      const makeNameSet = (arr) => new Set((arr || []).map(x => String(x.name || '').trim().toLowerCase()));

      const curAttackers = makeNameSet(cur.attackers);
      const curTargets = makeNameSet(cur.targets);
      const curVulns = makeNameSet(cur.vulns);

      (imported.attackers || []).forEach(a => {
        if (curAttackers.has(String(a.name || '').trim().toLowerCase())) dupeInfo.attackers.push(a.name);
      });
      (imported.targets || []).forEach(t => {
        if (curTargets.has(String(t.name || '').trim().toLowerCase())) dupeInfo.targets.push(t.name);
      });
      (imported.vulns || []).forEach(v => {
        if (curVulns.has(String(v.name || '').trim().toLowerCase())) dupeInfo.vulns.push(v.name);
      });

      const anyDupe = (dupeInfo.attackers.length || dupeInfo.targets.length || dupeInfo.vulns.length) > 0;

      if (anyDupe && !validateNamespace(nsInput.value.trim())) {
        alert('Duplicate names detected. A valid namespace is required. Example: teamA_');
        showImportJSONDialog(txt, payload);
        return;
      }

      const namespace = nsInput.value.trim();
      const applyNamespaceToName = (name) => namespace ? `${namespace}_${name}` : name;

      const idMap = new Map();
      const remapped = { attackers: [], targets: [], vulns: [], edges: { direct: {}, lateral: {}, contains: {} } };

      (imported.vulns || []).forEach(v => {
        const newId = uid();
        idMap.set(String(v.id), newId);
        remapped.vulns.push({ id: newId, name: applyNamespaceToName(v.name) });
      });

      (imported.targets || []).forEach(t => {
        const newId = uid();
        idMap.set(String(t.id), newId);
        const newVulns = (t.vulns || []).map(vId => idMap.get(String(vId)) || String(vId));
        remapped.targets.push({ id: newId, name: applyNamespaceToName(t.name), vulns: newVulns, final: !!t.final });
      });

      (imported.attackers || []).forEach(a => {
        const newId = uid();
        idMap.set(String(a.id), newId);
        const newEntries = (a.entries || []).map(e => idMap.get(String(e)) || String(e));
        const newExits   = (a.exits   || []).map(e => idMap.get(String(e)) || String(e));
        remapped.attackers.push({ id: newId, name: applyNamespaceToName(a.name), entries: newEntries, exits: newExits });
      });

      const remapEdgeMap = (mapIn) => {
        const out = {};
        Object.keys(mapIn || {}).forEach(fromId => {
          const tos = Array.isArray(mapIn[fromId]) ? mapIn[fromId] : [];
          const newFrom = idMap.get(String(fromId)) || null;
          if (!newFrom) return;
          out[newFrom] = tos.map(t => idMap.get(String(t)) || String(t));
        });
        return out;
      };

      remapped.edges.direct = remapEdgeMap(imported.edges.direct || {});
      remapped.edges.lateral = remapEdgeMap(imported.edges.lateral || {});
      remapped.edges.contains = remapEdgeMap(imported.edges.contains || {});

      const merged = StateMod.dehydrate();

      if (selected.includes('vulns')) merged.vulns = merged.vulns.concat(remapped.vulns);
      if (selected.includes('targets')) merged.targets = merged.targets.concat(remapped.targets);
      if (selected.includes('attackers')) merged.attackers = merged.attackers.concat(remapped.attackers);

      if (selected.includes('targets')) {
        merged.edges.direct   = merged.edges.direct   || {};
        merged.edges.lateral  = merged.edges.lateral  || {};
        merged.edges.contains = merged.edges.contains || {};
        Object.assign(merged.edges.direct,   remapped.edges.direct || {});
        Object.assign(merged.edges.lateral,  remapped.edges.lateral || {});
        Object.assign(merged.edges.contains, remapped.edges.contains || {});
      }

      StateMod.hydrate(merged);
      StateMod.State.targets.forEach(t => StateMod.ensureEdgeMaps(t.id));
      try { saveToLocal(StateMod.State); } catch {}
      renderAllUI();
      return;
    }, primary:true }
  ]);
}

/* -------------------------------------------------------------------------- */
/* Simulation launcher button                                                 */
/* -------------------------------------------------------------------------- */
function wireSimulationButton() {
  const btn = el('btnSimu');
  if (!btn) return;
  btn.onclick = async () => {
    try {
      disableTopButtons(true);
      setPlaybackEnabled(true);
      setPlayPauseVisual(true);
      playback_updateButtons();
      btn.textContent = 'Simulating…';
      btn.disabled = true;
      await runSimulation({ renderCallback: () => renderAllUI() });
    } finally {
      btn.textContent = 'Simulation';
      btn.disabled = false;
      enableTopButtons();
      setPlayPauseVisual(false);
      setPlaybackEnabled(false);
      renderAllUI();
      playback_resetToStart?.();
      playback_updateButtons();
    }
  };
}

/* -------------------------------------------------------------------------- */
/* Fresh simulation reset helper                                              */
/* -------------------------------------------------------------------------- */
function resetForFreshSimulation() {
  try { simStop(); } catch {}
  const cur = document.getElementById('__sim_cursor');
  if (cur) cur.remove();

  StateMod.State.attackers = [];
  StateMod.State.targets   = [];
  StateMod.State.vulns     = [];
  StateMod.State.edges     = { direct: {}, lateral: {}, contains: {} };

  lastResults = [];
  lastMeta = { cycles: false, truncated: false };

  const resultsEl = el('results');    if (resultsEl) resultsEl.innerHTML = '';
  const diagram = el('diagramBox');
  if (diagram) {
    diagram.innerHTML = '';
    diagram.removeAttribute('style');
    const oldSvg = diagram.querySelector('svg'); if (oldSvg) oldSvg.remove();
    const ph = document.createElement('div'); ph.className = 'small'; ph.textContent = 'Select a path → Diagram';
    diagram.appendChild(ph);
  }

  const svgSizeEl1 = el('svgSize'); if (svgSizeEl1) svgSizeEl1.textContent = '—';
  const statusEl  = el('status');   if (statusEl)  statusEl.textContent = '—';

  try { localStorage.removeItem('envuln-lite-store'); } catch {}
  try { localStorage.removeItem(UI_STORE_KEY); } catch {}

  renderAllUI();
  if (typeof playback_resetToStart === 'function') playback_resetToStart();
  setPlaybackEnabled(false);
  setPlayPauseVisual(false);
}

/* -------------------------------------------------------------------------- */
/* Results playback (diagram paging)                                          */
/* -------------------------------------------------------------------------- */
const playback = {
  dataset: [],
  index: 0,
  playing: false,
  timer: null,
  speed: 1.0,
  baseDelayMs: 1200
};

window.__updatePlaybackButtons = () => playback_updateButtons();

function playback_setDataset(results) {
  playback.dataset = Array.isArray(results) ? results.slice() : [];
  playback.index = 0;
  playback_updateButtons();
}
function playback_current() {
  return playback.dataset[playback.index] || null;
}
function playback_renderCurrent() {
  const p = playback_current();
  const box = el('diagramBox');
  const svgSizeEl = el('svgSize');
  if (!p || !box) {
    if (box) box.innerHTML = '<div class="small">Select a path → Diagram</div>';
    if (svgSizeEl) svgSizeEl.textContent = '—';
    return;
  }
  const svgStr = buildSVGForPath(p, StateMod.State);
  box.innerHTML = svgStr;
  const svg = box.querySelector('svg');
  if (svg && svgSizeEl) {
    const w = +svg.getAttribute('width') || svg.viewBox?.baseVal?.width || svg.getBoundingClientRect().width;
    const h = +svg.getAttribute('height') || svg.viewBox?.baseVal?.height || svg.getBoundingClientRect().height;
    svgSizeEl.textContent = `${Math.round(w)} × ${Math.round(h)} px`;
  }
}
function playback_updateButtons() {
  const btnPP          = el('btnPlayPause');
  const btnStop        = el('btnStop');
  const btnRestart     = el('btnRestart');
  const btnStepBack    = el('btnStepBack');
  const btnStepForward = el('btnStepForward');

  const simRunning = (typeof simIsRunning === 'function') && simIsRunning();
  const simPaused  = (typeof simIsPaused  === 'function') && simIsPaused();
  const hasData    = playback.dataset.length > 0;

  const enableRow  = playbackControlsEnabled && (simRunning || hasData);

  [btnPP, btnStop, btnRestart, btnStepBack, btnStepForward].forEach(b => {
    if (b) b.disabled = !enableRow;
  });

  if (enableRow) {
    if (simRunning) {
      if (btnStepBack)    btnStepBack.disabled    = !(typeof simCanStepBack === 'function' && simCanStepBack());
      if (btnStepForward) btnStepForward.disabled = !(typeof simCanStepForward === 'function' && simCanStepForward());
    } else {
      if (btnStepBack)    btnStepBack.disabled    = playback.index <= 0;
      if (btnStepForward) btnStepForward.disabled = playback.index >= (playback.dataset.length - 1);
    }
  }

  if (btnPP) {
    if (simRunning) {
      btnPP.textContent = simPaused ? '▶' : '⏸';
    } else {
      btnPP.textContent = playback.playing ? '⏸' : '▶';
    }
  }
}
function playback_tick() {
  if (!playback.playing) return;
  const delay = Math.max(200, Math.floor(playback.baseDelayMs / Math.max(0.2, playback.speed)));
  clearTimeout(playback.timer);
  playback.timer = setTimeout(() => {
    playback_stepForward();
    if (playback.playing) playback_tick();
  }, delay);
}
function playback_play() {
  if (!playback.dataset.length) return;
  playback.playing = true;
  playback_updateButtons();
  setPlayPauseVisual(true);
  playback_tick();
}
function playback_pause() {
  playback.playing = false;
  clearTimeout(playback.timer);
  playback_updateButtons();
  setPlayPauseVisual(false);
}
function playback_stop() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_restart() {
  playback.index = 0;
  playback_renderCurrent();
  if (playback.playing) playback_tick();
}
function playback_stepForward() {
  if (!playback.dataset.length) return;
  if (playback.index < playback.dataset.length - 1) {
    playback.index += 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_stepBack() {
  if (!playback.dataset.length) return;
  if (playback.index > 0) {
    playback.index -= 1;
    playback_renderCurrent();
  }
  playback_updateButtons();
}
function playback_setSpeed(mult) {
  playback.speed = Math.max(0.2, Math.min(3, +mult || 1));
  const lab = el('simSpeedValue');
  if (lab) lab.textContent = `×${playback.speed.toFixed(1)}`;
  if (playback.playing) playback_tick();
}
function playback_resetToStart() {
  playback_pause();
  playback.index = 0;
  playback_renderCurrent();
}
function playback_showIndex(idx, pauseAfter = false) {
  if (!playback.dataset.length) return;
  playback.index = Math.max(0, Math.min(playback.dataset.length - 1, idx));
  playback_renderCurrent();
  if (pauseAfter) playback_pause();
}
function playback_computeIfNeededAndStart() {
  if (playback.dataset.length > 0) {
    playback_play();
    return;
  }
  const opts = {
    includeLateral: !!el('includeLateral')?.checked,
    includeContains: !!el('includeContains')?.checked
  };
  const max = parseInt(el('maxPaths')?.value || '2000', 10);
  const out = computeAllPaths(StateMod.State, opts, max);
  lastResults = out.paths || [];
  lastMeta = { cycles: !!out.cycles, truncated: !!out.truncated };

  const chkOnlyVuln = el('chkOnlyVuln');
  const hasVulnsEverywhere = p =>
    Array.isArray(p.vulnsPerNode) &&
    p.vulnsPerNode.slice(1).length > 0 &&
    p.vulnsPerNode.slice(1).every(v => Array.isArray(v) && v.length > 0);
  const display = chkOnlyVuln && chkOnlyVuln.checked
    ? lastResults.filter(hasVulnsEverywhere)
    : lastResults;

  renderResultsList(display);

  if (display.length) {
    playback_renderCurrent();
    playback_play();
  } else {
    const filterOn = !!el('chkOnlyVuln')?.checked;
    const anyExits = (StateMod.State.attackers || []).some(a => (a.exits instanceof Set ? a.exits.size : (a.exits || []).length) > 0);
    if (filterOn && (lastResults?.length || 0) > 0) {
      renderStatus('0 paths • all were excluded by "Only vulnerable paths".');
    } else if (anyExits) {
      renderStatus('0 paths • check exit nodes are actually reachable.');
    } else {
      renderStatus('0 paths • check entries, links and options.');
    }
  }
}

/* -------------------------------------------------------------------------- */
/* Wire dataset + simulation playback controls                                */
/* -------------------------------------------------------------------------- */
function wirePlaybackControls() {
  const btnPP         = el('btnPlayPause');
  const btnStop       = el('btnStop');
  const btnRestart    = el('btnRestart');
  const btnStepBack   = el('btnStepBack');
  const btnStepForward= el('btnStepForward');
  const speed         = el('simSpeed');

  if (btnPP) {
    btnPP.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        if (simIsPaused && simIsPaused()) {
          try { simPlay(); } catch {}
          setPlayPauseVisual(true);
        } else {
          try { simPause(); } catch {}
          setPlayPauseVisual(false);
        }
        playback_updateButtons();
        return;
      }
      if (playback.playing) {
        playback_pause();
      } else {
        if (!playback.dataset.length) {
          playback_computeIfNeededAndStart();
        } else {
          if (!el('diagramBox')?.querySelector('svg')) playback_renderCurrent();
          playback_play();
        }
      }
      playback_updateButtons();
    };
  }

  if (btnStop) {
    btnStop.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}
        setPlayPauseVisual(false);
        setPlaybackEnabled(false);
        playback_updateButtons();
        return;
      }
      playback_stop();
      playback_updateButtons();
    };
  }

  if (btnRestart) {
    btnRestart.onclick = async () => {
      if (simIsRunning && simIsRunning()) {
        try { simStop(); } catch {}
        try { simCleanupUI(); } catch {}

        try {
          disableTopButtons(true);
          setPlaybackEnabled(true);
          setPlayPauseVisual(true);
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulating…'; b.disabled = true; }
          await runSimulation({ renderCallback: () => renderAllUI() });
        } finally {
          const b = el('btnSimu');
          if (b) { b.textContent = 'Simulation'; b.disabled = false; }
          enableTopButtons();
          setPlayPauseVisual(false);
          setPlaybackEnabled(false);
          renderAllUI();
          playback_resetToStart?.();
          playback_updateButtons();
        }
        return;
      }
      playback_restart();
      playback_updateButtons();
    };
  }

  if (btnStepBack) {
    btnStepBack.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepBack(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepBack();
      playback_updateButtons();
    };
  }

  if (btnStepForward) {
    btnStepForward.onclick = () => {
      if (simIsRunning && simIsRunning()) {
        try { simPause(); } catch {}
        try { simStepForward(10); } catch {}
        setPlayPauseVisual(false);
        playback_updateButtons();
        return;
      }
      playback_pause();
      playback_stepForward();
      playback_updateButtons();
    };
  }

  if (speed) {
    playback_setSpeed(speed.value || 1);
    try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    const lab = el('simSpeedValue');
    if (lab) lab.textContent = `×${(+speed.value || 1).toFixed(1)}`;
    speed.addEventListener('input', () => {
      playback_setSpeed(speed.value);
      try { simSetSpeed(parseFloat(speed.value || '1') || 1); } catch {}
    });
  }

  playback_updateButtons();
  playback_renderCurrent();
}

/* -------------------------------------------------------------------------- */
/* Convenience export if needed elsewhere                                     */
/* -------------------------------------------------------------------------- */
function playback_setExternalResults(results) {
  playback_setDataset(results);
  playback_resetToStart();
}

/* -------------------------------------------------------------------------- */
/* Boot                                                                       */
/* -------------------------------------------------------------------------- */
window.__envuln_boot = {
  State: StateMod.State,
  computeAllPaths,
  playback_setExternalResults
};
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}


===== ./js/state.js =====
// js/state.js
// Global application state

import { uid } from './helpers.js';

export const State = {
  version: 4,
  attackers: [],   // { id, name, entries:Set<targetId>, exits:Set<targetId> }
  targets: [],     // { id, name, vulns:Set<vulnId>, final:boolean }
  vulns: [],       // { id, name }
  edges: {
    direct: {},
    lateral: {},
    contains: {}
  }
};

export function ensureEdgeMaps(id){
  State.edges.direct[id]   = State.edges.direct[id]   || new Set();
  State.edges.lateral[id]  = State.edges.lateral[id]  || new Set();
  State.edges.contains[id] = State.edges.contains[id] || new Set();
}

function uniqueNameExists(list, name){
  return list.some(x => x.name.trim().toLowerCase() === name.trim().toLowerCase());
}

export function createAttacker(name){
  name = name.trim();
  if(!name) throw new Error('Attacker name required');
  if(uniqueNameExists(State.attackers, name)) throw new Error('Attacker already exists');
  const id = uid();
  State.attackers.push({ id, name, entries:new Set(), exits:new Set() });
  return id;
}

export function renameAttacker(id, newName){
  const a = State.attackers.find(x=>x.id===id);
  if(!a) throw new Error('Unknown attacker');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.attackers,newName) && a.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  a.name = newName;
}

export function deleteAttacker(id){
  State.attackers = State.attackers.filter(a=>a.id!==id);
}

export function createTarget(name, isFinal=false){
  name = name.trim();
  if(!name) throw new Error('Target name required');
  if(uniqueNameExists(State.targets,name)) throw new Error('Target already exists');
  const id = uid();
  State.targets.push({ id, name, vulns:new Set(), final:!!isFinal });
  ensureEdgeMaps(id);
  return id;
}

export function renameTarget(id, newName){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  newName = newName.trim();
  if(!newName) throw new Error('Invalid name');
  if(uniqueNameExists(State.targets,newName) && t.name.toLowerCase()!==newName.toLowerCase())
    throw new Error('Name already in use');
  t.name = newName;
}

export function setTargetFinal(id, val){
  const t = State.targets.find(x=>x.id===id);
  if(!t) throw new Error('Unknown target');
  t.final = !!val;
}

export function deleteTarget(id){
  State.targets = State.targets.filter(t=>t.id!==id);
  for(const m of Object.values(State.edges)){
    delete m[id];
    for(const k in m) m[k].delete(id);
  }
  State.attackers.forEach(a => {
    a.entries?.delete(id);
    a.exits?.delete(id);
  });
}

export function createVuln(name){
  name = name.trim();
  if(!name) throw new Error('Vulnerability name required');
  if(uniqueNameExists(State.vulns,name)) throw new Error('Vulnerability already exists');
  const id = uid();
  State.vulns.push({ id, name });
  return id;
}

export function deleteVuln(id){
  State.vulns = State.vulns.filter(v=>v.id!==id);
  State.targets.forEach(t => t.vulns.delete(id));
}

export function toggleVulnOnTarget(targetId, vulnId, enable){
  const t = State.targets.find(x=>x.id===targetId);
  if(!t) throw new Error('Unknown target');
  if(!(t.vulns instanceof Set)) t.vulns = new Set(t.vulns || []);
  if(enable) t.vulns.add(vulnId); else t.vulns.delete(vulnId);
}

export function setAttackerEntries(attackerId, entryIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.entries = new Set(entryIds);
}

export function setAttackerExits(attackerId, exitIds){
  const a = State.attackers.find(x=>x.id===attackerId);
  if(!a) throw new Error('Unknown attacker');
  a.exits = new Set(exitIds);
}

export function addEdge(type, fromId, toId){
  if(!State.edges[type]) throw new Error('Invalid edge type');
  ensureEdgeMaps(fromId);
  State.edges[type][fromId].add(toId);
}

export function removeEdge(type, fromId, toId){
  if(!State.edges[type]) return;
  if(State.edges[type][fromId]) State.edges[type][fromId].delete(toId);
}

export const getAttackers = ()=> State.attackers;
export const getTargets   = ()=> State.targets;
export const getVulns     = ()=> State.vulns;

export function getTargetName(id){
  return (State.targets.find(t=>t.id===id)?.name) || '?';
}

// --- Add below: helpers for reviving JSON into live state -------------------
function asSet(x) {
  if (x instanceof Set) return x;
  if (Array.isArray(x)) return new Set(x);
  if (x && typeof x === 'object') return new Set(Object.keys(x)); // tolerate old shapes
  return new Set();
}
function reviveEdgeMap(rawMap = {}) {
  const out = {};
  for (const [fromId, tos] of Object.entries(rawMap)) {
    out[fromId] = asSet(tos);
  }
  return out;
}

// --- Exported: hydrate() to load a plain object into the live State ---------
export function hydrate(raw = {}) {
  // attackers
  State.attackers = Array.isArray(raw.attackers) ? raw.attackers.map(a => ({
    id: a.id, name: a.name,
    entries: asSet(a.entries),
    exits:   asSet(a.exits)
  })) : [];

  // targets
  State.targets = Array.isArray(raw.targets) ? raw.targets.map(t => ({
    id: t.id, name: t.name,
    vulns: asSet(t.vulns),
    final: !!t.final
  })) : [];

  // vulns
  State.vulns = Array.isArray(raw.vulns) ? raw.vulns.map(v => ({ id: v.id, name: v.name })) : [];

  // edges
  const edges = raw.edges || {};
  State.edges = {
    direct:   reviveEdgeMap(edges.direct),
    lateral:  reviveEdgeMap(edges.lateral),
    contains: reviveEdgeMap(edges.contains)
  };

  // ensure edge maps exist for every target id
  State.targets.forEach(t => ensureEdgeMaps(t.id));

  // bump/keep version
  State.version = Number.isFinite(raw.version) ? raw.version : State.version;
}

// (optional but handy) convert live state back to JSON-safe structure
export function dehydrate() {
  const edgeToObj = (m) => {
    const obj = {};
    for (const [k, v] of Object.entries(m)) obj[k] = Array.from(v || []);
    return obj;
  };
  return {
    version: State.version,
    attackers: State.attackers.map(a => ({
      id: a.id, name: a.name,
      entries: Array.from(a.entries || []),
      exits:   Array.from(a.exits   || [])
    })),
    targets: State.targets.map(t => ({
      id: t.id, name: t.name, final: !!t.final,
      vulns: Array.from(t.vulns || [])
    })),
    vulns: State.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   edgeToObj(State.edges.direct),
      lateral:  edgeToObj(State.edges.lateral),
      contains: edgeToObj(State.edges.contains)
    }
  };
}

if(typeof window !== 'undefined'){
  window.State = State;
}

===== ./js/helpers.js =====
/*************************************************************
 * helpers.js — tiny shared utilities for Envuln
 * ⚙️ 100% client-side / no UI logic / no state mutations
 *************************************************************/

/**
 * Query DOM by ID (shorter to type)
 */
export const el = id => document.getElementById(id);

/**
 * Normalized string: trim + collapse spaces
 */
export const norm = s => (s || '').trim().replace(/\s+/g, ' ');

/**
 * Cheap unique ID — enough for UI graph nodes
 */
export const uid = () =>
  Math.random().toString(36).slice(2, 9) + '-' + Date.now().toString(36);

/**
 * Escape text for safe HTML/SVG insertion (no DOMParser needed)
 */
export const esc = s =>
  String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

/**
 * Safe integer parsing with fallback
 */
export const toInt = (v, fallback = 0) => {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
};

/**
 * Clamp number between min and max
 */
export const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

/**
 * Remove duplicates while preserving order
 */
export const unique = arr => [...new Set(arr)];

/**
 * DOM: small utility to create elements faster
 * ex: div('.badge') or div({ class:'item', text:'Click!' })
 */
export function div(arg){
  const el = document.createElement('div');
  if(typeof arg === 'string'){
    el.className = arg.replace(/^\./,'');
  } else if(arg && typeof arg === 'object'){
    if(arg.class) el.className = arg.class;
    if(arg.text) el.textContent = arg.text;
    if(arg.html) el.innerHTML = arg.html;
  }
  return el;
}

/**
 * Scroll node into center view if needed (no crash if missing)
 */
export function ensureInView(node, block='center'){
  try { node?.scrollIntoView({ behavior:'smooth', block }); } catch {}
}

/**
 * Async wait helper (ms)
 */
export const wait = ms => new Promise(res => setTimeout(res, ms));

/**
 * Toggle class for a short pulse highlight
 */
export function pulse(node, duration = 600){
  if(!node) return;
  node.classList.add('sim-pulse');
  setTimeout(()=> node.classList.remove('sim-pulse'), duration);
}

===== ./js/exportODS.js =====
// exportODS.js
// Generate a Flat ODS (.fods) spreadsheet fully client-side

import { computeAllPaths, nameOfTarget } from './paths.js';

/**
 * Export results into a Flat ODS file (.fods)
 * @param {Object} state Current state (from state.js)
 * @param {Object} options Optional: { results?:Array, filter?:Function }
 *   - results: precomputed paths array (same shape as computeAllPaths(...).paths)
 *   - filter : (path) => boolean  (to include/exclude rows)
 */
export function exportODS(state, options = {}) {
  const pre = (options.results && Array.isArray(options.results)) ? options.results : null;
  const results = pre ?? computeAllPaths(state).paths;

  const filterFn = typeof options.filter === 'function' ? options.filter : () => true;

  const filtered = results.filter(filterFn);
  if (!filtered.length) {
    alert("No paths to export.");
    return;
  }

  // Helpers
  const esc = s => String(s || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

  // ===== HEADERS =====
  const headPaths  = ['#','Attacker','Chain','Length','Final','Vulnerabilities (summary)'];
  const headDetail = ['Attacker','Step','Target','Final?','Vulnerabilities'];
  const headGraph  = ['Type','Source','Destination'];

  // ===== ROW BUILDERS =====
  const rowsPaths = filtered.map((p, idx) => {
    const chain = p.nodes.map(n => n.name).join(' → ');
    const len = p.nodes.length;
    const finale = len ? p.nodes[len - 1].name : '';
    const vulnSummary = p.vulnsPerNode.map((vs, i) => {
      const n = p.nodes[i]?.name || '?';
      return `[${n}: ${vs?.length ? vs.join(', ') : '—'}]`;
    }).join(' ');
    return [ String(idx+1), p.attackerName || p.attacker || '', chain, String(len), finale, vulnSummary ];
  });

  const rowsDetail = [];
  filtered.forEach(p => {
    p.nodes.forEach((n, i) => {
      const vs = p.vulnsPerNode?.[i] || [];
      rowsDetail.push([
        p.attackerName || p.attacker || '',
        String(i + 1),
        n?.name || '',
        (i === p.nodes.length - 1) ? 'Yes' : 'No',
        vs.length ? vs.join(', ') : '—'
      ]);
    });
  });

  const rowsGraph = [];
  const pushEdges = (type, map) => {
    for (const from in map) {
      const tos = Array.isArray(map[from]) ? map[from] : Array.from(map[from] || []);
      tos.forEach(to => {
        rowsGraph.push([
          type,
          nameOfTarget(state, from),
          nameOfTarget(state, to)
        ]);
      });
    }
  };
  pushEdges('direct',   state.edges?.direct || {});
  pushEdges('lateral',  state.edges?.lateral || {});
  pushEdges('contains', state.edges?.contains || {});

  // ===== STYLE (readability) =====
  const styles = `
  <office:styles>
    <!-- Bold header -->
    <style:style style:name="hdr" style:family="table-cell">
      <style:text-properties fo:font-weight="bold"/>
      <style:table-cell-properties fo:background-color="#0b1730"
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"/>
      <style:paragraph-properties fo:margin="0cm"/>
    </style:style>

    <!-- Zebra row styles -->
    <style:style style:name="z1" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <style:style style:name="z2" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        fo:background-color="#0f223f" style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Wrapped text -->
    <style:style style:name="wrap" style:family="table-cell">
      <style:table-cell-properties
        fo:padding-left="0.1cm" fo:padding-right="0.1cm"
        fo:padding-top="0.05cm" fo:padding-bottom="0.05cm"
        style:vertical-align="top"/>
      <style:text-properties fo:font-size="10pt"/>
    </style:style>

    <!-- Column widths -->
    <style:style style:name="colNarrow" style:family="table-column">
      <style:table-column-properties style:column-width="1.2cm"/>
    </style:style>
    <style:style style:name="colMed" style:family="table-column">
      <style:table-column-properties style:column-width="4.2cm"/>
    </style:style>
    <style:style style:name="colWide" style:family="table-column">
      <style:table-column-properties style:column-width="9.5cm"/>
    </style:style>
    <style:style style:name="colXL" style:family="table-column">
      <style:table-column-properties style:column-width="14cm"/>
    </style:style>
  </office:styles>`;

  // ===== XML TABLE UTILS =====
  const mkHeader = heads => `
    <table:table-header-rows>
      <table:table-row>
        ${heads.map(h =>
          `<table:table-cell office:value-type="string" table:style-name="hdr">
             <text:p>${esc(h)}</text:p>
           </table:table-cell>`
        ).join('')}
      </table:table-row>
    </table:table-header-rows>`;

  const mkRow = (cells, zebra=false, wrapIdx=new Set()) => `
    <table:table-row>
      ${cells.map((c,i)=>{
        const style = wrapIdx.has(i) ? 'wrap' : (zebra ? 'z2' : 'z1');
        return `<table:table-cell office:value-type="string" table:style-name="${style}">
                  <text:p>${esc(c)}</text:p>
                </table:table-cell>`;
      }).join('')}
    </table:table-row>`;

  // Columns that should wrap
  const wrapPaths  = new Set([2, 5]); // Chain, Vulnerabilities (summary)
  const wrapDetail = new Set([4]);    // Vulnerabilities
  const wrapGraph  = new Set([]);     // None

  // Build table bodies
  const headerPaths  = mkHeader(headPaths);
  const bodyPaths    = rowsPaths.map((r,i)=> mkRow(r, i%2===1, wrapPaths)).join('');
  const headerDetail = mkHeader(headDetail);
  const bodyDetail   = rowsDetail.map((r,i)=> mkRow(r, i%2===1, wrapDetail)).join('');
  const headerGraph  = mkHeader(headGraph);
  const bodyGraph    = rowsGraph.map((r,i)=> mkRow(r, i%2===1, wrapGraph)).join('');

  // Column layouts
  const colsPaths = `
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsDetail = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colNarrow"/>
    <table:table-column table:style-name="colXL"/>`;

  const colsGraph = `
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>
    <table:table-column table:style-name="colMed"/>`;

  // ===== ASSEMBLY =====
  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document
 xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0"
 xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0"
 xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0"
 xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0"
 xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"
 office:version="1.2"
 office:mimetype="application/vnd.oasis.opendocument.spreadsheet">
 ${styles}
 <office:body>
   <office:spreadsheet>

     <!-- Paths sheet -->
     <table:table table:name="Paths">
       ${colsPaths}
       ${headerPaths}
       ${bodyPaths}
     </table:table>

     <!-- Detail sheet -->
     <table:table table:name="Detail">
       ${colsDetail}
       ${headerDetail}
       ${bodyDetail}
     </table:table>

     <!-- Graph sheet -->
     <table:table table:name="Graph">
       ${colsGraph}
       ${headerGraph}
       ${bodyGraph}
     </table:table>

   </office:spreadsheet>
 </office:body>
</office:document>`;

  // ===== DOWNLOAD =====
  const blob = new Blob(
    [xml],
    { type: 'application/vnd.oasis.opendocument.spreadsheet' }
  );
  const filename = `envuln-export-${new Date().toISOString().replace(/[:.]/g,'-')}.fods`;

  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

===== ./js/storage.js =====
/**
 * storage.js
 * Save and load application state to/from localStorage.
 * Converts runtime structures (Sets) to plain arrays for persistence.
 */

const KEY = 'envuln-lite-store';
const CURRENT_VERSION = 4;

/* ------------ Public API ------------ */

/**
 * Serialize runtime state to localStorage.
 * @param {object} state
 */
export function saveToLocal(state) {
  try {
    localStorage.setItem(KEY, JSON.stringify(toSerializable(state)));
  } catch (e) {
    console.warn('[storage] save error:', e);
  }
}

/**
 * Load from localStorage and convert back to runtime state.
 * @returns {object|null}
 */
export function loadFromLocal() {
  try {
    const raw = localStorage.getItem(KEY);
    if (!raw) return null;

    const obj = JSON.parse(raw);
    if (!obj.version || obj.version !== CURRENT_VERSION) {
      console.warn('[storage] version mismatch: resetting storage');
      return null;
    }
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] load error -> reset storage:', e);
    return null;
  }
}

/** Clear storage */
export function clearLocal() {
  localStorage.removeItem(KEY);
}

/** Export JSON to a downloadable file */
export function exportJSON(state) {
  const serial = toSerializable(state);
  const blob = new Blob([JSON.stringify(serial, null, 2)], { type: 'application/json' });
  const ts = new Date().toISOString().replace(/[:.]/g, '-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `envuln-export-${ts}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/**
 * Convert a JSON string previously exported back into runtime state.
 * The caller is responsible for assigning it to the live singleton.
 */
export function importJSON(jsonStr) {
  try {
    const obj = JSON.parse(jsonStr);
    return fromSerializable(obj);
  } catch (e) {
    console.warn('[storage] invalid import JSON', e);
    return null;
  }
}

/* ------------ Runtime → serial ------------ */

function toSerializable(state) {
  return {
    version: CURRENT_VERSION,
    attackers: state.attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: [...a.entries],
      exits:   [...a.exits]
    })),
    targets: state.targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: [...t.vulns],
      final: !!t.final
    })),
    vulns: state.vulns.map(v => ({ id: v.id, name: v.name })),
    edges: {
      direct:   setsToArrays(state.edges.direct),
      lateral:  setsToArrays(state.edges.lateral),
      contains: setsToArrays(state.edges.contains),
    }
  };
}

/* ------------ Serial → runtime ------------ */

function fromSerializable(obj) {
  if (!obj || typeof obj !== 'object') {
    console.warn('[storage] fromSerializable failed');
    return null;
  }

  const {
    attackers = [],
    targets = [],
    vulns = [],
    edges = {}
  } = obj;

  return {
    version: obj.version ?? CURRENT_VERSION,
    vulns: vulns.map(v => ({ id: v.id, name: v.name })),
    targets: targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: new Set(t.vulns || []),
      final: !!t.final
    })),
    attackers: attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: new Set(a.entries || []),
      exits:   new Set(a.exits   || [])
    })),
    edges: {
      direct:   arraysToSets(edges.direct   || {}),
      lateral:  arraysToSets(edges.lateral  || {}),
      contains: arraysToSets(edges.contains || {})
    }
  };
}

/* ------------ Helpers ------------ */

function setsToArrays(map) {
  const out = {};
  for (const k in map) {
    out[k] = [...(map[k] || [])];
  }
  return out;
}

function arraysToSets(map) {
  const out = {};
  for (const k in map) {
    out[k] = new Set(map[k] || []);
  }
  return out;
}

/* ---------------------------
   Selective JSON export/import
   --------------------------- */

/* Build a serializable object that contains only requested domains.
   domains: Set or Array of strings: 'attackers', 'targets', 'vulns', 'edges'
   Returns a plain object ready to JSON.stringify.
*/
export function toSerializableSelective(state, domains = []) {
  const want = new Set(Array.isArray(domains) ? domains : Array.from(domains || []));
  const serial = { version: CURRENT_VERSION };

  if (want.has('vulns') || want.has('all')) {
    serial.vulns = state.vulns.map(v => ({ id: v.id, name: v.name }));
  } else {
    serial.vulns = [];
  }

  if (want.has('targets') || want.has('all')) {
    serial.targets = state.targets.map(t => ({
      id: t.id,
      name: t.name,
      vulns: [...(t.vulns || [])],
      final: !!t.final
    }));
  } else {
    serial.targets = [];
  }

  if (want.has('attackers') || want.has('all')) {
    serial.attackers = state.attackers.map(a => ({
      id: a.id,
      name: a.name,
      entries: [...(a.entries || [])],
      exits:   [...(a.exits   || [])]
    }));
  } else {
    serial.attackers = [];
  }

  // Always export edges if targets included (otherwise empty)
  if (want.has('edges') || want.has('targets') || want.has('all')) {
    const setsToArraysLocal = (map) => {
      const out = {};
      Object.keys(map || {}).forEach(k => {
        const v = map[k];
        out[k] = Array.isArray(v) ? v.slice() : Array.from(v || []);
      });
      return out;
    };
    serial.edges = {
      direct:   setsToArraysLocal(state.edges.direct),
      lateral:  setsToArraysLocal(state.edges.lateral),
      contains: setsToArraysLocal(state.edges.contains)
    };
  } else {
    serial.edges = { direct:{}, lateral:{}, contains:{} };
  }

  return serial;
}

/**
 * Download a selective JSON file.
 * domains: array of domain keys to include (attackers, targets, vulns, edges, or 'all')
 */
export function exportJSONSelective(state, domains = ['all']) {
  const serial = toSerializableSelective(state, domains);
  const blob = new Blob([JSON.stringify(serial, null, 2)], { type: 'application/json' });
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `envuln-export-${ts}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

/**
 * Parse a JSON string and return a partial serial object that contains only
 * the domains available in the file and optionally filtered by requested domains.
 * requestedDomains: array of 'attackers'|'targets'|'vulns'|'edges'|'all'
 * Returns { ok:true, payload: {version, attackers, targets, vulns, edges} } or { ok:false, error:.. }
 */
export function parseImportJSONPartial(jsonStr, requestedDomains = ['all']) {
  try {
    const obj = JSON.parse(jsonStr);
    if (!obj || typeof obj !== 'object') return { ok:false, error: 'invalid json' };
    const want = new Set(Array.isArray(requestedDomains) ? requestedDomains : [requestedDomains]);

    const pick = (key) => {
      if (want.has('all') || want.has(key)) {
        return Array.isArray(obj[key]) ? obj[key] : [];
      }
      return [];
    };

    // edges may be absent → normalize
    const rawEdges = obj.edges || {};
    const normalizeEdges = (m) => {
      const out = {};
      if (!m || typeof m !== 'object') return { direct:{}, lateral:{}, contains:{} };
      out.direct = m.direct || {};
      out.lateral = m.lateral || {};
      out.contains = m.contains || {};
      return out;
    };

    const payload = {
      version: typeof obj.version === 'number' ? obj.version : CURRENT_VERSION,
      attackers: pick('attackers'),
      targets: pick('targets'),
      vulns: pick('vulns'),
      edges: normalizeEdges(rawEdges)
    };

    return { ok:true, payload };
  } catch (e) {
    return { ok:false, error: e?.message || String(e) };
  }
}


===== ./styles/app.css =====
/* =====================
   Global theme
===================== */
:root {
  --bg: #071022;
  --panel: #0d1726;
  --muted: #9fb0c6;
  --accent: #2b8af6;
  --glass: rgba(255,255,255,0.03);

  --border-light: rgba(255,255,255,0.06);
  --border-soft: rgba(255,255,255,0.04);
  --border-strong: rgba(255,255,255,0.08);

  --text-main: #e6eef8;
  --text-muted: #9fb0c6;

  --shadow: 0 6px 18px rgba(0,0,0,0.6);
  --radius: 10px;
}

html, body {
  margin: 0;
  height: 100%;
  font-family: Inter, system-ui, Arial, sans-serif;
  background: linear-gradient(180deg, #041022, #021018);
  color: var(--text-main);
  user-select: none;
}

/* =====================
   Layout
===================== */
.wrap {
  display: grid;
  height: 100vh;
  box-sizing: border-box;
  padding: 18px;
  grid-template-columns: 300px 1fr 380px;
  gap: 16px;
}

.panel {
  min-height: 0;
  padding: 12px;
  overflow: auto;
  border-radius: var(--radius);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  box-shadow: var(--shadow);
}

/* Responsive */
@media (max-width: 1100px) {
  .wrap {
    grid-template-columns: 1fr;
    grid-auto-rows: minmax(0, auto);
  }
}

/* =====================
   Typography
===================== */
h3 {
  margin: 6px 0 10px;
  font-size: 14px;
  font-weight: 600;
}

.small {
  font-size: 13px;
  color: var(--text-muted);
}

.mini {
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Controls
===================== */
input[type=text],
input[type=number],
input[type=range],
select,
textarea {
  width: 100%;
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-light);
  background: rgba(255,255,255,0.02);
  color: inherit;
  box-sizing: border-box;
}

button {
  background: var(--accent);
  border: none;
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: opacity .2s ease;
}
button:hover {
  opacity: 0.9;
}

button.ghost {
  background: transparent;
  border: 1px dashed var(--border-light);
  color: var(--text-muted);
}
button.ghost:hover {
  color: #fff;
  border-color: var(--accent);
}

/* =====================
   Lists & Items
===================== */
.list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  background: var(--glass);
  padding: 8px;
  border-radius: 8px;
  border: 1px solid var(--border-soft);
}

.item .left {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.badge {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: var(--text-muted);
}

/* =====================
   Result cards
===================== */
.path-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.path {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  align-items: flex-start;
  padding: 8px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-soft);
}

.path .left {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* =====================
   Diagram panel
===================== */
.uml {
  overflow-x: auto;
  overflow-y: hidden;
  min-height: 260px;
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius);
  padding: 8px;
}

/* =====================
   Simulation visual markers
===================== */
.sim-pulse {
  box-shadow: 0 0 0 3px rgba(59,130,246,0.35) !important;
}

/* nice scrolling everywhere */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.12);
  border-radius: 8px;
}
::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.22);
}

/* small fade hover on list items */
.item:hover,
.path:hover {
  background: rgba(255,255,255,0.04);
}

/* =====================
   Playback
===================== */
/* Playback disabled look */
#playbackRow.is-disabled {
  opacity: 0.45;
  filter: grayscale(0.6);
  pointer-events: none; /* clicks blocked while disabled */
}

/* Align items inside attacker/target/vulnerability lists */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#panelEntities .list > div {
  display: flex;
  flex-direction: column;
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  padding: 10px 12px;
  position: relative;
}

/* Force actions to right side — horizontally aligned */
#panelEntities .list > div button {
  align-self: flex-end; /* right-align actions */
  margin-top: 6px;      /* spacing from text */
}

/* Ensure Rename and Delete align together nicely */
#panelEntities .list > div button + button {
  margin-left: 8px;
}

/* ===============================
   Compact lists in the left panel
==================================== */

#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;                 /* space between cards */
}

#panelEntities .list > div {
  position: relative;        /* required to position the buttons on the right */
  padding: 12px 180px 12px 14px; /* space reserved on the right for the buttons */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* Title + meta on a single line when possible */
#panelEntities .list > div > div {
  display: inline;           /* “Attacker A  Entries: …” stays on the same line */
}

/* Right-aligned buttons, same line, no wrapper needed */
#panelEntities .list > div > button:nth-last-of-type(2) {
  position: absolute;
  top: 12px;
  right: 96px;               /* positions the “Rename” button to the left of Delete */
}
#panelEntities .list > div > button:last-of-type {
  position: absolute;
  top: 12px;
  right: 14px;               /* “Delete” button on the far right */
}

/* Small visual adjustments */
#panelEntities .list > div > button {
  margin: 0;                 /* removes vertical margin that added unnecessary spacing */
}

/* === Left panel list cards: full width, no squeeze === */
#panelEntities .list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Carte = grid: [contenu flexible] [Rename] [Delete]  */
#panelEntities .list > div {
  display: grid;
  grid-template-columns: 1fr auto auto; /* contenu prend toute la largeur */
  align-items: start;
  gap: 10px;
  padding: 12px;                /* ← plus de padding droit réservé */
  border-radius: 14px;
  background: rgba(255,255,255,.03);
  position: static;             /* ← plus d'absolu */
}

/* Colonne contenu = prend tout l'espace  */
#panelEntities .list > div .left {
  grid-column: 1 / 2;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  min-width: 0;                 /* ← autorise l'expansion */
}

/* Les deux boutons sur la droite, alignés en haut */
#panelEntities .list > div > button {
  position: static;             /* ← supprime l'absolu */
  align-self: start;
  margin: 0;
}
#panelEntities .list > div > button:nth-last-of-type(2) { grid-column: 2 / 3; }
#panelEntities .list > div > button:last-of-type       { grid-column: 3 / 4; }

/* Ajustements de texte/badges pour éviter les colonnes étroites */
#panelEntities .list .badge { display: inline-block; }
#panelEntities .list .mini  { white-space: normal; word-break: break-word; }

/* Optionnel: cartes génériques .item → s'étirent aussi */
.item {
  display: grid;
  grid-template-columns: 1fr auto; /* contenu + actions */
  align-items: start;
  gap: 10px;
}
.item .left { min-width: 0; }

@media (max-width: 520px) {
  #panelEntities .list > div {
    grid-template-columns: 1fr;    /* contenu pleine largeur */
  }
  #panelEntities .list > div > button {
    grid-column: 1 / -1;           /* boutons passent dessous */
    justify-self: end;
  }
}

/* === Left panel: cartes pleine largeur, contenu fluide === */

/* 1) Annule les anciens hacks (inline/absolute/padding réservé) */
#panelEntities .list > div > div { display: block !important; }
#panelEntities .list > div > button { position: static !important; }
#panelEntities .list > div { padding-right: 12px !important; }

/* 2) La carte .item devient une grid: [contenu][Rename][Delete] */
#panelEntities .list .item {
  display: grid !important;
  grid-template-columns: 1fr auto auto;   /* contenu prend tout, boutons autos */
  align-items: start;
  gap: 12px;
  padding: 12px;
  border-radius: 14px;
  background: rgba(255,255,255,.03);
}

/* 3) Colonne contenu: laisse respirer le texte */
#panelEntities .list .item .left {
  min-width: 0;            /* autorise l’expansion */
  display: flex;
  flex-direction: column;  /* badge au-dessus, mini dessous */
  gap: 6px;
}

/* 4) Texte des "mini" non étriqué */
#panelEntities .list .mini {
  white-space: normal;     /* pas de contrainte inline */
  word-break: break-word;
  line-height: 1.25;
}

/* 5) Groupe de boutons alignés à droite sans chevauchement */
#panelEntities .list .item > div:last-child {
  display: flex;
  gap: 8px;
  align-items: start;
}

/* Option mobile: empile les boutons sous le contenu */
@media (max-width: 560px) {
  #panelEntities .list .item {
    grid-template-columns: 1fr;
  }
  #panelEntities .list .item > div:last-child {
    justify-self: end;
  }
}


