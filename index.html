<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>⋊ENVULN</title>

<style>
  :root{
    --accent:#2563eb;
    --muted:#94a3b8;
    --bg:#0f172a;
    --glass:rgba(255,255,255,0.06);
  }

  /* ===== Base ===== */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;
  }
  body{
    background:linear-gradient(180deg,#071024 0%, #071827 40%, #02111b 100%);
    color:#e6eef8;
    padding:18px;
    box-sizing:border-box;
  }

  /* ===== Layout principal ===== */
  .app{
    display:grid;
    /* minmax(0,1fr) permet à la colonne centrale de RÉTRÉCIR (sinon la page s'élargit) */
    grid-template-columns:380px minmax(0,1fr) 460px;
    gap:18px;
    height:calc(100vh - 36px);
  }
  @media (max-width:1400px){
    .app{ grid-template-columns:320px minmax(0,1fr) 380px; }
  }
  @media (max-width:1100px){
    .app{
      grid-template-columns:1fr;      /* pile : gauche / centre / droite */
      grid-auto-rows:minmax(0, auto);
      height:auto;
    }
  }

  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:14px;
    box-shadow:0 6px 24px rgba(2,6,23,0.6);
    overflow:auto;   /* chaque panneau peut scroller en interne */
    min-height:0;    /* indispensable en grid pour autoriser le scroll */
    min-width:0;     /* permet au contenu de ne PAS forcer la largeur de la colonne */
  }

  h2{ margin:4px 0 12px; font-size:16px; }
  .small{ font-size:13px; color:var(--muted); }

  /* ===== Listes ===== */
  .list{ display:flex; flex-direction:column; gap:8px; }
  .item{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px; border-radius:8px; background:var(--glass);
    backdrop-filter:blur(6px);
    border:1px solid rgba(255,255,255,0.08);
  }
  .item .name{
    font-size:14px; inline-size:70%;
    overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
  }

  /* ===== Grilles utilitaires ===== */
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .col{ display:flex; flex-direction:column; gap:8px; }
  .spacer{ flex:1; }

  /* ===== Formes ===== */
  button{
    background:var(--accent); color:#fff; border:none;
    padding:8px 10px; border-radius:8px; cursor:pointer;
  }
  button.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.12);
    color:var(--muted);
  }
  button.ghost{
    background:transparent;
    border:1px dashed rgba(255,255,255,0.20);
    color:var(--muted);
  }
  input[type=text], input[type=number], textarea, select{
    width:100%; padding:8px; border-radius:8px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(255,255,255,0.02);
    color:inherit;
  }
  select{ min-height:200px; }

  /* ===== Chemins ===== */
  .path-list{ display:flex; flex-direction:column; gap:6px; }
  .path-entry{
    padding:8px; border-radius:8px; background:rgba(255,255,255,0.02);
    display:flex; justify-content:space-between; align-items:center; gap:10px;
  }

  /* ===== UML : conteneur scrollable horizontal, responsive ===== */
  .uml{
    background:rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.10);
    border-radius:12px;
    padding:8px 8px 48px;
    overflow-x:auto;   /* <-- la barre de défilement horizontale est ici */
    overflow-y:hidden; /* inutile de scroller en vertical dans ce cadre */
    width:100%;
    max-width:100%;
    min-width:0;       /* ne jamais forcer la colonne à s'élargir */
  }
  /* IMPORTANT : ne réduis PAS le SVG à 100% de la largeur du conteneur */
  .uml svg{
    display:block;
    max-width:none;      /* annule tout shrink-to-fit */
    width:auto;          /* largeur dictée par l'attribut width du <svg> (JS) */
    height:auto;
  }
  .uml svg .note{ font-size:11px; }

  /* ===== Badges / légende ===== */
  .badge{
    padding:4px 8px;
    border:1px solid rgba(255,255,255,0.12);
    border-radius:999px;
    font-size:12px;
  }
  .warn{ color:#fbbf24; }
  .legend{ display:flex; gap:8px; align-items:center; margin-left:8px; }
  .legend .dot{ width:14px; height:8px; border-radius:4px; }
  .legend .dash{ border-bottom:3px dashed #fbbf24; width:24px; }

  /* ===== Contrôle de simulation ===== */
  .sim-controls{ display:flex; align-items:center; gap:8px; margin-left:10px; }
  .sim-controls input[type=range]{ width:140px; accent-color:var(--accent); }

  /* ===== ÉDITEUR CIBLE : 3 colonnes pleines largeur ===== */
  /* (tes règles d’éditeur conservées telles quelles) */

  /* 1) La rangée qui contient [selectTarget] [label Final] [bloc 3 colonnes] */
  div.panel > div > div.row[style*="margin-top:6px"][style*="flex-wrap:wrap"]{ align-items:stretch; }
  /* 2) Le sélecteur de cible + la case finale passent au-dessus, full width */
  div.panel > div > div.row[style*="margin-top:6px"][style*="flex-wrap:wrap"] > select#selectTarget,
  div.panel > div > div.row[style*="margin-top:6px"][style*="flex-wrap:wrap"] > label.small{ flex:0 0 100%; }
  /* 3) Le sous-conteneur prend 100% */
  div.panel > div > div.row[style*="margin-top:6px"][style*="flex-wrap:wrap"] > div[style*="min-width:420px"]{
    flex:1 1 100%; margin-left:0;
  }
  /* 4) Grille stricte 3 colonnes alignées */
  div.row[style*="min-width:420px"][style*="align-items:flex-start"]{
    display:grid !important;
    grid-template-columns:repeat(3, 1fr);
    grid-template-rows:auto 1fr auto;
    gap:12px; align-items:start;
  }
  /* Colonnes */
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > div:nth-child(1){ grid-column:1; grid-row:1 / span 2; }
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > div:nth-child(3){ grid-column:2; grid-row:1 / span 2; }
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > div:nth-child(5){ grid-column:3; grid-row:1 / span 2; }
  /* Boutons */
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > .col:nth-child(2){ grid-column:1; grid-row:3; }
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > .col:nth-child(4){ grid-column:2; grid-row:3; }
  div.row[style*="min-width:420px"][style*="align-items:flex-start"] > .col:nth-child(6){ grid-column:3; grid-row:3; }
  /* Labels / selects */
  div.row[style*="min-width:420px"] > div > label.small{
    display:flex; align-items:flex-end; min-height:44px; margin:0 0 6px; line-height:1.2; white-space:normal;
  }
  div.row[style*="min-width:420px"] > div > select{
    min-height:260px; max-height:360px; padding:8px; border-radius:10px;
    border:1px solid rgba(255,255,255,0.16);
    background:rgba(255,255,255,0.04); width:100%;
  }
  div.row[style*="min-width:420px"] .col{ display:flex; flex-wrap:wrap; gap:8px; }
  div.row[style*="min-width:420px"] .col button.ghost{ font-size:12px; padding:6px 8px; border-radius:8px; }
  div.row[style*="min-width:420px"] .col button:not(.ghost){ width:100%; }
  /* Responsive : 1 colonne sous 1100px */
  @media (max-width:1100px){
    div.row[style*="min-width:420px"][style*="align-items:flex-start"]{
      grid-template-columns:1fr;
      grid-template-rows:repeat(6, auto);
    }
    div.row[style*="min-width:420px"] > *{ grid-column:1 !important; grid-row:auto !important; }
    div.row[style*="min-width:420px"] > div > label.small{ min-height:0; }
    div.row[style*="min-width:420px"] > div > select{ min-height:220px; }
  }

  /* ===== Simulation : aides visuelles ===== */
  .sim-click{ outline:2px solid rgba(59,130,246,.5); }
  .sim-pulse{ box-shadow:0 0 0 3px rgba(59,130,246,.35)!important; }

  /* ===== Compat Safari (backdrop-filter) ===== */
  @supports (-webkit-backdrop-filter: blur(0)){
    .item{
      -webkit-backdrop-filter:none !important;
      backdrop-filter:none !important;
      background:rgba(255,255,255,0.08) !important;
    }
  }
  
 .uml{
  /* …tes styles existants… */
  min-height: 420px;     /* <- nouveau */
}
</style>


</head>
<body>
  <!-- Topbar -->
  <div class="row" style="justify-content:space-between;margin-bottom:12px;gap:12px;flex-wrap:wrap">
    <div>
      <strong>⋊ENVULN</strong>
      <div class="small">Modélisateur de menaces, moyens, cibles, vulnérabilités, l’outil énumère tous les chemins atteignant une cible finale, directement ou par latéralisation.</div>
    </div>
    <div class="row">
      <span class="small" id="counts">—</span>
      <button id="exportBtn" title="Export des listes (menaces, cibles, vulnérabilités) en YAML">Exporter YAML</button>
      <button id="importBtn" class="secondary" title="Importer des listes YAML (menaces, cibles, vulnérabilités)">Importer YAML</button>
      <button id="simulateBtn" class="secondary" title="Lancer une simulation aléatoire">Simulation</button>
      <div class="sim-controls">
        <label class="small" for="simSpeed">Vitesse</label>
        <input id="simSpeed" type="range" min="0.1" max="2.5" step="0.1" value="1">
        <span id="simSpeedValue" class="small">×1.0</span>
      </div>

      <!-- YAML + JSON (compat) -->
      <input
        id="importFile"
        type="file"
        accept=".yml,.yaml,text/yaml,text/x-yaml,application/x-yaml,application/yaml,application/json,text/plain"
        style="display:none"
      />
    </div>
  </div>

  <!-- App -->
  <div class="app">
    <!-- Gauche : données -->
    <div class="panel">
      <h2>Données</h2>
      <div class="row">
        <input id="quickSearch" placeholder="Rechercher…" />
        <button id="clearAll" class="secondary">Réinitialiser</button>
      </div>

      <div class="col" style="margin-top:10px">
        <div>
          <label class="small">Nouvelle menace</label>
          <div class="row">
            <input id="threatName" placeholder="Nom de la menace" />
            <button id="addThreat">Ajouter</button>
          </div>
          <div class="row">
            <input id="meanName" placeholder="Ajouter un moyen à la menace sélectionnée" />
            <button id="addMeanToThreat" class="ghost">+ Moyen</button>
          </div>
        </div>

        <div>
          <label class="small">Nouvelle cible</label>
          <div class="row">
            <input id="targetName" placeholder="Nom de la cible" />
            <button id="addTarget">Ajouter</button>
          </div>
          <div class="row">
            <label class="small"><input type="checkbox" id="targetFinalFlag" /> Cible finale par défaut</label>
          </div>
        </div>

        <div>
          <label class="small">Nouvelle vulnérabilité</label>
          <div class="row">
            <input id="vulnName" placeholder="Nom de la vulnérabilité" />
            <button id="addVuln">Ajouter</button>
          </div>
        </div>

        <hr style="opacity:.08;margin:10px 0" />

        <div>
          <h2>Menaces</h2>
          <div id="threatList" class="list"></div>
        </div>

        <div>
          <h2>Cibles</h2>
          <div id="targetList" class="list"></div>
        </div>

        <div>
          <h2>Vulnérabilités</h2>
          <div id="vulnList" class="list"></div>
        </div>
      </div>
    </div>

    <!-- Centre : associations & calcul -->
    <div class="panel" style="display:flex;flex-direction:column;gap:12px">
      <h2>Associations & Calcul</h2>

      <!-- Menace -> moyens & cibles de départ -->
      <div>
        <div class="small">Sélectionnez une menace pour lui associer des <strong>moyens</strong> et des <strong>cibles de départ</strong>.</div>
        <div class="row" style="margin-top:6px; gap:12px; align-items:flex-start; flex-wrap:wrap">
          <select id="selectThreat" style="min-width:260px"></select>
          <div class="row" style="flex:1;min-width:300px;align-items:flex-start">
            <div style="flex:1">
              <label class="small">Cibles disponibles</label>
              <select id="selectStartPool" multiple size="6" style="width:100%"></select>
            </div>
            <div class="col" style="min-width:90px;margin-top:18px">
              <button id="btnAddStart">→ Ajouter</button>
              <button id="btnRemoveStart" class="secondary">← Retirer</button>
            </div>
            <div style="flex:1">
              <label class="small">Cibles de départ de la menace</label>
              <select id="selectStarts" multiple size="6" style="width:100%"></select>
            </div>
          </div>
        </div>
      </div>

      <!-- Cible -> vulnérabilités & liens -->
      <div>
        <div class="small">Associez la <strong>cible</strong> à ses <strong>vulnérabilités</strong> et à ses liens sortants : <em>normaux</em> et <em>latéraux</em>.</div>
        <div class="row" style="margin-top:6px; gap:12px; align-items:flex-start; flex-wrap:wrap">
          <select id="selectTarget" style="min-width:260px"></select>
          <label class="small"><input type="checkbox" id="flagFinal" /> Cible finale</label>

          <!-- Sous-conteneur 3 colonnes -->
          <div class="row" style="flex:1;min-width:420px;align-items:flex-start">
            <div style="flex:1">
              <label class="small">Vulnérabilités</label>
              <select id="selectVulns" multiple size="6" style="width:100%"></select>
            </div>
            <div class="col" style="min-width:110px;margin-top:18px">
              <button id="selAllV" class="ghost">Tout</button>
              <button id="unselAllV" class="ghost">Aucun</button>
              <button id="saveTargetV">Sauvegarder</button>
            </div>

            <div style="flex:1">
              <label class="small">Liens normaux (cette cible → …)</label>
              <select id="selectEdges" multiple size="6" style="width:100%"></select>
            </div>
            <div class="col" style="min-width:110px;margin-top:18px">
              <button id="selAllE" class="ghost">Tout</button>
              <button id="unselAllE" class="ghost">Aucun</button>
              <button id="saveEdges">Sauvegarder</button>
            </div>

            <div style="flex:1">
              <label class="small">Liens latéraux (cette cible → …)</label>
              <select id="selectLateral" multiple size="6" style="width:100%"></select>
            </div>
            <div class="col" style="min-width:110px;margin-top:18px">
              <button id="selAllL" class="ghost">Tout</button>
              <button id="unselAllL" class="ghost">Aucun</button>
              <button id="saveLateral">Sauvegarder</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Calcul chemins -->
      <div>
        <h2>Découverte des chemins</h2>
        <div class="row">
          <label class="small">Plafond de chemins (anti-explosion)</label>
          <input id="maxPaths" type="number" min="100" value="5000" style="width:110px" />
          <label class="small">Inclure liens latéraux</label>
          <input id="includeLateral" type="checkbox" checked />
          <div class="spacer"></div>
          <div class="legend">
            <div class="dot" style="background:#3b82f6"></div><div class="small">lien normal</div>
            <div class="dash"></div><div class="small">lien latéral</div>
          </div>
          <button id="btnFindPaths">Trouver tous les chemins</button>
        </div>
        <div class="small" id="algoHint">—</div>
      </div>

      <!-- Liste chemins -->
      <div>
        <h2>Chemins trouvés</h2>
        <div class="row small"><span id="summary">—</span><span class="spacer"></span><span id="cycleWarn" class="small warn"></span></div>
        <div id="pathList" class="path-list"></div>
      </div>

      <!-- UML -->
      <div>
        <h2>Diagramme UML (SVG)</h2>
        <div class="row">
          <button id="btnDiagramSelected" class="secondary">SVG du chemin sélectionné</button>
          <button id="btnDownloadSVG" class="secondary">Télécharger SVG</button>
          <span class="spacer"></span><span id="svgSize" class="small">—</span>
        </div>
        <div id="umlContainer" class="uml" aria-live="polite"><div class="small">Sélectionnez un chemin pour générer le diagramme.</div></div>
      </div>
    </div>

    <!-- Droite : détails & aide -->
    <div class="panel">
      <h2>Détails</h2>
      <div id="details" class="small">Sélectionnez une menace / cible dans les listes pour afficher les associations.</div>
      <hr style="opacity:.08;margin:12px 0" />
      <h2>Aide rapide</h2>
      <div class="small">
        <ol>
          <li>Créez Menaces (puis ajoutez des Moyens), Cibles, Vulnérabilités.</li>
          <li>Pour chaque menace, définissez ses <em>cibles de départ</em>.</li>
          <li>Pour chaque cible, cochez ses vulnérabilités, ses <em>liens normaux</em> et ses <em>liens latéraux</em>.</li>
          <li>Cliquez “Trouver tous les chemins”. L'option "Inclure liens latéraux" compte les latéraux comme arêtes dans le graphe.</li>
          <li>Affichez le SVG d’un chemin et téléchargez-le. Les liens latéraux sont en pointillés.</li>
        </ol>
      </div>
    </div>
  </div>

<script>
/* ========================== APP SCRIPT (COMPLET) ========================== */
/* API publique conservée : addThreat, addMeanToSelectedThreat, addTarget, addVuln, hydrateThreatStarts, hydrateTargetEditors, saveTargetVulns, saveEdges, saveLateral, findAllPaths, renderUMLForPath */
(() => {
/* ---------- State ---------- */
let state = {
  version: 7,
  threats: [], // {id,name,means:Set(meanId), starts:Set(targetId)}
  means: [],   // {id,name}
  targets: [], // {id,name,final:boolean}
  vulns: [],   // {id,name}
  targetVulns: {}, // targetId -> Set(vulnId)
  edges: {},       // fromId -> Set(toId) (normaux)
  lateralEdges: {} // fromId -> Set(toId) (latéraux)
};

/* ---------- DOM helpers ---------- */
const el = id => document.getElementById(id);
const uid = () => Math.random().toString(36).slice(2, 11) + "-" + Date.now().toString(36);
const norm = s => (s || "").trim().replace(/\s+/g, " ");
const byId = (arr, id) => arr.find(x => x.id === id);

/* ---------- Rendering Lists ---------- */
function makeItemList(listEl, items, type) {
  const q = (el('quickSearch')?.value || '').trim().toLowerCase();
  const filtered = q ? items.filter(it => it.name.toLowerCase().includes(q)) : items;

  listEl.innerHTML = '';
  filtered.forEach(it => {
    const div = document.createElement('div');
    div.className = 'item';

    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = it.name + (type==='target' && it.final ? ' (finale)' : '');

    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.gap = '8px';

    const edit = document.createElement('button');
    edit.className = 'secondary';
    edit.textContent = 'Éditer';
    edit.onclick = () => editItem(type, it.id);

    const del = document.createElement('button');
    del.textContent = 'Suppr';
    del.onclick = () => { if (confirm('Supprimer "' + it.name + '" ?')) deleteItem(type, it.id); };

    right.append(edit, del);
    div.append(name, right);
    listEl.appendChild(div);

    div.onclick = () => showDetails(type, it.id);
  });
}

function refreshLists() {
  makeItemList(el('threatList'), state.threats, 'threat');
  makeItemList(el('targetList'), state.targets, 'target');
  makeItemList(el('vulnList'), state.vulns, 'vuln');

  // Sélecteurs simples
  const sThreat = el('selectThreat');
  if (sThreat) sThreat.innerHTML = '';
  const addOpt = (sel, obj) => {
    const o = document.createElement('option');
    o.value = obj.id;
    o.textContent = obj.name;
    sel.appendChild(o);
  };
  state.threats.forEach(t => addOpt(sThreat, t));

  // Pools & Editors
  const selStartPool = el('selectStartPool');
  if (selStartPool) selStartPool.innerHTML = '';
  const selStarts = el('selectStarts');
  if (selStarts) selStarts.innerHTML = '';
  state.targets.forEach(t => addOpt(selStartPool, t));

  const sTarget = el('selectTarget');
  if (sTarget) sTarget.innerHTML = '';
  state.targets.forEach(t => addOpt(sTarget, t));

  const sV = el('selectVulns');
  if (sV) sV.innerHTML = '';
  state.vulns.forEach(v => addOpt(sV, v));

  // Liens normaux / latéraux — peupler séparément
  const sEdges = el('selectEdges');
  if (sEdges) sEdges.innerHTML = '';
  const sLateral = el('selectLateral');
  if (sLateral) sLateral.innerHTML = '';
  state.targets.forEach(t => { addOpt(sEdges, t); });
  state.targets.forEach(t => { addOpt(sLateral, t); });

  updateCounts();
}

function updateCounts(){
  const counts = `${state.threats.length} menaces • ${state.means.length} moyens • ${state.targets.length} cibles • ${state.vulns.length} vulnérabilités`;
  const cEl = el('counts');
  if(cEl) cEl.textContent = counts;
}

/* ---------- CRUD ---------- */
function existsName(arr, name) {
  const n = norm(name).toLowerCase();
  return arr.some(x => x.name.toLowerCase() === n);
}

function addThreat(name) {
  name = norm(name);
  if (!name) return alert('Nom requis.');
  if (existsName(state.threats, name)) return alert('Menace existante.');
  state.threats.push({ id: uid(), name, means: new Set(), starts: new Set() });
  save();
  refreshLists();
}

function addMeanToSelectedThreat(name) {
  name = norm(name);
  if (!name) return;
  const thId = el('selectThreat')?.value || (state.threats[0] && state.threats[0].id);
  if (!thId) return alert('Sélectionnez d’abord une menace.');

  let mean = state.means.find(m => m.name.toLowerCase() === name.toLowerCase());
  if (!mean) {
    mean = { id: uid(), name };
    state.means.push(mean);
  }
  const th = byId(state.threats, thId);
  th.means.add(mean.id);
  save();
  showDetails('threat', thId);
  refreshLists();
}

function addTarget(name, finalFlag) {
  name = norm(name);
  if (!name) return alert('Nom requis.');
  if (existsName(state.targets, name)) return alert('Cible existante.');
  const id = uid();
  state.targets.push({ id, name, final: !!finalFlag });
  state.targetVulns[id] = state.targetVulns[id] || new Set();
  state.edges[id] = state.edges[id] || new Set();
  state.lateralEdges[id] = state.lateralEdges[id] || new Set();
  save();
  refreshLists();
}

function addVuln(name) {
  name = norm(name);
  if (!name) return alert('Nom requis.');
  if (existsName(state.vulns, name)) return alert('Vulnérabilité existante.');
  state.vulns.push({ id: uid(), name });
  save();
  refreshLists();
}

function editItem(type, id) {
  const arr = type === 'threat' ? state.threats : type === 'target' ? state.targets : state.vulns;
  const it = byId(arr, id);
  if (!it) return;
  const nn = prompt('Renommer', it.name);
  if (nn == null) return;
  const name = norm(nn);
  if (!name) return alert('Nom invalide.');
  if (existsName(arr, name)) return alert('Nom déjà utilisé.');
  it.name = name;
  save();
  refreshLists();
  showDetails(type, id);
}

function deleteItem(type, id) {
  if (type === 'threat') {
    state.threats = state.threats.filter(x => x.id !== id);
  } else if (type === 'target') {
    state.targets = state.targets.filter(x => x.id !== id);
    delete state.targetVulns[id];
    delete state.edges[id];
    delete state.lateralEdges[id];
    for (const k in state.edges) state.edges[k] = new Set([...(state.edges[k] || new Set())].filter(x => x !== id));
    for (const k in state.lateralEdges) state.lateralEdges[k] = new Set([...(state.lateralEdges[k] || new Set())].filter(x => x !== id));
    for (const th of state.threats) th.starts = new Set([...(th.starts || new Set())].filter(x => x !== id));
  } else {
    state.vulns = state.vulns.filter(x => x.id !== id);
    for (const k in state.targetVulns) state.targetVulns[k] = new Set([...(state.targetVulns[k] || new Set())].filter(x => x !== id));
  }
  save();
  refreshLists();
}

/* ---------- Details ---------- */
function showDetails(type, id) {
  const d = el('details');
  if (!d) return;

  if (type === 'threat') {
    const t = byId(state.threats, id);
    if (!t) return;
    const means = [...(t.means || [])].map(mid => (byId(state.means, mid) || { name: '(supprimé)' }).name);
    const starts = [...(t.starts || [])].map(sid => (byId(state.targets, sid) || { name: '(supprimée)' }).name);
    d.innerHTML = `<strong>Menace :</strong> ${t.name}<br><span class="small">Moyens : ${means.length ? means.join(', ') : '<i>aucun</i>'} • Cibles de départ : ${starts.length ? starts.join(', ') : '<i>aucune</i>'}</span>`;
    if (el('selectThreat')) {
      el('selectThreat').value = t.id;
      hydrateThreatStarts(t.id);
    }
  } else if (type === 'target') {
    const tg = byId(state.targets, id);
    if (!tg) return;
    const vs = [...(state.targetVulns[id] || new Set())].map(v => (byId(state.vulns, v) || { name: '(supprimée)' }).name);
    const outs = [...(state.edges[id] || new Set())].map(tid => (byId(state.targets, tid) || { name: '(supprimée)' }).name);
    const louts = [...(state.lateralEdges[id] || new Set())].map(tid => (byId(state.targets, tid) || { name: '(supprimée)' }).name);
    d.innerHTML = `<strong>Cible :</strong> ${tg.name} ${tg.final ? '<span class="badge">finale</span>' : ''}<br><span class="small">Vulnérabilités : ${vs.length ? vs.join(', ') : '<i>aucune</i>'}</span><br><span class="small">Liens normaux : ${outs.length ? outs.join(', ') : '<i>aucun</i>'} • Liens latéraux : ${louts.length ? louts.join(', ') : '<i>aucun</i>'}</span>`;
    if (el('selectTarget')) {
      el('selectTarget').value = id;
      hydrateTargetEditors(id);
    }
  } else if (type === 'vuln') {
    const v = byId(state.vulns, id);
    if (!v) return;
    d.innerHTML = `<strong>Vulnérabilité :</strong> ${v.name}`;
  }
}

/* ---------- Assocs: menace -> starts ---------- */
function hydrateThreatStarts(thId) {
  const t = byId(state.threats, thId);
  if (!t) return;
  const pool = el('selectStartPool');
  const startsSel = el('selectStarts');
  if (!pool || !startsSel) return;

  pool.innerHTML = '';
  startsSel.innerHTML = '';
  const addOpt = (sel, obj) => {
    const o = document.createElement('option');
    o.value = obj.id;
    o.textContent = obj.name;
    sel.appendChild(o);
  };

  const inStart = new Set(t.starts || []);
  state.targets.forEach(tg => { if (!inStart.has(tg.id)) addOpt(pool, tg); });
  state.targets.forEach(tg => { if (inStart.has(tg.id)) addOpt(startsSel, tg); });
}

function addStart() {
  const thId = el('selectThreat')?.value;
  if (!thId) return;
  const th = byId(state.threats, thId);
  th.starts = th.starts || new Set();
  const sel = [...el('selectStartPool').selectedOptions].map(o => o.value);
  sel.forEach(id => th.starts.add(id));
  save();
  hydrateThreatStarts(thId);
  showDetails('threat', thId);
}

function removeStart() {
  const thId = el('selectThreat')?.value;
  if (!thId) return;
  const th = byId(state.threats, thId);
  th.starts = th.starts || new Set();
  const rem = new Set([...el('selectStarts').selectedOptions].map(o => o.value));
  th.starts = new Set([...th.starts].filter(x => !rem.has(x)));
  save();
  hydrateThreatStarts(thId);
  showDetails('threat', thId);
}

/* ---------- Assocs: cible -> vulns & edges & lateral ---------- */
function hydrateTargetEditors(tId) {
  const tg = byId(state.targets, tId);
  if (!tg) return;

  if (el('flagFinal')) el('flagFinal').checked = !!tg.final;

  // Vulns
  const vset = state.targetVulns[tId] || new Set();
  const sV = el('selectVulns');
  if (sV) for (const o of sV.options) o.selected = vset.has(o.value);

  // Edges (disable self)
  const sE = el('selectEdges');
  if (sE) {
    for (const o of sE.options) {
      o.disabled = (o.value === tId);
      o.selected = false;
    }
    const eSet = state.edges[tId] || new Set();
    for (const o of sE.options) if (eSet.has(o.value)) o.selected = true;
  }

  // Lateral
  const sL = el('selectLateral');
  if (sL) {
    for (const o of sL.options) {
      o.disabled = (o.value === tId);
      o.selected = false;
    }
    const lSet = state.lateralEdges[tId] || new Set();
    for (const o of sL.options) if (lSet.has(o.value)) o.selected = true;
  }
}

function saveTargetVulns() {
  const tId = el('selectTarget')?.value;
  if (!tId) return;
  state.targetVulns[tId] = new Set([...el('selectVulns').options].filter(o => o.selected).map(o => o.value));
  const tg = byId(state.targets, tId);
  if (tg && el('flagFinal')) tg.final = el('flagFinal').checked;
  save();
  showDetails('target', tId);
}

function saveEdges() {
  const tId = el('selectTarget')?.value;
  if (!tId) return;
  const outs = [...el('selectEdges').options].filter(o => o.selected && o.value !== tId).map(o => o.value);
  state.edges[tId] = new Set(outs);
  const tg = byId(state.targets, tId);
  if (tg && el('flagFinal')) tg.final = el('flagFinal').checked;
  save();
  showDetails('target', tId);
}

function saveLateral() {
  const tId = el('selectTarget')?.value;
  if (!tId) return;
  const outs = [...el('selectLateral').options].filter(o => o.selected && o.value !== tId).map(o => o.value);
  state.lateralEdges[tId] = new Set(outs);
  const tg = byId(state.targets, tId);
  if (tg && el('flagFinal')) tg.final = el('flagFinal').checked;
  save();
  showDetails('target', tId);
}

/* ---------- Persist ---------- */
function serialize() {
  return {
    version: state.version,
    threats: state.threats.map(t => ({
      id: t.id,
      name: t.name,
      means: [...(t.means || new Set())],
      starts: [...(t.starts || new Set())]
    })),
    means: state.means,
    targets: state.targets,
    vulns: state.vulns,
    targetVulns: Object.fromEntries(Object.entries(state.targetVulns).map(([k, v]) => [k, [...v]])),
    edges: Object.fromEntries(Object.entries(state.edges).map(([k, v]) => [k, [...v]])),
    lateralEdges: Object.fromEntries(Object.entries(state.lateralEdges).map(([k, v]) => [k, [...v]]))
  };
}

function save() {
  try {
    localStorage.setItem('mmcv-lat', JSON.stringify(serialize()));
  } catch (e) {
    console.warn(e);
  }
}

function load() {
  try {
    const s = localStorage.getItem('mmcv-lat');
    if (!s) return;
    const o = JSON.parse(s);
    state.means = o.means || [];
    state.vulns = o.vulns || [];
    state.targets = o.targets || [];
    state.threats = (o.threats || []).map(t => ({ id: t.id, name: t.name, means: new Set(t.means || []), starts: new Set(t.starts || []) }));
    state.targetVulns = {};
    for (const k in (o.targetVulns || {})) state.targetVulns[k] = new Set(o.targetVulns[k]);
    state.edges = {};
    for (const k in (o.edges || {})) state.edges[k] = new Set(o.edges[k]);
    state.lateralEdges = {};
    for (const k in (o.lateralEdges || {})) state.lateralEdges[k] = new Set(o.lateralEdges[k]);
  } catch (e) {
    console.warn(e);
  }
}

/* ---------- Import / Export YAML (listes simples) + compat JSON ---------- */
function yamlEscape(s){
  if (/^[\w .\-\/]+$/.test(s)) return s; // simple
  return JSON.stringify(s); // fallback robuste
}

function exportYAML(){
  const threats = state.threats.map(t => ` - ${yamlEscape(t.name)}`).join('\n');
  const targets = state.targets.map(t => ` - ${yamlEscape(t.name)}`).join('\n');
  const vulns = state.vulns.map(v => ` - ${yamlEscape(v.name)}`).join('\n');

  const yaml = [
    '# Export ⋊ENVULN — listes simples sans id/metadata',
    'threats:',
    threats || ' -',
    'targets:',
    targets || ' -',
    'vulns:',
    vulns || ' -',
    ''
  ].join('\n');

  const blob = new Blob([yaml], { type: 'text/yaml' });
  const ts = new Date().toISOString().replace(/[:.]/g, '-');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `envuln-${ts}.yml`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
}

function parseSimpleYAML(text){
  const out = { threats: [], targets: [], vulns: [] };
  const keys = new Set(['threats','targets','vulns']);
  const trimmed = text.trim();
  // Si JSON, laisser le fallback JSON gérer
  if (trimmed.startsWith('{') || trimmed.startsWith('[')) return null;

  const lines = text.replace(/\r/g,'').split('\n');
  let current = null;
  for (let raw of lines){
    const line = raw.replace(/#.*$/, ''); // retire commentaires
    if (!line.trim()) continue;

    const mKey = line.match(/^\s*([A-Za-z][\w-]*)\s*:\s*(.*)$/);
    if (mKey){
      const k = mKey[1].toLowerCase();
      const rest = (mKey[2] || '').trim();
      current = keys.has(k) ? k : null;
      // tableau inline: [ "a", 'b', c ]
      if (current && rest.startsWith('[') && rest.endsWith(']')){
        const inside = rest.slice(1,-1);
        inside.split(',').forEach(tok=>{
          const v = tok.trim().replace(/^['"]|['"]$/g,'');
          if (v) out[current].push(v);
        });
        current = null;
      }
      continue;
    }

    const mItem = line.match(/^\s*-\s*(.+)$/);
    if (mItem && current){
      const v = mItem[1].trim().replace(/^['"]|['"]$/g,'');
      if (v) out[current].push(v);
      continue;
    }
  }
  return out;
}

function importDataText(txt){
  // 1) Essayer YAML simple (ajout/merge par noms)
  const y = parseSimpleYAML(txt);
  if (y){
    const addUniqueByName = (arr, name) => {
      const n = (name||'').trim().replace(/\s+/g,' ');
      if(!n) return;
      if (!arr.some(x => x.name.toLowerCase() === n.toLowerCase())){
        if (arr === state.threats){
          state.threats.push({ id: uid(), name: n, means: new Set(), starts: new Set() });
        } else if (arr === state.targets){
          const id = uid();
          state.targets.push({ id, name: n, final: false });
          state.targetVulns[id] = state.targetVulns[id] || new Set();
          state.edges[id] = state.edges[id] || new Set();
          state.lateralEdges[id] = state.lateralEdges[id] || new Set();
        } else if (arr === state.vulns){
          state.vulns.push({ id: uid(), name: n });
        }
      }
    };

    (y.threats||[]).forEach(n => addUniqueByName(state.threats, n));
    (y.targets||[]).forEach(n => addUniqueByName(state.targets, n));
    (y.vulns ||[]).forEach(n => addUniqueByName(state.vulns, n));

    save();
    refreshLists();
    if (el('umlContainer')) el('umlContainer').innerHTML = '<div class="small">Import YAML terminé.</div>';
    return true;
  }

  // 2) Fallback JSON (ancien format complet)
  try{
    const o = JSON.parse(txt);
    state.means = o.means || [];
    state.vulns = o.vulns || [];
    state.targets = o.targets || [];
    state.threats = (o.threats || []).map(t => ({ id: t.id, name: t.name, means: new Set(t.means || []), starts: new Set(t.starts || []) }));
    state.targetVulns = {};
    for (const k in (o.targetVulns || {})) state.targetVulns[k] = new Set(o.targetVulns[k]);
    state.edges = {};
    for (const k in (o.edges || {})) state.edges[k] = new Set(o.edges[k]);
    state.lateralEdges = {};
    for (const k in (o.lateralEdges || {})) state.lateralEdges[k] = new Set(o.lateralEdges[k]);
    save();
    refreshLists();
    if (el('umlContainer')) el('umlContainer').innerHTML = '<div class="small">Import JSON (compat) terminé.</div>';
    return true;
  } catch(e){
    // pas JSON
    return false;
  }
}

function importDataFile(file){
  const reader = new FileReader();
  reader.onload = e => {
    const txt = e.target.result || '';
    const ok = importDataText(txt);
    if(!ok) alert('Format non reconnu (YAML simple ou JSON attendu).');
  };
  reader.readAsText(file);
}

/* ---------- Path Finding (DAG + DFS) ---------- */
function adjacencyOf(id, includeLateral) {
  const outs = new Set([...(state.edges[id] || new Set())]);
  if (includeLateral) for (const v of (state.lateralEdges[id] || new Set())) outs.add(v);
  return [...outs];
}

function isDAG(includeLateral) {
  const WHITE = 0, GRAY = 1, BLACK = 2;
  const color = {};
  state.targets.forEach(t => color[t.id] = WHITE);
  let hasCycle = false;

  function dfs(u) {
    color[u] = GRAY;
    for (const v of adjacencyOf(u, includeLateral)) {
      if (color[v] === GRAY) {
        hasCycle = true;
        return;
      }
      if (color[v] === WHITE) dfs(v);
      if (hasCycle) return;
    }
    color[u] = BLACK;
  }

  state.targets.forEach(t => {
    if (color[t.id] === WHITE) dfs(t.id);
  });
  return !hasCycle;
}

function enumeratePaths_DAG_from(startId, memo, includeLateral) {
  if (memo.has(startId)) return memo.get(startId);
  let res = [];
  const outs = adjacencyOf(startId, includeLateral);
  const isFinal = (byId(state.targets, startId) || {}).final;
  if (outs.length === 0 || isFinal) res.push([startId]);
  for (const v of outs) {
    const sub = enumeratePaths_DAG_from(v, memo, includeLateral);
    for (const path of sub) res.push([startId, ...path]);
  }
  memo.set(startId, res);
  return res;
}

function enumeratePaths_DAG(starts, includeLateral) {
  const memo = new Map();
  let all = [];
  for (const s of starts) all = all.concat(enumeratePaths_DAG_from(s, memo, includeLateral));
  return all;
}

function enumeratePaths_General(starts, includeLateral, maxPaths) {
  let all = [];
  let cycles = false;
  const adj = id => adjacencyOf(id, includeLateral);

  function dfs(u, visited, stack) {
    if (all.length >= maxPaths) return;
    const isFinal = (byId(state.targets, u) || {}).final;
    const outs = adj(u);
    if (outs.length === 0 || isFinal) {
      all.push([...stack, u]);
      return;
    }
    visited.add(u);
    for (const v of outs) {
      if (visited.has(v)) {
        cycles = true;
        continue;
      }
      dfs(v, visited, [...stack, u]);
      if (all.length >= maxPaths) break;
    }
    visited.delete(u);
  }

  for (const s of starts) {
    dfs(s, new Set(), []);
    if (all.length >= maxPaths) break;
  }
  return { paths: all, cycles };
}

function findAllPathsForThreat(th, includeLateral, maxPaths) {
  const starts = [...(th.starts || new Set())];
  const dag = isDAG(includeLateral);

  const hint = el('algoHint');
  if (hint) hint.textContent = dag
    ? 'Graphe (latéraux = ' + (includeLateral ? 'oui' : 'non') + ') détecté comme DAG : mémoïsation utilisée.'
    : 'Graphe avec cycles : DFS de chemins simples (pruning, plafond appliqué).';

  let pathNodes = [], cycles = false;
  if (dag) {
    pathNodes = enumeratePaths_DAG(starts, includeLateral);
  } else {
    const out = enumeratePaths_General(starts, includeLateral, maxPaths);
    pathNodes = out.paths;
    cycles = out.cycles;
  }

  const paths = pathNodes.map(nodes => ({
    threatId: th.id,
    threatName: th.name,
    means: [...(th.means || new Set())].map(id => (byId(state.means, id) || { name: '(supprimé)' }).name),
    nodes: nodes.map(id => byId(state.targets, id)).filter(Boolean),
    vulnsPerNode: nodes.map(id => [...(state.targetVulns[id] || new Set())].map(v => (byId(state.vulns, v) || { name: '(supprimée)' }).name)),
  }));

  return { paths, cycles, truncated: (!dag && pathNodes.length >= maxPaths) };
}

function findAllPaths() {
  const includeLateral = !!el('includeLateral')?.checked;
  const maxPaths = Math.max(100, parseInt(el('maxPaths')?.value || '5000', 10));
  let all = [];
  let sawCycles = false, truncated = false;

  for (const th of state.threats) {
    const out = findAllPathsForThreat(th, includeLateral, maxPaths);
    all.push(...out.paths);
    if (out.cycles) sawCycles = true;
    if (out.truncated) truncated = true;
  }
  renderPaths(all, sawCycles, truncated);
}

/* ---------- Render Path List + UML ---------- */
let selectedPath = null;

function renderPaths(paths, sawCycles, truncated) {
  const box = el('pathList');
  if (!box) return;
  box.innerHTML = '';

  const summary = el('summary');
  if (summary) summary.textContent = `${paths.length} chemins complets trouvés`;

  const warn = el('cycleWarn');
  if (warn) warn.textContent = sawCycles ? 'Cycles détectés : chemins simples uniquement.' : (truncated ? 'Résultat tronqué par le plafond.' : '');

  paths.forEach(p => {
    const row = document.createElement('div');
    row.className = 'path-entry';

    const left = document.createElement('div');
    const chain = p.nodes.map(n => n.name).join(' → ');
    const vulnStr = p.vulnsPerNode.map((vs, i) => vs.length ? `[${p.nodes[i].name}: ${vs.join(', ')}]` : `[${p.nodes[i].name}: —]`).join(' ');
    left.innerHTML = `<strong>${p.threatName}</strong> — ${p.means.join(', ') || '<i>aucun moyen</i>'}<br><span class="small">${chain}</span><br><span class="small">${vulnStr}</span>`;

    const right = document.createElement('div');
    const btn = document.createElement('button');
    btn.className = 'secondary';
    btn.textContent = 'Diagramme';
    btn.onclick = () => {
      selectedPath = p;
      renderUMLForPath(p);
    };
    right.appendChild(btn);

    row.append(left, right);
    box.appendChild(row);
  });
}

/* ======================= UML======================= */
function renderUMLForPath(p) {
  // ——— paramètres visuels de base (inchangés sémantiquement) ———
  const padX = 24, padY = 24;
  const boxW = 240, boxH = 80;
  const gap = 68;
  const noteLineH = 16, vPad = 12;
  const corner = 12;
  const fontFamily = 'Inter, ui-sans-serif, system-ui';

  // Étapes (identique)
  const steps = [
    { kind: 'threat', title: 'Menace', subtitle: p.threatName },
    { kind: 'means',  title: 'Moyens',  subtitle: (p.means.join(', ') || '—') },
    ...p.nodes.map((n, i) => ({
      kind: 'target',
      title: `Cible ${i + 1}${i === p.nodes.length - 1 ? ' (finale)' : ''}`,
      subtitle: n.name,
      vulns: p.vulnsPerNode[i],
      id: n.id,
      isFinal: i === p.nodes.length - 1
    }))
  ];

  const notes = steps.map(s =>
    s.kind === 'target'
      ? (s.vulns && s.vulns.length ? `Vulnérabilités:\n- ${s.vulns.join('\n- ')}` : 'Aucune vulnérabilité')
      : ''
  );

  // ——— dimensions de base (non scalées) ———
  const noteHeights = notes.map(n => n ? (n.split('\n').length * noteLineH + 12) : 0);
  const maxNoteH = Math.max(28, ...noteHeights);
  const baseH = padY * 2 + boxH + (p.nodes.length ? (vPad + maxNoteH) : 0);
  const baseW = padX * 2 + steps.length * boxW + (steps.length - 1) * gap;

  // ——— SCALE auto pour tenir en hauteur “normale” ———
  const container = el('umlContainer');
  // hauteur visible cible (on garde un peu de marge dans le panneau)
  const targetH = (() => {
    const h = (container?.clientHeight || 0);
    // si le panneau est petit, prend une valeur sûre ; sinon garde ~70% de la hauteur utile
    if (h <= 0) return 260;
    return Math.max(220, Math.min(340, Math.floor(h * 0.72)));
  })();
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const SCALE = clamp(targetH / baseH, 1.1, 3.0); // bornes raisonnables

  // ——— dimensions finales (scalées) ———
  const totalW = Math.round(baseW * SCALE);
  const totalH = Math.round(baseH * SCALE);

  // utilitaires
  const esc = s => String(s || '').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
  const wrap = (text, max = 30) => {
    const t = String(text || '');
    if (t.length <= max) return [t];
    const words = t.split(/\s+/); const lines = []; let cur = '';
    for (const w of words) {
      if ((cur + ' ' + w).trim().length > max) { if (cur) lines.push(cur); cur = w; }
      else cur = (cur ? cur + ' ' : '') + w;
    }
    if (cur) lines.push(cur);
    return lines.slice(0, 3);
  };

  // arêtes latérales entre cibles consécutives
  const nodeIds = p.nodes.map(n => n.id);
  const lateralBetween = [];
  for (let i = 0; i < nodeIds.length - 1; i++) {
    const from = nodeIds[i], to = nodeIds[i + 1];
    const latSet = state.lateralEdges[from] || new Set();
    lateralBetween[i] = latSet.has(to);
  }

  // ——— SVG : viewBox sur base, width/height scalés (zoom propre) ———
  let x = padX, y = padY;
let svg = `
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 ${baseW} ${baseH}"
     width="${totalW}" height="${totalH}"
     role="img" aria-label="Chemin UML (latéralisation)"
     style="display:block;background:#0b1224;border-radius:14px">
  <defs>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.35"/>
    </filter>
    <linearGradient id="gradTarget" x1="0" x2="0" y1="0" y2="1">
      <stop offset="0%"  stop-color="#0b1730"/><stop offset="100%" stop-color="#0e223d"/>
    </linearGradient>
    <marker id="arrowHead" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
      <polygon points="0,0 12,4 0,8" fill="#a7b8cf"/></marker>
    <marker id="arrowHeadLat" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
      <polygon points="0,0 12,4 0,8" fill="#fbbf24"/></marker>
    <style>
      .box{fill:#0b1730;stroke:#3b82f6;stroke-width:1.4;rx:${corner};ry:${corner}}
      .box-means{fill:#0b1730;stroke:#a855f7;stroke-width:1.4;rx:${corner};ry:${corner}}
      .box-target{fill:url(#gradTarget);stroke:#22c55e;stroke-width:1.4;rx:${corner};ry:${corner}}
      .box-final{stroke:#16a34a;stroke-width:2}
      .title{font:600 14px ${fontFamily};fill:#e6eef8}
      .subtitle{font:12px ${fontFamily};fill:#9fb0c6}
      .arrow{stroke:#a7b8cf;stroke-width:1.6;marker-end:url(#arrowHead)}
      .arrow-lat{stroke:#fbbf24;stroke-width:1.4;stroke-dasharray:6 4;marker-end:url(#arrowHeadLat)}
      .note-bg{fill:#0f223f;stroke:#28466b;stroke-width:1;rx:8;ry:8}
      .note{font:12px ${fontFamily};fill:#cbd5e1;white-space:pre}
    </style>
  </defs>`;

  function box(cls, title, subtitle, isFinal) {
    svg += `<rect class="${cls} ${isFinal ? 'box-final' : ''}" x="${x}" y="${y}" width="${boxW}" height="${boxH}" filter="url(#shadow)"/>`;
    const tLines = wrap(title, 28), sLines = wrap(subtitle, 32);
    let ty = y + 22;
    tLines.forEach((ln, idx) => { svg += `<text class="title" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += (idx === tLines.length - 1 ? 18 : 16); });
    sLines.forEach(ln => { svg += `<text class="subtitle" x="${x + 12}" y="${ty}">${esc(ln)}</text>`; ty += 14; });
  }

  steps.forEach((s, i) => {
    const cls = s.kind === 'threat' ? 'box' : s.kind === 'means' ? 'box-means' : 'box-target';
    box(cls, s.title, s.subtitle, s.isFinal);

    if (s.kind === 'target') {
      const note = notes[i];
      const ny = y + boxH + vPad, nx = x + 8, nWidth = boxW - 16;
      const lines = (note || '').split('\n').map(esc);
      const nh = (lines.length * noteLineH) + 12;
      svg += `<rect class="note-bg" x="${nx - 6}" y="${ny - 14}" width="${nWidth + 12}" height="${nh}"/>`;
      let lY = ny; lines.forEach(ln => { svg += `<text class="note" x="${nx}" y="${lY}">${ln}</text>`; lY += noteLineH; });
    }

    if (i < steps.length - 1) {
      const nx = x + boxW + gap;
      let isLat = false;
      if (s.kind === 'target') {
        const idx = i - 2;
        if (idx >= 0 && idx < lateralBetween.length) isLat = !!lateralBetween[idx];
      }
      const midY = y + boxH / 2;
      const clsArrow = isLat ? 'arrow-lat' : 'arrow';
      const c1x = x + boxW + gap / 2;
      const c1y = midY + (isLat ? -12 : 0);
      const pathD = `M ${x + boxW} ${midY} Q ${c1x} ${c1y} ${nx} ${midY}`;
      svg += `<path class="${clsArrow}" d="${pathD}"/>`;
      x = nx;
    }
  });

  svg += `</svg>`;

  // ——— Injection et comportement de scroll ———
  if (container) {
    // forcer le conteneur à clipper et scroller horizontalement
    container.style.overflowX = 'auto';
    container.style.overflowY = 'hidden';
    container.style.whiteSpace = 'nowrap';
    container.innerHTML = svg;

    // centrer la vue (voir la portion du milieu au départ)
    requestAnimationFrame(() => {
      container.scrollLeft = Math.max(0, (container.scrollWidth - container.clientWidth) / 2);
    });

    // bonus : Shift + molette => scroll horizontal
    container.onwheel = (ev) => {
      if (ev.shiftKey) {
        container.scrollLeft += ev.deltaY;
        ev.preventDefault();
      }
    };
  }

  const size = el('svgSize');
  if (size) size.textContent = `${totalW}×${totalH}px`;
}


/* ---------- Wiring UI ---------- */
function wire() {
  el('addThreat').onclick = () => {
    addThreat(el('threatName').value);
    el('threatName').value='';
  };
  el('addMeanToThreat').onclick = () => {
    addMeanToSelectedThreat(el('meanName').value);
    el('meanName').value='';
  };
  el('addTarget').onclick = () => {
    addTarget(el('targetName').value, el('targetFinalFlag').checked);
    el('targetName').value='';
    el('targetFinalFlag').checked=false;
  };
  el('addVuln').onclick = () => {
    addVuln(el('vulnName').value);
    el('vulnName').value='';
  };

  el('selectThreat').onchange = () => hydrateThreatStarts(el('selectThreat').value);
  el('btnAddStart').onclick = addStart;
  el('btnRemoveStart').onclick = removeStart;

  el('selectTarget').onchange = () => hydrateTargetEditors(el('selectTarget').value);

  el('selAllV').onclick = () => { for (const o of el('selectVulns').options) o.selected = true; };
  el('unselAllV').onclick = () => { for (const o of el('selectVulns').options) o.selected = false; };

  el('selAllE').onclick = () => { for (const o of el('selectEdges').options) if (!o.disabled) o.selected = true; };
  el('unselAllE').onclick = () => { for (const o of el('selectEdges').options) o.selected = false; };

  el('selAllL').onclick = () => { for (const o of el('selectLateral').options) if (!o.disabled) o.selected = true; };
  el('unselAllL').onclick = () => { for (const o of el('selectLateral').options) o.selected = false; };

  el('saveTargetV').onclick = saveTargetVulns;
  el('saveEdges').onclick = saveEdges;
  el('saveLateral').onclick = saveLateral;

  el('btnFindPaths').onclick = findAllPaths;

  el('btnDiagramSelected').onclick = () => {
    if (!selectedPath) return alert('Sélectionnez un chemin dans la liste.');
    renderUMLForPath(selectedPath);
  };

  el('btnDownloadSVG').onclick = () => {
    const node = el('umlContainer').querySelector('svg');
    if (!node) return alert('Générez un diagramme d’abord.');
    const blob = new Blob([node.outerHTML], { type: 'image/svg+xml' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `chemin-uml-lat-${ts}.svg`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 0);
  };

  el('quickSearch').addEventListener('input', refreshLists);

  el('clearAll').onclick = () => {
    if (!confirm('Tout réinitialiser ?')) return;
    state = { version: 7, threats: [], means: [], targets: [], vulns: [], targetVulns: {}, edges: {}, lateralEdges: {} };
    save();
    refreshLists();
    if (el('umlContainer')) el('umlContainer').innerHTML = '<div class="small">Réinitialisé.</div>';
    if (el('summary')) el('summary').textContent = '—';
    if (el('algoHint')) el('algoHint').textContent = '—';
    if (el('pathList')) el('pathList').innerHTML = '';
  };

  // Import/Export (YAML + compat JSON)
  el('exportBtn').onclick = exportYAML;
  el('importBtn').onclick = () => el('importFile').click();
  el('importFile').onchange = (e) => {
    if (e.target.files.length) importDataFile(e.target.files[0]);
    e.target.value = null;
  };
}

/* ---------- Seed realistic dataset if empty ---------- */
function seedIfEmpty() {
  if (state.targets.length || state.threats.length || state.vulns.length) return;

  // Targets
  const T = n => {
    const id = uid();
    state.targets.push({ id, name: n, final: false });
    state.edges[id] = new Set();
    state.lateralEdges[id] = new Set();
    state.targetVulns[id] = new Set();
    return id;
  };
  const TF = n => {
    const id = uid();
    state.targets.push({ id, name: n, final: true });
    state.edges[id] = new Set();
    state.lateralEdges[id] = new Set();
    state.targetVulns[id] = new Set();
    return id;
  };

  const tEmail = T('Email Gateway');
  const tWeb = T('Serveur Web DMZ');
  const tWks = T('Poste Utilisateur');
  const tAD = T('Contrôleur de Domaine');
  const tDB = T('Base de Données');
  const tFiles = T('Serveur de Fichiers');
  const tVPN = T('VPN Appliance');
  const tConsole = TF('Console Admin');

  // Vulns
  const V = n => {
    const id = uid();
    state.vulns.push({ id, name: n });
    return id;
  };
  const vPhish = V('Phishing (HTML/Doc Macro)');
  const vXSS = V('XSS stockée');
  const vSQLi = V('Injection SQL');
  const vCred = V('Réutilisation d’identifiants');
  const vCVE = V('CVE non patchée');
  const vWeakVPN = V('VPN config faible');

  // Attach vulns to targets
  state.targetVulns[tEmail].add(vPhish);
  state.targetVulns[tWeb].add(vXSS);
  state.targetVulns[tWeb].add(vCVE);
  state.targetVulns[tWks].add(vCred);
  state.targetVulns[tDB].add(vSQLi);
  state.targetVulns[tDB].add(vCred);
  state.targetVulns[tVPN].add(vWeakVPN);
  state.targetVulns[tConsole].add(vCred);

  // Edges (normaux)
  state.edges[tEmail].add(tWks);
  state.edges[tWeb].add(tDB);
  state.edges[tDB].add(tConsole);
  state.edges[tVPN].add(tAD);

  // Lateral
  state.lateralEdges[tWks].add(tFiles);
  state.lateralEdges[tFiles].add(tAD);
  state.lateralEdges[tAD].add(tConsole);
  state.lateralEdges[tWeb].add(tWks);

  // Threat + means + start
  const th = { id: uid(), name: 'Opérateur APT', means: new Set(), starts: new Set([tEmail, tWeb]) };
  state.threats.push(th);
  const m1 = { id: uid(), name: 'Botnet' }, m2 = { id: uid(), name: 'Kit de Phishing' };
  state.means.push(m1, m2);
  th.means.add(m1.id);
  th.means.add(m2.id);

  save();
}

/* ---------- Init ---------- */
load();
seedIfEmpty();
refreshLists();
wire();

// Pré-sélection pour détails/éditeurs
if (state.threats[0]) {
  el('selectThreat').value = state.threats[0].id;
  hydrateThreatStarts(state.threats[0].id);
}
if (state.targets[0]) {
  el('selectTarget').value = state.targets[0].id;
  hydrateTargetEditors(state.targets[0].id);
}

/* ---------- Expose public API ---------- */
Object.assign(window, {
  addThreat,
  addMeanToSelectedThreat,
  addTarget,
  addVuln,
  hydrateThreatStarts,
  hydrateTargetEditors,
  saveTargetVulns,
  saveEdges,
  saveLateral,
  findAllPaths,
  renderUMLForPath
});
})();
</script>


<script>
/* ====================== SIMULATION ULTRA RÉALISTE & DENSE ====================== */
/* Requiert que le script principal ait exposé l’API :
   addThreat, addMeanToSelectedThreat, addTarget, addVuln,
   hydrateThreatStarts, hydrateTargetEditors,
   saveTargetVulns, saveEdges, saveLateral,
   findAllPaths, renderUMLForPath
*/

(function(){
  const $ = id => document.getElementById(id);

  /* ====== Vitesse live ====== */
  let speed = 1;
  const updateSpeedUI = () => {
    const v = $('simSpeed')?.value || 1;
    $('simSpeedValue') && ($('simSpeedValue').textContent = `×${Number(v).toFixed(1)}`);
  };
  $('simSpeed') && $('simSpeed').addEventListener('input', (e)=>{ speed = parseFloat(e.target.value)||1; updateSpeedUI(); });
  updateSpeedUI();

  const wait = ms => new Promise(res=>setTimeout(res, ms / Math.max(0.05, speed)));

  /* ====== Aides visuelles ====== */
  function ensureInView(el, block='center'){ if(el) try{ el.scrollIntoView({behavior:'smooth', block}); }catch{} }
  function pulse(el){ if(!el) return; el.classList.add('sim-pulse'); setTimeout(()=>el.classList.remove('sim-pulse'), 650/Math.max(0.05,speed)); }

  // Curseur + bulle de légende
  const cursor = document.createElement('div'), caption = document.createElement('div');
  Object.assign(cursor.style,{
    position:'fixed',width:'14px',height:'14px',borderRadius:'50%',
    background:'#fff',boxShadow:'0 0 0 2px rgba(0,0,0,.5), 0 0 12px rgba(255,255,255,.35)',
    zIndex:99999,left:'0',top:'0',transform:'translate(-50%,-50%)',pointerEvents:'none'
  });
  Object.assign(caption.style,{
    position:'fixed',zIndex:99998,background:'rgba(15,23,42,.92)',color:'#e6eef8',
    border:'1px solid rgba(255,255,255,.15)',borderRadius:'10px',
    font:'13px/1.35 Inter, ui-sans-serif',padding:'8px 10px',maxWidth:'360px',
    transform:'translate(-50%, calc(-100% - 16px))',pointerEvents:'none',opacity:'0',
    transition:'opacity .16s ease'
  });
  document.body.append(caption, cursor);
  const style = document.createElement('style');
  style.textContent = `.sim-click{outline:2px solid rgba(59,130,246,.5)}`;
  document.head.appendChild(style);

  async function moveToEl(el, offsetX=0, offsetY=0){
    if(!el){ await wait(120); return; }
    const r = el.getBoundingClientRect();
    const x = Math.round(r.left + r.width/2 + offsetX);
    const y = Math.round(r.top + r.height/2 + offsetY);
    const prevX = cursor._x ?? x, prevY = cursor._y ?? y;
    const dist = Math.hypot(x-prevX,y-prevY)||1;
    const dur = Math.min(900, Math.max(140, dist * 0.45)) / Math.max(0.05, speed);
    cursor.style.transition = `transform ${dur}ms cubic-bezier(.2,.8,.2,1)`;
    cursor.style.transform = `translate(${x}px, ${y}px)`; cursor._x=x; cursor._y=y;
    await wait(dur + 40);
  }
  async function captionAt(el, text){
    if(!el) return;
    const r = el.getBoundingClientRect();
    caption.textContent = text;
    caption.style.left = (r.left + r.width/2) + 'px';
    caption.style.top = r.top + 'px';
    caption.style.opacity = '1';
    await wait(180);
  }

  function hideCaption(remove=false){
    if(!caption) return;
    caption.style.opacity='0';
    if(remove){ try{ caption.remove(); }catch{} }
  }

  async function clickEl(el){
    if(!el) return;
    el.classList.add('sim-click');
    el.dispatchEvent(new MouseEvent('mousedown',{bubbles:true}));
    el.dispatchEvent(new MouseEvent('mouseup',{bubbles:true}));
    el.dispatchEvent(new MouseEvent('click',{bubbles:true}));
    await wait(140); el.classList.remove('sim-click');
  }
  async function typeInto(inputEl, text, delay=55){
    if(!inputEl) return;
    ensureInView(inputEl);
    inputEl.focus && inputEl.focus(); inputEl.value='';
    for(const ch of text){
      inputEl.value += ch;
      inputEl.dispatchEvent(new Event('input',{bubbles:true}));
      await wait(delay + Math.random()*25);
    }
    inputEl.dispatchEvent(new Event('change',{bubbles:true}));
    await wait(100);
  }

  /* ====== Sélecteurs utilitaires ====== */
  function selectOptionByText(selEl, txt){
    for(const o of selEl.options){
      if(o.textContent.trim().toLowerCase()===String(txt).toLowerCase()){
        selEl.value=o.value; selEl.dispatchEvent(new Event('change',{bubbles:true}));
        return o.value;
      }
    }
    return null;
  }
  function selectManyByText(selectEl, texts){
    const set = new Set((texts||[]).map(t=>String(t).toLowerCase()));
    for(const o of selectEl.options) o.selected = set.has(o.textContent.trim().toLowerCase());
  }
  function selectOneByText(selectEl, text){
    for(const o of selectEl.options){
      if(o.textContent.trim().toLowerCase()===String(text).toLowerCase()){
        o.selected=true; return true;
      }
    }
    return false;
  }

  /* ====== Actions idempotentes ====== */
  async function ensureThreat(name){
    const sel = $('selectThreat'); if(!sel) return null;
    if(!selectOptionByText(sel, name)){
      await captionAt($('threatName'), 'Créer une menace');
      await moveToEl($('threatName')); await clickEl($('threatName'));
      await typeInto($('threatName'), name);
      await moveToEl($('addThreat')); await clickEl($('addThreat'));
      selectOptionByText(sel, name);
    }
    hideCaption(); await wait(120); return sel.value;
  }
  async function ensureMeanForSelectedThreat(mean){
    await captionAt($('meanName'), 'Ajouter un moyen');
    await moveToEl($('meanName')); await clickEl($('meanName')); await typeInto($('meanName'), mean);
    await moveToEl($('addMeanToThreat')); await clickEl($('addMeanToThreat'));
    hideCaption(); await wait(120);
  }
  async function ensureTarget(name, finalFlag=false){
    const sT = $('selectTarget'); if(!sT) return null;
    if(!selectOptionByText(sT, name)){
      await captionAt($('targetName'), 'Créer une cible' + (finalFlag?' (finale)':''));
      await moveToEl($('targetName')); await clickEl($('targetName')); await typeInto($('targetName'), name);
      if(finalFlag && !$('targetFinalFlag').checked){ await moveToEl($('targetFinalFlag')); await clickEl($('targetFinalFlag')); }
      await moveToEl($('addTarget')); await clickEl($('addTarget'));
      if(finalFlag && $('targetFinalFlag').checked){ $('targetFinalFlag').click(); } // reset checkbox
      selectOptionByText(sT, name);
    }
    hideCaption(); await wait(120); return sT.value;
  }
  async function ensureVuln(name){
    const sV = $('selectVulns'); if(!sV) return;
    if([...sV.options].some(o=>o.textContent.trim().toLowerCase()===name.toLowerCase())) return;
    await captionAt($('vulnName'), 'Ajouter une vulnérabilité');
    await moveToEl($('vulnName')); await clickEl($('vulnName')); await typeInto($('vulnName'), name);
    await moveToEl($('addVuln')); await clickEl($('addVuln')); hideCaption(); await wait(100);
  }

  async function setVulns(targetName, list){
    await captionAt($('selectTarget'), `Associer vulnérabilités à « ${targetName} »`);
    selectOptionByText($('selectTarget'), targetName);
    ensureInView(document.querySelector('div.row[style*="min-width:420px"] select'),'center');
    selectManyByText($('selectVulns'), list); pulse($('selectVulns'));
    await moveToEl($('saveTargetV')); await clickEl($('saveTargetV')); hideCaption(); await wait(120);
  }
  async function setEdges(from, tos){
    await captionAt($('selectEdges'), `Liens normaux depuis « ${from} »`);
    selectOptionByText($('selectTarget'), from); await wait(80);
    for(const o of $('selectEdges').options) o.selected=false;
    (tos||[]).forEach(t=>selectOneByText($('selectEdges'), t)); pulse($('selectEdges'));
    await moveToEl($('saveEdges')); await clickEl($('saveEdges')); hideCaption(); await wait(120);
  }
  async function setLaterals(from, tos){
    await captionAt($('selectLateral'), `Liens latéraux depuis « ${from} »`);
    selectOptionByText($('selectTarget'), from); await wait(80);
    for(const o of $('selectLateral').options) o.selected=false;
    (tos||[]).forEach(t=>selectOneByText($('selectLateral'), t)); pulse($('selectLateral'));
    await moveToEl($('saveLateral')); await clickEl($('saveLateral')); hideCaption(); await wait(120);
  }
  async function setStarts(threatName, starts){
    await captionAt($('selectStartPool'), `Déf. cibles de départ pour « ${threatName} »`);
    selectOptionByText($('selectThreat'), threatName); await wait(80);
    const pool = $('selectStartPool'); for(const o of pool.options) o.selected=false;
    (starts||[]).forEach(n=>selectOneByText(pool, n)); pulse(pool);
    await moveToEl($('btnAddStart')); await clickEl($('btnAddStart'));
    hideCaption(); await wait(120);
  }
  async function runFindAndDiagram(withLateral=true){
    await captionAt($('btnFindPaths'), 'Calculer tous les chemins');
    const chk = $('includeLateral'); if(chk && chk.checked !== withLateral){ await moveToEl(chk); await clickEl(chk); }
    await moveToEl($('btnFindPaths')); await clickEl($('btnFindPaths')); hideCaption(); await wait(400);

    const firstBtn = document.querySelector('#pathList .path-entry button');
    if(firstBtn){ await captionAt(firstBtn,'Afficher le diagramme'); ensureInView(firstBtn); await moveToEl(firstBtn); await clickEl(firstBtn); hideCaption(); await wait(350); }

    const dl = $('btnDownloadSVG');
    if(dl){ await captionAt(dl,'Télécharger le SVG'); await moveToEl(dl); await clickEl(dl); hideCaption(); await wait(250); }

    // Focus visuel du SVG
    const uml = $('umlContainer'); if(uml){ const o = uml.style.boxShadow; uml.style.boxShadow='0 0 0 3px rgba(59,130,246,.28)'; await wait(600); uml.style.boxShadow=o; }
  }

  /* ====== Scénarios denses ====== */

  // Outils pour reset propre et préparation
  async function hardReset(){
    if(!$('clearAll')) return;
    await captionAt($('clearAll'), 'Réinitialiser les données');
    await moveToEl($('clearAll')); await clickEl($('clearAll'));
    hideCaption(); await wait(200);
  }

  // Scénario 1 : Intrusion Web → DB → Console, latéral web→poste→AD
  async function scenarioWebToDB(){
    await hardReset();

    const th = 'Opérateur APT';
    const m1 = 'Botnet', m2 = 'Kit de Phishing';

    const tgWeb = 'Serveur Web DMZ';
    const tgDB  = 'Base de Données';
    const tgWks = 'Poste Utilisateur';
    const tgAD  = 'Contrôleur de Domaine';
    const tgConsole = 'Console Admin';

    const vXSS='XSS stockée', vSQLi='Injection SQL', vCred='Réutilisation d’identifiants', vCVE='CVE non patchée';

    await ensureThreat(th);
    await ensureMeanForSelectedThreat(m1);
    await ensureMeanForSelectedThreat(m2);

    await ensureTarget(tgWeb, false);
    await ensureTarget(tgDB,  false);
    await ensureTarget(tgWks, false);
    await ensureTarget(tgAD,  false);
    await ensureTarget(tgConsole, true);

    for(const v of [vXSS,vSQLi,vCred,vCVE]) await ensureVuln(v);

    await setVulns(tgWeb, [vXSS, vCVE]);
    await setVulns(tgDB,  [vSQLi, vCred]);
    await setVulns(tgWks, [vCred]);
    await setVulns(tgConsole,[vCred]);

    await setEdges(tgWeb, [tgDB]);
    await setEdges(tgDB,  [tgConsole]);

    await setLaterals(tgWeb, [tgWks]);
    await setLaterals(tgWks, [tgAD]);
    await setLaterals(tgAD,  [tgConsole]);

    await setStarts(th, [tgWeb]);

    await runFindAndDiagram(true);
  }

  // Scénario 2 : Campagne phishing → Poste → Fichiers → AD → Console (latéral dense)
  async function scenarioPhishingLateral(){
    await hardReset();

    const th = 'Campagne Phishing';
    const m1 = 'Kit d’emailing', m2 = 'Loader';

    const tgEmail='Email Gateway', tgWks='Poste Utilisateur', tgFiles='Serveur de Fichiers', tgAD='Contrôleur de Domaine', tgConsole='Console Admin';
    const vPhish='Phishing (HTML/Doc Macro)', vCred='Réutilisation d’identifiants', vCVE='CVE non patchée';

    await ensureThreat(th);
    await ensureMeanForSelectedThreat(m1);
    await ensureMeanForSelectedThreat(m2);

    await ensureTarget(tgEmail, false);
    await ensureTarget(tgWks,  false);
    await ensureTarget(tgFiles, false);
    await ensureTarget(tgAD,   false);
    await ensureTarget(tgConsole, true);

    for(const v of [vPhish,vCred,vCVE]) await ensureVuln(v);

    await setVulns(tgEmail, [vPhish]);
    await setVulns(tgWks,   [vCred]);
    await setVulns(tgFiles, [vCVE]);
    await setVulns(tgConsole,[vCred]);

    await setEdges(tgEmail, [tgWks]);
    await setLaterals(tgWks, [tgFiles, tgAD]);
    await setLaterals(tgFiles, [tgAD]);
    await setLaterals(tgAD, [tgConsole]);

    await setStarts(th, [tgEmail]);

    await runFindAndDiagram(true);
  }

  // Scénario 3 : Accès VPN faible → AD, branchement direct sans latéral
  async function scenarioVPNDirect(){
    await hardReset();

    const th='Exploitation Appliance VPN';
    const m='Exploit CVE';

    const tgVPN='VPN Appliance', tgAD='Contrôleur de Domaine', tgConsole='Console Admin';
    const vWeakVPN='VPN config faible', vCred='Réutilisation d’identifiants';

    await ensureThreat(th);
    await ensureMeanForSelectedThreat(m);

    await ensureTarget(tgVPN, false);
    await ensureTarget(tgAD,  false);
    await ensureTarget(tgConsole, true);

    for(const v of [vWeakVPN, vCred]) await ensureVuln(v);

    await setVulns(tgVPN, [vWeakVPN]);
    await setVulns(tgConsole, [vCred]);

    await setEdges(tgVPN, [tgAD]);
    await setEdges(tgAD,  [tgConsole]);

    await setStarts(th, [tgVPN]);

    await runFindAndDiagram(false);
  }

  // Scénario 4 : Mix realistic – deux menaces concurrentes partageant des cibles
  async function scenarioDualThreats(){
    await hardReset();

    // Menace 1
    const th1='Opérateur Red', m1a='Botnet', m1b='Proxy résidentiel';
    // Menace 2
    const th2='Malspam MaaS', m2a='Template Office', m2b='Dropper';

    // Cibles
    const tWeb='Serveur Web DMZ', tDB='Base de Données', tWks='Poste Utilisateur', tFiles='Serveur de Fichiers', tAD='Contrôleur de Domaine', tConsole='Console Admin';

    // Vulns
    const vXSS='XSS stockée', vSQLi='Injection SQL', vCred='Réutilisation d’identifiants', vOld='CVE non patchée';

    // Menace 1
    await ensureThreat(th1);
    await ensureMeanForSelectedThreat(m1a);
    await ensureMeanForSelectedThreat(m1b);

    // Menace 2
    await ensureThreat(th2);
    await ensureMeanForSelectedThreat(m2a);
    await ensureMeanForSelectedThreat(m2b);

    // Cibles
    await ensureTarget(tWeb,false);
    await ensureTarget(tDB,false);
    await ensureTarget(tWks,false);
    await ensureTarget(tFiles,false);
    await ensureTarget(tAD,false);
    await ensureTarget(tConsole,true);

    // Vulns
    for(const v of [vXSS,vSQLi,vCred,vOld]) await ensureVuln(v);
    await setVulns(tWeb,[vXSS,vOld]);
    await setVulns(tDB,[vSQLi,vCred]);
    await setVulns(tWks,[vCred]);
    await setVulns(tFiles,[vOld]);
    await setVulns(tConsole,[vCred]);

    // Liens
    await setEdges(tWeb,[tDB]);
    await setEdges(tDB,[tConsole]);
    await setLaterals(tWks,[tFiles,tAD]);
    await setLaterals(tFiles,[tAD]);
    await setLaterals(tAD,[tConsole]);

    // Départs multiples pour deux menaces
    await setStarts(th1,[tWeb, tWks]);
    await setStarts(th2,[tWks]);

    await runFindAndDiagram(true);
  }

  // Scénario 5 : Graphe avec cycle léger (pruning) pour démontrer l’anti-explosion
  async function scenarioCyclePruned(){
    await hardReset();

    const th='Worm latéral';
    const m='Scan réseau';

    const a='Poste A', b='Poste B', c='Poste C', d='Serveur MEP', z='Console Admin';
    const vCred='Réutilisation d’identifiants';

    await ensureThreat(th);
    await ensureMeanForSelectedThreat(m);

    await ensureTarget(a,false);
    await ensureTarget(b,false);
    await ensureTarget(c,false);
    await ensureTarget(d,false);
    await ensureTarget(z,true);

    await ensureVuln(vCred);
    await setVulns(z,[vCred]);

    // Cycle A→B→C→A (latéral), plus chemin vers D puis Z
    await setLaterals(a,[b]);
    await setLaterals(b,[c]);
    await setLaterals(c,[a,d]);
    await setEdges(d,[z]);

    await setStarts(th,[a]);

    await captionAt($('maxPaths'),'Plafond de chemins'); await moveToEl($('maxPaths')); $('maxPaths').value=1200; $('maxPaths').dispatchEvent(new Event('change',{bubbles:true})); hideCaption();
    await runFindAndDiagram(true);
  }

  const scenarios = [
    {name:'Intrusion Web → DB → Console (latéral web→poste→AD)', fn: scenarioWebToDB},
    {name:'Phishing → Poste → Fichiers/AD → Console (latéral dense)', fn: scenarioPhishingLateral},
    {name:'VPN faible → AD → Console (sans latéral)', fn: scenarioVPNDirect},
    {name:'Deux menaces concurrentes, départs multiples', fn: scenarioDualThreats},
    {name:'Cycle léger pruné (anti-explosion)', fn: scenarioCyclePruned},
  ];

  function pickScenario(){
    const idx = Math.floor(Math.random()*scenarios.length);
    return scenarios[idx];
  }

  /* ====== Lancement ====== */
  async function runDemo(){
    const btn = $('simulateBtn'); if(btn){ btn.disabled=true; btn.textContent='Simulation en cours…'; }
    try{
      if(!window.addThreat || !window.findAllPaths){
        alert('Fonctions de l’app introuvables : placer ce script APRÈS le script principal.');
        return;
      }
      ensureInView(document.querySelector('.app > .panel:nth-child(2)'),'start');

      const scenario = pickScenario();
      await captionAt($('simulateBtn'), `Scénario : ${scenario.name}`);
      await wait(400); hideCaption();

      await scenario.fn();

    } catch(e){
      console.error('[Simulation]', e);
      alert('La simulation a rencontré un problème (détails en console).');
    } finally {
      const btn = $('simulateBtn'); if(btn){ btn.disabled=false; btn.textContent='Simulation'; }
      hideCaption();
    }
  }

  const simBtn = $('simulateBtn');
  if(simBtn){
    simBtn.addEventListener('click', runDemo);
  } else {
    console.warn('simulateBtn introuvable — ajoute le bouton Simulation dans la topbar.');
  }
})();
</script>

</body>
</html>
